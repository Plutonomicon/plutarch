-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package plutarch
@version 1.3.0

module Plutarch.DataRepr.Internal.HList.Utils
newtype Labeled sym a
Labeled :: a -> Labeled sym a
[$sel:unLabeled:Labeled] :: Labeled sym a -> a

-- | GADT proof-witness of HList membership, usable as an index
data Elem (a :: k) (as :: [k])
[Here] :: Elem a (a ': as)
[There] :: Elem a as -> Elem a (b ': as)

-- | Indexing type-level lists
type family IndexList (n :: Nat) (l :: [k]) :: k

-- | Indexing list of labeled pairs by label
type family IndexLabel name as

-- | Return the single item from a singleton list
type family SingleItem (as :: [k]) :: k

-- | Drop first n fields of a list
type family Drop (n :: Nat) (as :: [k]) :: [k]

module Plutarch.Internal.PrettyStack
prettyStack :: Text -> CallStack -> Text

module Plutarch.Internal.Witness
witness :: c => Proxy c -> ()

module Plutarch.Pretty.Internal.Config
keywords :: Set Text
indentWidth :: Int

-- | Prefix to use for naming forced builtin functions.
forcedPrefix :: Text

module Plutarch.Pretty.Internal.BuiltinConstant
prettyConstant :: Some (ValueOf DefaultUni) -> Doc ()

module Plutarch.Pretty.Internal.TermUtils
unwrapLamAbs :: Index -> Term name uni fun ann -> (Index, Term name uni fun ann)
unwrapBindings :: [Term name uni fun ann] -> Term name uni fun ann -> ([Term name uni fun ann], Term name uni fun ann)
unwrapApply :: [Term name uni fun ann] -> Term name uni fun ann -> ([Term name uni fun ann], Term name uni fun ann)

-- | Increment the debruijn index of a <a>Var</a>, leave any other AST node
--   unchanged.
incrVar :: Term DeBruijn uni fun () -> Term DeBruijn uni fun ()
pattern PFixAst :: Term name uni fun ()
pattern ComposeAST :: Term DeBruijn uni fun () -> Term DeBruijn uni fun () -> Term DeBruijn uni fun ()
pattern IfThenElseLikeAST :: Term name uni fun () -> Term name uni fun () -> Term name uni fun () -> Term name uni fun () -> Term name uni fun ()

module Plutarch.Pretty.Internal.Types

-- | Notifies the prettifier what "state" the cursor currently is, so it
--   can decide whether or not to wrap the target expression in parens.
--   
--   Normal indicates no parens wrapping is necessary, even for complex
--   expressions.
--   
--   Special indicates complex expressions should be wrapped in parens.
--   
--   Usually, <a>Special</a> just hints at one of three states:
--   
--   <ol>
--   <li>Applying - The expression is being applied like a function.</li>
--   <li>Applied - The expression is being applied as a function
--   argument.</li>
--   <li>Unary arg - The expression is being used as an argument to a high
--   arity unary operator (~ and !).</li>
--   </ol>
data PrettyCursor
Normal :: PrettyCursor
Special :: PrettyCursor
data PrettyState
PrettyState :: Map Index Text -> Set Text -> PrettyCursor -> PrettyState
[$sel:ps'nameMap:PrettyState] :: PrettyState -> Map Index Text
[$sel:ps'names:PrettyState] :: PrettyState -> Set Text
[$sel:ps'cursor:PrettyState] :: PrettyState -> PrettyCursor
type PrettyMonad s = ReaderT (STGenM StdGen s) (StateT PrettyState (ST s))
forkState :: MonadState s m => m b -> m b
normalizeCursor :: PrettyState -> PrettyState
specializeCursor :: PrettyState -> PrettyState
memorizeName :: Text -> PrettyState -> PrettyState

-- | Insert a fresh binding onto the name map, i.e a name at index 0 -
--   incrementing all other indices.
insertName :: Text -> PrettyState -> PrettyState
insertBindings :: [Text] -> PrettyState -> PrettyState
builtinFunAtRef :: Map Index Text -> Index -> Maybe DefaultFun
nameOfRef :: Index -> Map Index Text -> Maybe Text
instance GHC.Show.Show Plutarch.Pretty.Internal.Types.PrettyCursor
instance GHC.Classes.Eq Plutarch.Pretty.Internal.Types.PrettyCursor
instance GHC.Enum.Enum Plutarch.Pretty.Internal.Types.PrettyCursor
instance GHC.Enum.Bounded Plutarch.Pretty.Internal.Types.PrettyCursor

module Plutarch.Pretty.Internal.Name
smartName :: Term DeBruijn uni DefaultFun () -> PrettyMonad s Text
freshVarName :: PrettyMonad s Text

module Plutarch.Script
newtype Script
Script :: Program DeBruijn DefaultUni DefaultFun () -> Script
[$sel:unScript:Script] :: Script -> Program DeBruijn DefaultUni DefaultFun ()
serialiseScript :: Script -> ShortByteString
deserialiseScript :: ShortByteString -> Script
instance GHC.Generics.Generic Plutarch.Script.Script
instance GHC.Show.Show Plutarch.Script.Script
instance GHC.Classes.Eq Plutarch.Script.Script

module Plutarch.Internal.Evaluate
uplcVersion :: Version

-- | Evaluate a script with a big budget, returning the trace log and term
--   result.
evalScript :: Script -> (Either EvalError Script, ExBudget, [Text])

-- | Evaluate a script with a huge budget, returning the trace log and term
--   result.
evalScriptHuge :: Script -> (Either EvalError Script, ExBudget, [Text])

-- | Evaluate a script with a specific budget, returning the trace log and
--   term result.
evalScript' :: ExBudget -> Script -> (Either (CekEvaluationException NamedDeBruijn DefaultUni DefaultFun) Script, ExBudget, [Text])
type EvalError = (CekEvaluationException NamedDeBruijn DefaultUni DefaultFun)

module Plutarch.Internal
newtype (:-->) (a :: PType) (b :: PType) (s :: S)
PLam :: (Term s a -> Term s b) -> (:-->) (a :: PType) (b :: PType) (s :: S)
infixr 0 :-->
data PDelayed (a :: PType) (s :: S)
newtype Term (s :: S) (a :: PType)
Term :: (Word64 -> TermMonad TermResult) -> Term (s :: S) (a :: PType)
[$sel:asRawTerm:Term] :: Term (s :: S) (a :: PType) -> Word64 -> TermMonad TermResult
asClosedRawTerm :: ClosedTerm a -> TermMonad TermResult
newtype Script
Script :: Program DeBruijn DefaultUni DefaultFun () -> Script
mapTerm :: (RawTerm -> RawTerm) -> TermResult -> TermResult

-- | Lambda abstraction.
--   
--   Only works with a single argument. Use <tt>plam</tt> instead, to
--   support currying.
plam' :: (Term s a -> Term s b) -> Term s (a :--> b)

-- | Let bindings.
--   
--   This is approximately a shorthand for a lambda and application:
--   
--   <tt>plet v f</tt> == <tt> papp (plam f) v</tt>
--   
--   But sufficiently small terms in WHNF may be inlined for efficiency.
plet :: Term s a -> (Term s a -> Term s b) -> Term s b

-- | Lambda Application.
papp :: Term s (a :--> b) -> Term s a -> Term s b

-- | Plutus 'delay', used for laziness.
pdelay :: Term s a -> Term s (PDelayed a)

-- | Plutus 'force', used to force evaluation of <a>PDelayed</a> terms.
pforce :: Term s (PDelayed a) -> Term s a
phoistAcyclic :: HasCallStack => ClosedTerm a -> Term s a

-- | Plutus 'error'.
--   
--   When using this explicitly, it should be ensured that the containing
--   term is delayed, avoiding premature evaluation.
perror :: Term s a

-- | Unsafely coerce the type-tag of a Term.
--   
--   This should mostly be avoided, though it can be safely used to assert
--   known types of Datums, Redeemers or ScriptContext.
punsafeCoerce :: Term s a -> Term s b
punsafeBuiltin :: DefaultFun -> Term s a

-- | <i>Deprecated: Use <tt>pconstant</tt> instead.</i>
punsafeConstant :: Some (ValueOf DefaultUni) -> Term s a
punsafeConstantInternal :: Some (ValueOf DefaultUni) -> Term s a

-- | Compile a (closed) Plutus Term to a usable script
compile :: Config -> ClosedTerm a -> Either Text Script
compile' :: TermResult -> UTerm

-- | <ul>
--   <li>Closed* terms with no free variables.</li>
--   </ul>
type ClosedTerm (a :: PType) = forall (s :: S). Term s a
type Dig = Digest Blake2b_160
hashTerm :: Config -> ClosedTerm a -> Either Text Dig
hashRawTerm :: RawTerm -> Dig
data RawTerm
RVar :: Word64 -> RawTerm
RLamAbs :: Word64 -> RawTerm -> RawTerm
RApply :: RawTerm -> [RawTerm] -> RawTerm
RForce :: RawTerm -> RawTerm
RDelay :: RawTerm -> RawTerm
RConstant :: Some (ValueOf DefaultUni) -> RawTerm
RBuiltin :: DefaultFun -> RawTerm
RCompiled :: UTerm -> RawTerm
RError :: RawTerm
RHoisted :: HoistedTerm -> RawTerm
data TermResult
TermResult :: RawTerm -> [HoistedTerm] -> TermResult
[$sel:getTerm:TermResult] :: TermResult -> RawTerm
[$sel:getDeps:TermResult] :: TermResult -> [HoistedTerm]
data S
SI :: S

-- | Shorthand for Plutarch types.
type PType = S -> Type
pthrow :: HasCallStack => Text -> Term s a
newtype Config
Config :: TracingMode -> Config
[$sel:tracingMode:Config] :: Config -> TracingMode
data TracingMode
NoTracing :: TracingMode
DetTracing :: TracingMode
DoTracing :: TracingMode
DoTracingAndBinds :: TracingMode
pgetConfig :: (Config -> Term s a) -> Term s a
newtype TermMonad m
TermMonad :: ReaderT Config (Either Text) m -> TermMonad m
[$sel:runTermMonad:TermMonad] :: TermMonad m -> ReaderT Config (Either Text) m

-- | High precedence infixl synonym of <a>papp</a>, to be used like
--   function juxtaposition. e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; f # x # y
--   f x y
--   </pre>
(#) :: Term s (a :--> b) -> Term s a -> Term s b
infixl 8 #

-- | Low precedence infixr synonym of <a>papp</a>, to be used like
--   <a>$</a>, in combination with <a>#</a>. e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; f # x #$ g # y # z
--   f x (g y z)
--   </pre>
(#$) :: Term s (a :--> b) -> Term s a -> Term s b
infixr 0 #$
instance GHC.Show.Show Plutarch.Internal.HoistedTerm
instance GHC.Show.Show Plutarch.Internal.RawTerm
instance GHC.Base.Monad Plutarch.Internal.TermMonad
instance GHC.Base.Applicative Plutarch.Internal.TermMonad
instance GHC.Base.Functor Plutarch.Internal.TermMonad
instance Data.Default.Class.Default Plutarch.Internal.Config

module Plutarch.Reducible

-- | This class provides a work-around for partially applying type families
--   of kind <tt>a</tt>, where <tt>a</tt> is either <a>Type</a> or <tt>b
--   -&gt; c</tt> where <tt>c</tt> satisfies the same constraint.
--   
--   Given a type family <tt>F : A -&gt; Type</tt>, you can make the
--   following <tt> type F' :: A -&gt; Type newtype F' (a :: A) = F'
--   (NoReduce (F a)) deriving stock Generic </tt> It is then true that
--   <tt>forall a. Reduce (F' a) ~ F a</tt>.
type family Reduce (x :: Type) :: Type
newtype NoReduce a
NoReduce :: a -> NoReduce a
reduce :: Coercible a (Reduce a) => a -> Reduce a

module Plutarch.Pretty

-- | Prettify a Plutarch term.
--   
--   This will call <a>error</a> if there's a compilation failure. Use
--   <a>prettyTerm'</a> for a non-partial version.
--   
--   <h2>Example ==</h2>
--   
--   <pre>
--   import Plutarch.Prelude
--   import Plutarch.Api.V1
--   import Plutarch.Extra.TermCont
--   
--   checkSignatory :: Term s (PPubKeyHash :--&gt; PScriptContext :--&gt; PUnit)
--   checkSignatory = plam $ ph ctx' -&gt; unTermCont $ do
--     ctx &lt;- pletFieldsC <tt>["txInfo", "purpose"] ctx'
--     purph &lt;- pmatchC ctx.purpose
--     pure $ case purph of
--       PSpending _ -&gt;
--         let signatories = pfield </tt>"signatories" # ctx.txInfo
--         in pif
--             (pelem # pdata ph # pfromData signatories)
--             -- Success!
--             (pconstant ())
--             -- Signature not present.
--             perror
--       _ -&gt; ptraceError "checkSignatoryCont: not a spending tx"
--   </pre>
--   
--   Prettification result:
--   
--   <pre>
--   let frSndPair = !!sndPair
--       unDataSum = (xF -&gt; frSndPair (unConstrData xF))
--       frTailList = !tailList
--       frHeadList = !headList
--       frIfThenElse = !ifThenElse
--   in (oP4ECBT qsrxlF0Y7 -&gt;
--         let cjlB6yrGk = unDataSum qsrxlF0Y7
--             cRFO = unConstrData (frHeadList (frTailList cjlB6yrGk))
--             cs9iR = !!fstPair cRFO
--             w4 = frSndPair cRFO
--         in if equalsInteger 1 cs9iR
--              then if (vModHwqYB -&gt;
--                         let blM6d67 =
--                               (x5sad ePDSInSEC -&gt;
--                                  !(!!chooseList
--                                      ePDSInSEC
--                                      ~False
--                                      ~(if equalsData
--                                             (frHeadList ePDSInSEC)
--                                             vModHwqYB
--                                          then True
--                                          else x5sad (frTailList ePDSInSEC))))
--                             mC = (jfZs -&gt; blM6d67 (itzT -&gt; jfZs jfZs itzT))
--                         in blM6d67 (ispwp_oeT -&gt; mC mC ispwp_oeT))
--                        (bData oP4ECBT)
--                        (unListData
--                           let q6X3 = frHeadList cjlB6yrGk
--                           in frHeadList
--                                let olbZ = unDataSum q6X3
--                                in frTailList
--                                     (frTailList
--                                        (frTailList
--                                           (frTailList
--                                              (frTailList
--                                                 (frTailList
--                                                    (frTailList olbZ)))))))
--                     then ()
--                     else ERROR
--              else !(!trace "checkSignatoryCont: not a spending tx" ~ERROR))
--   </pre>
--   
--   <h2>Semantics ==</h2>
--   
--   <h3>Constants ===</h3>
--   
--   <ul>
--   <li>Builtin integers are printed as regular integers. [0-9]+</li>
--   <li>Builtin bytestrings are printed in hex notation, prefixed by `0x`.
--   0x[0-9a-f]+/i</li>
--   <li>Builtin strings are printed as is.</li>
--   <li>Builtin unit is printed as the unit literal. ()</li>
--   <li>Builtin booleans are printed as the literal <a>True</a> or
--   <a>False</a>.</li>
--   <li>Builtin lists are prettified as list literals, i.e delimited with
--   `[` and `]`.</li>
--   <li>Builtin pairs are prettified as 2-ary tuple literals, e.g. `(a,
--   b)`.</li>
--   <li><tt>I</tt> data (i.e data encoded integers) are prettified like
--   builtin integers with a <tt>#</tt> prefix. #[0-9]+</li>
--   <li><tt>B</tt> data (i.e data encoded bytestrings) are prettified like
--   builtin bytestrings with a <tt>#</tt> prefix. #0x[0-9a-f]+/i</li>
--   <li><tt>List</tt> data (i.e data encoded lists) are prettified like
--   builtin lists with a <tt>#</tt> prefix.</li>
--   <li><tt>Map</tt> data is printed like record literals. Delimited by
--   `{` and `}`.</li>
--   </ul>
--   
--   Each key value pair is prettified like <a>key</a> = <a>value</a> and
--   multiple pairs are joined with `,`.
--   
--   For example, `Map [(I 42, I 0), (I 100, I 1)]` is prettified as `{ #42
--   = #0, #100 = #1 }` - Constr data has two core elements in its
--   prettified form:
--   
--   <ul>
--   <li>The constructor index, prettified as an integer prefixed with
--   <tt>Σ</tt> (sigma).</li>
--   <li>Its fields, prettified as a list.</li>
--   </ul>
--   
--   These two elements are then joined with a <a>.</a> (period).
--   
--   For example, `Constr 1 [I 42]` is prettified as "Σ1.[#42]".
--   
--   <h3>Builtin functions ===</h3>
--   
--   Builtin functions are prettified into their name, in title case.
--   
--   <h3>Forced term ===</h3>
--   
--   Forced terms are prefixed with a <tt>!</tt>. The unary operator
--   <tt>!</tt> has higher fixity than function application.
--   
--   <h3>Delayed term ===</h3>
--   
--   Delayed terms are prefixed with a <a>~</a>. The unary operator
--   <a>~</a> has higher fixity than function application.
--   
--   <h3>Var ===</h3>
--   
--   Random names are generated for all variable bindings, and these names
--   are used to refer to them.
--   
--   Names are always unique, between 1 and 8 characters in length, and
--   begin with a lowercase letter.
--   
--   Names may consist of alphanumeric characters, underscore, or single
--   quotes.
--   
--   <h3>LamAbs ===</h3>
--   
--   Lambdas are prettified similar to haskell lambdas, i.e `x -&gt; ...`.
--   
--   Lambdas with multiple arguments are detected and simplified: `x y z
--   -&gt; ...`.
--   
--   <h3>Apply ===</h3>
--   
--   Application is, simply, a space - just like haskell. `f x`.
--   
--   Multi arg applications to the same function are detected and
--   simplified: `f x y`.
--   
--   <h3>Error term ===</h3>
--   
--   <tt>perror</tt> is represented by the literal <tt>ERROR</tt>.
--   
--   <h3>Special handling ===</h3>
--   
--   To achieve better prettification, certain AST structures are given
--   special handling logic.
--   
--   <ul>
--   <li>The AST structure produced by <tt>plet</tt> (Single <a>Apply</a> +
--   <a>LamAbs</a> pair) is prettified into Haskell-like let bindings.</li>
--   <li>Lazy if<i>then</i>else (<tt>pif</tt> in particular, not
--   <tt>pif'</tt>) is detected and prettified into Haskell-like syntax:
--   `if cond then expr1 else expr2`.</li>
--   </ul>
--   
--   Chains of if<i>then</i>else are nested:
--   
--   <pre>
--   if cond
--     then expr1
--     else if cond
--       then expr2
--       else expr3
--   
--   </pre>
--   
--   <ul>
--   <li>When generating names for bindings, well known structures are
--   identified and given special names.</li>
--   </ul>
--   
--   This machinery is made to be extensible in the future.
--   
--   For example, the structure of the <tt>pfix</tt> function is well known
--   and constant - so it is simply called <tt>fix</tt> in the output.
--   
--   Bindings to forced builtin functions inherit the builtin function
--   name, prefixed with a <tt>fr</tt>.
prettyTerm :: Config -> ClosedTerm a -> Doc ()

-- | Non-partial <a>prettyTerm</a>.
prettyTerm' :: Config -> ClosedTerm p -> Either Text (Doc ())

-- | <a>prettyTerm</a> for pre-compiled <a>Script</a>s.
prettyScript :: Script -> Doc ()


-- | This module defines functions, associated type families, and newtypes
--   for use with <a><tt>DerivingVia</tt></a> to allow Plutarch to convert
--   to and from PTypes and Haskell types.
module Plutarch.Lift

-- | Create a Plutarch-level constant, from a Haskell value. Example: &gt;
--   pconstant @PInteger 42
pconstant :: forall p s. PLift p => PLifted p -> Term s p

-- | Like <a>plift'</a> but throws on failure.
plift :: forall p. (HasCallStack, PLift p) => ClosedTerm p -> PLifted p

-- | Convert a Plutarch term to the associated Haskell value. Fail
--   otherwise. This will fully evaluate the arbitrary closed expression,
--   and convert the resulting value.
plift' :: forall p. PUnsafeLiftDecl p => Config -> ClosedTerm p -> Either LiftError (PLifted p)

-- | Error during script evaluation.
data LiftError
LiftError_EvalError :: EvalError -> LiftError
LiftError_KnownTypeError :: KnownTypeError -> LiftError
LiftError_FromRepr :: LiftError
LiftError_CompilationError :: Text -> LiftError

-- | Class of Haskell types <tt>h</tt> that can be represented as a Plutus
--   core builtin and converted to a Plutarch type.
--   
--   The Plutarch type is determined by `PConstanted h`. Its Plutus Core
--   representation is given by `PConstantRepr h`.
--   
--   This typeclass is closely tied with <a>PLift</a>.
--   
--   Laws: - <tt>pconstantFromRepr . pconstantToRepr ≡ Just</tt> -
--   <tt>(pconstantToRepr <a>$</a>) . pconstantFromRepr ≡ Just</tt> -
--   <tt>plift . pfromData . flip ptryFrom fst . pconstant .
--   PlutusTx.toData ≡ id</tt> - <tt>PlutusTx.fromData . plift .
--   pforgetData . pdata . pconstant ≡ Just</tt>
--   
--   These laws must be upheld for the sake of soundness of the type
--   system.
class (PUnsafeLiftDecl (PConstanted h), DefaultUni `Includes` PConstantRepr h) => PConstantDecl (h :: Type) where {
    type PConstantRepr h :: Type;
    type PConstanted h :: PType;
}
pconstantToRepr :: PConstantDecl h => h -> PConstantRepr h
pconstantFromRepr :: PConstantDecl h => PConstantRepr h -> Maybe h

-- | Class of Plutarch types <tt>p</tt> that can be converted to/from a
--   Haskell type.
--   
--   The Haskell type is determined by `PLifted p`.
--   
--   This typeclass is closely tied with <a>PConstant</a>.
type PLift = PUnsafeLiftDecl

-- | Type synonym to simplify deriving of <tt>PConstant</tt> via
--   <tt>DerivePConstantViaNewtype</tt>.
--   
--   A newtype <tt>Foo a</tt> is considered <a>Constantable</a> if:
--   
--   <ul>
--   <li>The wrapped type <tt>a</tt> has a <tt>PConstant</tt>
--   instance.</li>
--   <li>The lifted type of <tt>a</tt> has a <tt>PUnsafeLiftDecl</tt>
--   instance.</li>
--   <li>There is type equality between <tt>a</tt> and <tt>PLifted
--   (PConstanted a)</tt>.</li>
--   </ul>
--   
--   These constraints are sufficient to derive a <tt>PConstant</tt>
--   instance for the newtype.
--   
--   For deriving <tt>PConstant</tt> for a wrapped type represented in UPLC
--   as <tt>Data</tt>, see <tt>DerivePConstantViaData</tt>.
type PConstant a = (a ~ PLifted (PConstanted a), PConstantDecl a)

-- | Newtype wrapper for deriving <tt>PConstant</tt> when the wrapped type
--   is directly represented by a builtin UPLC type that is <i>not</i>
--   <tt>Data</tt>.
--   
--   Ex: <tt>PInteger</tt> is directly represented as a builtin integer.
newtype DerivePConstantDirect (h :: Type) (p :: PType)
DerivePConstantDirect :: h -> DerivePConstantDirect (h :: Type) (p :: PType)

-- | Newtype wrapper for deriving <tt>PConstant</tt> when the wrapped type
--   is represented indirectly by a builtin UPLC type that is <i>not</i>
--   <tt>Data</tt>.
--   
--   Ex: <tt>PPubKeyHash</tt> is a newtype to a <tt>PByteString</tt> and
--   <tt>PByteString</tt> is directly represented as a builtin bytestring.
--   
--   Polymorphic types can be derived as follows:
--   
--   <pre>
--   newtype Foo a = Foo a
--   
--   newtype PFoo a s = PFoo (Term s a)
--   
--   instance forall a. PLift a =&gt; PUnsafeLiftDecl (PFoo a) where
--     type PLifted (PFoo a) = Foo (PLifted a)
--   
--   deriving via
--     ( DerivePConstantViaNewtype
--         (Foo a)
--         (PFoo (PConstanted a))
--         (PConstanted a)
--     )
--     instance
--       PConstant a =&gt;
--       PConstantDecl (Foo a)
--   </pre>
newtype DerivePConstantViaNewtype (h :: Type) (p :: PType) (p' :: PType)

-- | The Haskell newtype we are deriving a <tt>PConstant</tt> instance for
DerivePConstantViaNewtype :: h -> DerivePConstantViaNewtype (h :: Type) (p :: PType) (p' :: PType)
newtype DerivePConstantViaBuiltin (h :: Type) (p :: PType) (p' :: PType)
DerivePConstantViaBuiltin :: h -> DerivePConstantViaBuiltin (h :: Type) (p :: PType) (p' :: PType)

-- | Laws: - It must be that <tt>PConstantRepr (PLifted p)</tt> when
--   encoded as a constant in UPLC (via the <a>Constant</a> constructor) is
--   a valid <tt>p</tt>.
class (PConstantDecl (PLifted p), PConstanted (PLifted p) ~ p) => PUnsafeLiftDecl (p :: PType) where {
    type PLifted p = (r :: Type) | r -> p;
}
instance GHC.Classes.Eq Plutarch.Lift.LiftError
instance forall (p :: Plutarch.Internal.PType) (p' :: Plutarch.Internal.PType) h h'. (Plutarch.Lift.PLift p, Plutarch.Lift.PLift p', GHC.Types.Coercible @GHC.Types.Type h h', Plutarch.Lift.ToBuiltin' (Plutarch.Lift.PLifted p') h', Plutarch.Lift.FromBuiltin' h' (Plutarch.Lift.PLifted p')) => Plutarch.Lift.PConstantDecl (Plutarch.Lift.DerivePConstantViaBuiltin h p p')
instance forall arep a. PlutusTx.Builtins.Class.FromBuiltin arep a => Plutarch.Lift.FromBuiltin' arep a
instance Plutarch.Lift.FromBuiltin' PlutusTx.Builtins.Internal.BuiltinData PlutusCore.Data.Data
instance forall a arep. PlutusTx.Builtins.Class.ToBuiltin a arep => Plutarch.Lift.ToBuiltin' a arep
instance Plutarch.Lift.ToBuiltin' PlutusCore.Data.Data PlutusTx.Builtins.Internal.BuiltinData
instance forall (p :: Plutarch.Internal.PType) (p' :: Plutarch.Internal.PType) h. (Plutarch.Lift.PLift p, Plutarch.Lift.PLift p', GHC.Types.Coercible @GHC.Types.Type h (Plutarch.Lift.PLifted p')) => Plutarch.Lift.PConstantDecl (Plutarch.Lift.DerivePConstantViaNewtype h p p')
instance forall (p :: Plutarch.Internal.PType) h. (Plutarch.Lift.PLift p, Universe.Core.Includes @GHC.Types.Type PlutusCore.Default.Universe.DefaultUni h) => Plutarch.Lift.PConstantDecl (Plutarch.Lift.DerivePConstantDirect h p)

module Plutarch.Internal.TypeFamily

-- | Convert a list of `Term s a` to a list of <tt>a</tt>.
type family ToPType as
type family ToPType2 as
type family UnTerm x
type family Snd ab

module Plutarch.Internal.Quantification
newtype PForall (b :: a -> PType) s
PForall :: (forall (x :: a). Term s (b x)) -> PForall (b :: a -> PType) s
data PSome (b :: a -> PType) s
PSome :: Term s (b x) -> PSome (b :: a -> PType) s
newtype PFix f s
PFix :: Term s (f (PFix f)) -> PFix f s

module Plutarch.Internal.Generic

-- | <a>Generic</a> constraint extended to work with Plutarch types.
class (forall s. PGeneric' a s) => PGeneric a
class (Generic (a s), GFrom (a s), GTo (a s), All2 Top (PCode a), All2 Top (GCode (a s)), GDatatypeInfo (a s)) => PGeneric' a s

-- | Like <tt>Code</tt> but for Plutarch types
type PCode a = ToPType2 (GCode (a Any))
gpfrom :: forall a s. PGeneric a => a s -> SOP (Term s) (PCode a)
gpto :: forall a s. PGeneric a => SOP (Term s) (PCode a) -> a s
instance forall (a :: Plutarch.Internal.PType). (forall (s :: Plutarch.Internal.S). Plutarch.Internal.Generic.PGeneric' a s) => Plutarch.Internal.Generic.PGeneric a
instance forall (a :: Plutarch.Internal.S -> GHC.Types.Type) (s :: Plutarch.Internal.S). (GHC.Generics.Generic (a s), Generics.SOP.GGP.GFrom (a s), Generics.SOP.GGP.GTo (a s), Data.SOP.Constraint.All2 @{Plutarch.Internal.PType} (Data.SOP.Constraint.Top @{Plutarch.Internal.PType}) (Plutarch.Internal.Generic.PCode a), Data.SOP.Constraint.All2 @{GHC.Types.Type} (Data.SOP.Constraint.Top @{GHC.Types.Type}) (Generics.SOP.GGP.GCode (a s)), Generics.SOP.GGP.GDatatypeInfo (a s)) => Plutarch.Internal.Generic.PGeneric' a s
instance forall a. Generics.SOP.GGP.GTo a => Plutarch.Internal.Generic.GTo' a
instance forall a. Generics.SOP.GGP.GFrom a => Plutarch.Internal.Generic.GFrom' a

module Plutarch.Internal.PlutusType
class PlutusType (a :: PType)
type PlutusTypeStratConstraint strategy :: PType -> Constraint

-- | <i>Deprecated: Use PlutusType</i>
type PCon = PlutusType

-- | <i>Deprecated: Use PlutusType</i>
type PMatch = PlutusType
pcon' :: forall s. PlutusType a => a s -> Term s (PInner a)
pmatch' :: forall s b. PlutusType a => Term s (PInner a) -> (a s -> Term s b) -> Term s b

-- | Pattern match over Plutarch Terms via a Haskell datatype
pmatch :: PlutusType a => Term s a -> (a s -> Term s b) -> Term s b

-- | Construct a Plutarch Term via a Haskell datatype
pcon :: PlutusType a => a s -> Term s a
type PInner a :: PType
class PlutusTypeStrat (strategy :: Type)
class (PInner a ~ DerivedPInner (DPTStrat a) a, PlutusTypeStrat (DPTStrat a), PlutusTypeStratConstraint (DPTStrat a) a, PlutusType a) => DerivePlutusType (a :: PType)
type DPTStrat a :: Type
type DerivedPInner strategy (a :: PType) :: PType
derivedPCon :: forall a s. (PlutusTypeStrat strategy, DerivePlutusType a, DPTStrat a ~ strategy) => a s -> Term s (DerivedPInner strategy a)
derivedPMatch :: forall a s b. (PlutusTypeStrat strategy, DerivePlutusType a, DPTStrat a ~ strategy) => Term s (DerivedPInner strategy a) -> (a s -> Term s b) -> Term s b
class (forall t. PVariant'' t => PVariant'' (a t)) => PVariant a
class (forall t. PCovariant'' t => PCovariant'' (a t)) => PCovariant a
class (forall t. PCovariant'' t => PContravariant'' (a t)) => PContravariant a
type PVariant' a :: Constraint
type PCovariant' a :: Constraint
type PContravariant' a :: Constraint
instance forall (a :: Plutarch.Internal.PType -> Plutarch.Internal.PType). (forall (t :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PVariant'' t => Plutarch.Internal.PlutusType.PVariant'' (a t)) => Plutarch.Internal.PlutusType.PVariant a
instance forall (a :: Plutarch.Internal.PType -> Plutarch.Internal.PType). (forall (t :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PCovariant'' t => Plutarch.Internal.PlutusType.PContravariant'' (a t)) => Plutarch.Internal.PlutusType.PContravariant a
instance forall (a :: Plutarch.Internal.PType -> Plutarch.Internal.PType). (forall (t :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PCovariant'' t => Plutarch.Internal.PlutusType.PCovariant'' (a t)) => Plutarch.Internal.PlutusType.PCovariant a
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PCovariant' a => Plutarch.Internal.PlutusType.PCovariant'' a
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PContravariant' a => Plutarch.Internal.PlutusType.PContravariant'' a
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PVariant' a => Plutarch.Internal.PlutusType.PVariant'' a
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (a Plutarch.Internal.:--> b)
instance forall a (f :: a -> Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.Quantification.PForall @a f)
instance forall a (f :: a -> Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.Quantification.PSome @a f)
instance forall (f :: Plutarch.Internal.PType -> Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.Quantification.PFix f)

module Plutarch.Internal.ScottEncoding
data PlutusTypeScott
newtype PScottEncoded a r s
PScottEncoded :: Term s (ScottFn (ScottList a r) r) -> PScottEncoded a r s
instance forall (a :: Plutarch.Internal.PType). (forall (r :: Plutarch.Internal.PType). Plutarch.Internal.ScottEncoding.SListIScottList a r, Data.SOP.Constraint.SListI2 @{Plutarch.Internal.PType} (Plutarch.Internal.Generic.PCode a), Plutarch.Internal.Generic.PGeneric a) => Plutarch.Internal.ScottEncoding.PlutusTypeScottConstraint a
instance Plutarch.Internal.PlutusType.PlutusTypeStrat Plutarch.Internal.ScottEncoding.PlutusTypeScott
instance forall (a :: Plutarch.Internal.PType) (r :: Plutarch.Internal.PType). Data.SOP.Constraint.SListI @{Plutarch.Internal.PType} (Plutarch.Internal.ScottEncoding.ScottList (Plutarch.Internal.Generic.PCode a) r) => Plutarch.Internal.ScottEncoding.SListIScottList a r
instance forall (a :: [[Plutarch.Internal.PType]]) (r :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Internal.ScottEncoding.PScottEncoded a r)

module Plutarch.Internal.Other

-- | Prettyprint a Term via the PLC pretty printer
--   
--   TODO: Heavily improve. It's unreadable right now.
--   
--   We could convert the de Bruijn indices into names with:
--   
--   <pre>
--   show . prettyPlcReadableDef . (\(Right p) -&gt; p) . Scripts.mkTermToEvaluate . compile $ term
--   </pre>
printTerm :: HasCallStack => Config -> ClosedTerm a -> String

-- | Prettyprint a compiled Script via the PLC pretty printer
printScript :: Script -> String

-- | Safely coerce from a Term to it's <a>PInner</a> representation.
pto :: Term s a -> Term s (PInner a)

-- | Fixpoint recursion. Used to encode recursive functions.
--   
--   Example:
--   
--   <pre>
--   iterateN' ::
--    Term s (PInteger :--&gt; (a :--&gt; a) :--&gt; a :--&gt; a) -&gt;
--    Term s PInteger -&gt;
--    Term s (a :--&gt; a) -&gt;
--    Term s a
--   iterateN' self n f x =
--     pif (n #== 0) x (self # n - 1 #$ f x)
--   
--   iterateN :: Term s (PInteger :--&gt; (a :--&gt; a) :--&gt; a :--&gt; a)
--   iterateN = pfix #$ plam iterateN'
--   </pre>
--   
--   Further examples can be found in examples/Recursion.hs
pfix :: Term s (((a :--> b) :--> (a :--> b)) :--> (a :--> b))

-- | An Arbitrary Term with an unknown type
newtype POpaque s
POpaque :: Term s POpaque -> POpaque s

-- | Erase the type of a Term
popaque :: Term s a -> Term s POpaque
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Internal.Other.POpaque

module Plutarch.Internal.Newtype
data PlutusTypeNewtype
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Internal.Generic.PGeneric a, (Plutarch.Internal.Generic.PCode a :: [[Plutarch.Internal.PType]]) GHC.Types.~ ((':) @[Plutarch.Internal.PType] ((':) @Plutarch.Internal.PType (Plutarch.Internal.Newtype.GetPNewtype a) ('[] @Plutarch.Internal.PType)) ('[] @[Plutarch.Internal.PType]) :: [[Plutarch.Internal.PType]])) => Plutarch.Internal.Newtype.Helper a
instance Plutarch.Internal.PlutusType.PlutusTypeStrat Plutarch.Internal.Newtype.PlutusTypeNewtype

module Plutarch.Evaluate

-- | Evaluate a script with a big budget, returning the trace log and term
--   result.
evalScript :: Script -> (Either EvalError Script, ExBudget, [Text])

-- | Evaluate a script with a huge budget, returning the trace log and term
--   result.
evalScriptHuge :: Script -> (Either EvalError Script, ExBudget, [Text])

-- | Evaluate a script with a specific budget, returning the trace log and
--   term result.
evalScript' :: ExBudget -> Script -> (Either (CekEvaluationException NamedDeBruijn DefaultUni DefaultFun) Script, ExBudget, [Text])
type EvalError = (CekEvaluationException NamedDeBruijn DefaultUni DefaultFun)

-- | Compile and evaluate term.
evalTerm :: Config -> ClosedTerm a -> Either Text (Either EvalError (ClosedTerm a), ExBudget, [Text])

module Plutarch.Api.Internal.Hashing

-- | Hash a Script with the given version prefix
hashScriptWithPrefix :: ByteString -> Script -> ScriptHash

-- | Hash Plutus <tt>Data</tt>.
hashData :: Data -> BuiltinByteString

-- | Hash <tt>LedgerBytes</tt>.
hashLedgerBytes :: LedgerBytes -> BuiltinByteString

module Plutarch.TryFrom

-- | <tt>PTryFrom a b</tt> represents a subtyping relationship between
--   <tt>a</tt> and <tt>b</tt>, and a way to go from <tt>a</tt> to
--   <tt>b</tt>. Laws: - <tt>(punsafeCoerce . fst) <a>$</a> tcont (ptryFrom
--   x) ≡ pure x</tt>
class PSubtype a b => PTryFrom (a :: PType) (b :: PType) where {
    type PTryFromExcess a b :: PType;
    type PTryFromExcess a b = PTryFromExcess a (PInner b);
}
ptryFrom' :: forall s r. PTryFrom a b => Term s a -> ((Term s b, Reduce (PTryFromExcess a b s)) -> Term s r) -> Term s r
ptryFrom' :: forall s r. (PTryFrom a b, PTryFrom a (PInner b), PTryFromExcess a b ~ PTryFromExcess a (PInner b)) => Term s a -> ((Term s b, Reduce (PTryFromExcess a b s)) -> Term s r) -> Term s r
ptryFrom :: forall b a s r. PTryFrom a b => Term s a -> ((Term s b, Reduce (PTryFromExcess a b s)) -> Term s r) -> Term s r
data PSubtypeRelation
PSubtypeRelation :: PSubtypeRelation
PNoSubtypeRelation :: PSubtypeRelation
type family PSubtype (a :: PType) (b :: PType) :: Constraint
type family PSubtype' (a :: PType) (b :: PType) :: PSubtypeRelation
pupcast :: forall a b s. PSubtype a b => Term s b -> Term s a
pupcastF :: forall a b (p :: PType -> PType) s. (PSubtype a b, PCovariant p) => Proxy p -> Term s (p b) -> Term s (p a)
pdowncastF :: forall a b (p :: PType -> PType) s. (PSubtype a b, PContravariant p) => Proxy p -> Term s (p a) -> Term s (p b)

module Plutarch.Unsafe
punsafeBuiltin :: DefaultFun -> Term s a

-- | Unsafely coerce the type-tag of a Term.
--   
--   This should mostly be avoided, though it can be safely used to assert
--   known types of Datums, Redeemers or ScriptContext.
punsafeCoerce :: Term s a -> Term s b

-- | <i>Deprecated: Use <tt>pconstant</tt> instead.</i>
punsafeConstant :: Some (ValueOf DefaultUni) -> Term s a

-- | Unsafely coerce from the <a>PInner</a> representation of a Term,
--   assuming that the value is a safe construction of the Term.
punsafeDowncast :: Term s (PInner a) -> Term s a

module Plutarch.Num
class PNum (a :: PType)
(#+) :: PNum a => Term s a -> Term s a -> Term s a
(#+) :: (PNum a, PNum (PInner a)) => Term s a -> Term s a -> Term s a
(#-) :: PNum a => Term s a -> Term s a -> Term s a
(#-) :: (PNum a, PNum (PInner a)) => Term s a -> Term s a -> Term s a
(#*) :: PNum a => Term s a -> Term s a -> Term s a
(#*) :: (PNum a, PNum (PInner a)) => Term s a -> Term s a -> Term s a
pnegate :: PNum a => Term s (a :--> a)
pnegate :: (PNum a, PNum (PInner a)) => Term s (a :--> a)
pabs :: PNum a => Term s (a :--> a)
pabs :: (PNum a, PNum (PInner a)) => Term s (a :--> a)
psignum :: PNum a => Term s (a :--> a)
psignum :: (PNum a, PNum (PInner a)) => Term s (a :--> a)
pfromInteger :: PNum a => Integer -> Term s a
pfromInteger :: (PNum a, PNum (PInner a)) => Integer -> Term s a
infix 6 #+
infix 6 #-
infix 6 #*
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). Plutarch.Num.PNum a => GHC.Num.Num (Plutarch.Internal.Term s a)

module Plutarch.Internal.Trace

-- | Trace the given message before evaluating the argument.
ptrace :: Term s PString -> Term s a -> Term s a
ptrace' :: Term s (PString :--> (a :--> a))

module Plutarch.Internal.PLam
plam :: forall c. (PLamN a b s, HasCallStack) => (Term s c -> a) -> Term s (c :--> b)
pinl :: Term s a -> (Term s a -> Term s b) -> Term s b
instance forall a' (s :: Plutarch.Internal.S) (a :: Plutarch.Internal.PType). ((a' :: GHC.Types.Type) GHC.Types.~ (Plutarch.Internal.Term s a :: GHC.Types.Type)) => Plutarch.Internal.PLam.PLamN a' a s
instance forall a' (s :: Plutarch.Internal.S) (a :: Plutarch.Internal.PType) b' (b :: Plutarch.Internal.PType). ((a' :: GHC.Types.Type) GHC.Types.~ (Plutarch.Internal.Term s a :: GHC.Types.Type), Plutarch.Internal.PLam.PLamN b' b s) => Plutarch.Internal.PLam.PLamN (a' -> b') (a Plutarch.Internal.:--> b) s

module Plutarch.Bool

-- | Plutus <tt>BuiltinBool</tt>
data PBool (s :: S)
PTrue :: PBool (s :: S)
PFalse :: PBool (s :: S)
class PEq t
(#==) :: PEq t => Term s t -> Term s t -> Term s PBool
(#==) :: (PEq t, PGeneric t, PlutusType t, All2 PEq (PCode t)) => Term s t -> Term s t -> Term s PBool
infix 4 #==

-- | Partial ordering relation.
class PEq t => PPartialOrd t
(#<=) :: PPartialOrd t => Term s t -> Term s t -> Term s PBool
(#<=) :: (PPartialOrd t, POrd (PInner t)) => Term s t -> Term s t -> Term s PBool
(#<) :: PPartialOrd t => Term s t -> Term s t -> Term s PBool
(#<) :: (PPartialOrd t, POrd (PInner t)) => Term s t -> Term s t -> Term s PBool
infix 4 #<=
infix 4 #<

-- | Total ordering relation.
class PPartialOrd t => POrd t

-- | Lazy if-then-else.
pif :: Term s PBool -> Term s a -> Term s a -> Term s a

-- | Strict version of <a>pif</a>. Emits slightly less code.
pif' :: Term s (PBool :--> (a :--> (a :--> a)))

-- | Boolean negation for <a>PBool</a> terms.
pnot :: Term s (PBool :--> PBool)

-- | Lazily evaluated boolean and for <a>PBool</a> terms.
(#&&) :: Term s PBool -> Term s PBool -> Term s PBool
infixr 3 #&&

-- | Lazily evaluated boolean or for <a>PBool</a> terms.
(#||) :: Term s PBool -> Term s PBool -> Term s PBool
infixr 2 #||

-- | Hoisted, Plutarch level, lazily evaluated boolean or function.
por :: Term s (PBool :--> (PDelayed PBool :--> PDelayed PBool))

-- | Hoisted, Plutarch level, lazily evaluated boolean and function.
pand :: Term s (PBool :--> (PDelayed PBool :--> PDelayed PBool))

-- | Hoisted, Plutarch level, strictly evaluated boolean and function.
pand' :: Term s (PBool :--> (PBool :--> PBool))

-- | Hoisted, Plutarch level, strictly evaluated boolean or function.
por' :: Term s (PBool :--> (PBool :--> PBool))

-- | Scott-encoded bool.
data PSBool (s :: S)
PSTrue :: PSBool (s :: S)
PSFalse :: PSBool (s :: S)

-- | Strict version of <a>pmatch</a> for <a>PSBool</a>.
pmatchStrict :: forall (r :: PType) (s :: S). Term s PSBool -> (PSBool s -> Term s r) -> Term s r
pstrue :: forall (s :: S). Term s PSBool
psfalse :: forall (s :: S). Term s PSBool

-- | Lazy <tt>if</tt> on Scott-encoded bool.
psif :: forall (s :: S) (a :: PType). Term s PSBool -> Term s a -> Term s a -> Term s a

-- | Strict <tt>if</tt> on Scott-encoded bool.
psif' :: forall (s :: S) (a :: PType). Term s PSBool -> Term s a -> Term s a -> Term s a

-- | <tt>not</tt> on Scott-encoded bool.
psnot :: forall (s :: S). Term s PSBool -> Term s PSBool
psand :: forall (s :: S). Term s PSBool -> Term s PSBool -> Term s PSBool
psand' :: forall (s :: S). Term s PSBool -> Term s PSBool -> Term s PSBool
psor :: forall (s :: S). Term s PSBool -> Term s PSBool -> Term s PSBool
psor' :: forall (s :: S). Term s PSBool -> Term s PSBool -> Term s PSBool
instance forall (s :: Plutarch.Internal.S). GHC.Show.Show (Plutarch.Bool.PBool s)
instance forall (s :: Plutarch.Internal.S). GHC.Show.Show (Plutarch.Bool.PSBool s)
instance forall (s :: Plutarch.Internal.S). GHC.Classes.Ord (Plutarch.Bool.PSBool s)
instance forall (s :: Plutarch.Internal.S). GHC.Classes.Eq (Plutarch.Bool.PSBool s)
instance Plutarch.Lift.PConstantDecl GHC.Types.Bool
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Bool.PSBool
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Bool.PSBoolRaw a)
instance Plutarch.Bool.PPartialOrd Plutarch.Bool.PBool
instance Plutarch.Bool.POrd Plutarch.Bool.PBool
instance Plutarch.Bool.PEq Plutarch.Bool.PBool
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Bool.PBool
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Bool.PBool

module Plutarch.Integer

-- | Plutus BuiltinInteger
data PInteger s
class PIntegral a
pdiv :: PIntegral a => Term s (a :--> (a :--> a))
pdiv :: (PIntegral a, PIntegral (PInner a)) => Term s (a :--> (a :--> a))
pmod :: PIntegral a => Term s (a :--> (a :--> a))
pmod :: (PIntegral a, PIntegral (PInner a)) => Term s (a :--> (a :--> a))
pquot :: PIntegral a => Term s (a :--> (a :--> a))
pquot :: (PIntegral a, PIntegral (PInner a)) => Term s (a :--> (a :--> a))
prem :: PIntegral a => Term s (a :--> (a :--> a))
prem :: (PIntegral a, PIntegral (PInner a)) => Term s (a :--> (a :--> a))
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Integer.PInteger
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Integer.PInteger s)
instance Plutarch.Lift.PConstantDecl GHC.Num.Integer.Integer
instance Plutarch.Integer.PIntegral Plutarch.Integer.PInteger
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Integer.PInteger
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Integer.PInteger
instance Plutarch.Bool.PEq Plutarch.Integer.PInteger
instance Plutarch.Bool.PPartialOrd Plutarch.Integer.PInteger
instance Plutarch.Bool.POrd Plutarch.Integer.PInteger
instance Plutarch.Num.PNum Plutarch.Integer.PInteger

module Plutarch.ByteString

-- | Plutus <tt>BuiltinByteString</tt>
data PByteString s

-- | Interpret a hex string as a PByteString.
phexByteStr :: HasCallStack => String -> Term s PByteString

-- | Construct a PByteString term from a Haskell bytestring.

-- | <i>Deprecated: Use <a>pconstant</a> instead.</i>
pbyteStr :: ByteString -> Term s PByteString

-- | Prepend a byte, represented by a non negative <a>PInteger</a>, to a
--   <tt>PBytestring</tt>.
pconsBS :: Term s (PInteger :--> (PByteString :--> PByteString))

-- | Slice a <a>PByteString</a> with given start index and slice length.
--   
--   <pre>
--   &gt;&gt;&gt; (pslice # 2 # 3 phexByteStr "4102afde5b2a") #== phexByteStr "afde5b"
--   </pre>
psliceBS :: Term s (PInteger :--> (PInteger :--> (PByteString :--> PByteString)))

-- | Find the length of a <a>PByteString</a>.
plengthBS :: Term s (PByteString :--> PInteger)

-- | <a>PByteString</a> indexing function.
pindexBS :: Term s (PByteString :--> (PInteger :--> PInteger))
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.ByteString.PByteString
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.ByteString.PByteString s)
instance Plutarch.Lift.PConstantDecl Data.ByteString.Internal.Type.ByteString
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.ByteString.PByteString
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.ByteString.PByteString
instance Plutarch.Bool.PEq Plutarch.ByteString.PByteString
instance Plutarch.Bool.PPartialOrd Plutarch.ByteString.PByteString
instance Plutarch.Bool.POrd Plutarch.ByteString.PByteString
instance forall (s :: Plutarch.Internal.S). GHC.Base.Semigroup (Plutarch.Internal.Term s Plutarch.ByteString.PByteString)
instance forall (s :: Plutarch.Internal.S). GHC.Base.Monoid (Plutarch.Internal.Term s Plutarch.ByteString.PByteString)

module Plutarch.String

-- | Plutus <tt>BuiltinString</tt> values
data PString s

-- | Create a PString from <a>Text</a>

-- | <i>Deprecated: Use <a>pconstant</a> instead.</i>
pfromText :: Text -> Term s PString

-- | Encode a <a>PString</a> using UTF-8.
pencodeUtf8 :: Term s (PString :--> PByteString)

-- | Decode a <a>PByteString</a> using UTF-8.
pdecodeUtf8 :: Term s (PByteString :--> PString)
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.String.PString
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.String.PString s)
instance Plutarch.Lift.PConstantDecl Data.Text.Internal.Text
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.String.PString
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.String.PString
instance forall (s :: Plutarch.Internal.S). Data.String.IsString (Plutarch.Internal.Term s Plutarch.String.PString)
instance Plutarch.Bool.PEq Plutarch.String.PString
instance forall (s :: Plutarch.Internal.S). GHC.Base.Semigroup (Plutarch.Internal.Term s Plutarch.String.PString)
instance forall (s :: Plutarch.Internal.S). GHC.Base.Monoid (Plutarch.Internal.Term s Plutarch.String.PString)

module Plutarch.Show
class PShow t

-- | Return the string representation of a Plutarch value
--   
--   If the wrap argument is True, optionally wrap the output in `(..)` if
--   it represents multiple parameters.
pshow' :: PShow t => Bool -> Term s t -> Term s PString

-- | Return the string representation of a Plutarch value
--   
--   If the wrap argument is True, optionally wrap the output in `(..)` if
--   it represents multiple parameters.
pshow' :: (PShow t, PGeneric t, PlutusType t, All2 PShow (PCode t)) => Bool -> Term s t -> Term s PString

-- | Return the string representation of a Plutarch value
pshow :: PShow a => Term s a -> Term s PString

-- | Causes an error where the input is shown in the message. Works for all
--   types.
pshowAndErr :: Term s a -> Term s b
instance Plutarch.Show.PShow Plutarch.String.PString
instance Plutarch.Show.PShow Plutarch.Bool.PBool
instance Plutarch.Show.PShow Plutarch.Integer.PInteger
instance Plutarch.Show.PShow Plutarch.ByteString.PByteString

module Plutarch.Trace

-- | Trace the given message before evaluating the argument.
ptrace :: Term s PString -> Term s a -> Term s a

-- | Like Haskell's <tt>traceShowId</tt> but for Plutarch
ptraceShowId :: PShow a => Term s a -> Term s a

-- | Trace the given message if the argument evaluates to true.
ptraceIfTrue :: Term s PString -> Term s PBool -> Term s PBool

-- | Trace the given message if the argument evaluates to False.
ptraceIfFalse :: Term s PString -> Term s PBool -> Term s PBool

-- | Trace the given message and terminate evaluation with a <a>perror</a>.
ptraceError :: Term s PString -> Term s a

module Plutarch.TermCont
hashOpenTerm :: Term s a -> TermCont s Dig
newtype TermCont :: forall (r :: PType). S -> Type -> Type
[TermCont] :: forall r s a. ((a -> Term s r) -> Term s r) -> TermCont @r s a
($sel:runTermCont:TermCont) :: TermCont @r s a -> (a -> Term s r) -> Term s r
unTermCont :: TermCont @a s (Term s a) -> Term s a
tcont :: ((a -> Term s r) -> Term s r) -> TermCont @r s a
instance forall (r :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Base.Functor (Plutarch.TermCont.TermCont @r s)
instance forall (r :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Base.Applicative (Plutarch.TermCont.TermCont @r s)
instance forall (r :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Base.Monad (Plutarch.TermCont.TermCont @r s)
instance forall (r :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). Control.Monad.Fail.MonadFail (Plutarch.TermCont.TermCont @r s)

module Plutarch
data (:-->) (a :: PType) (b :: PType) (s :: S)
infixr 0 :-->

-- | <ul>
--   <li>Closed* terms with no free variables.</li>
--   </ul>
type ClosedTerm (a :: PType) = forall (s :: S). Term s a

-- | Compile a (closed) Plutus Term to a usable script
compile :: Config -> ClosedTerm a -> Either Text Script
newtype Script
Script :: Program DeBruijn DefaultUni DefaultFun () -> Script
type Dig = Digest Blake2b_160
hashTerm :: Config -> ClosedTerm a -> Either Text Dig

-- | Lambda Application.
papp :: Term s (a :--> b) -> Term s a -> Term s b

-- | Plutus 'delay', used for laziness.
pdelay :: Term s a -> Term s (PDelayed a)
data PDelayed (a :: PType) (s :: S)

-- | Plutus 'error'.
--   
--   When using this explicitly, it should be ensured that the containing
--   term is delayed, avoiding premature evaluation.
perror :: Term s a

-- | Plutus 'force', used to force evaluation of <a>PDelayed</a> terms.
pforce :: Term s (PDelayed a) -> Term s a
phoistAcyclic :: HasCallStack => ClosedTerm a -> Term s a

-- | Let bindings.
--   
--   This is approximately a shorthand for a lambda and application:
--   
--   <tt>plet v f</tt> == <tt> papp (plam f) v</tt>
--   
--   But sufficiently small terms in WHNF may be inlined for efficiency.
plet :: Term s a -> (Term s a -> Term s b) -> Term s b
pthrow :: HasCallStack => Text -> Term s a
data Term (s :: S) (a :: PType)
data S

-- | Shorthand for Plutarch types.
type PType = S -> Type

-- | Low precedence infixr synonym of <a>papp</a>, to be used like
--   <a>$</a>, in combination with <a>#</a>. e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; f # x #$ g # y # z
--   f x (g y z)
--   </pre>
(#$) :: Term s (a :--> b) -> Term s a -> Term s b
infixr 0 #$

-- | High precedence infixl synonym of <a>papp</a>, to be used like
--   function juxtaposition. e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; f # x # y
--   f x y
--   </pre>
(#) :: Term s (a :--> b) -> Term s a -> Term s b
infixl 8 #
class PlutusType (a :: PType)
type PInner a :: PType

-- | Construct a Plutarch Term via a Haskell datatype
pcon :: PlutusType a => a s -> Term s a

-- | Pattern match over Plutarch Terms via a Haskell datatype
pmatch :: PlutusType a => Term s a -> (a s -> Term s b) -> Term s b

-- | <i>Deprecated: Use PlutusType</i>
type PCon = PlutusType

-- | <i>Deprecated: Use PlutusType</i>
type PMatch = PlutusType

-- | Prettify a Plutarch term.
--   
--   This will call <a>error</a> if there's a compilation failure. Use
--   <a>prettyTerm'</a> for a non-partial version.
--   
--   <h2>Example ==</h2>
--   
--   <pre>
--   import Plutarch.Prelude
--   import Plutarch.Api.V1
--   import Plutarch.Extra.TermCont
--   
--   checkSignatory :: Term s (PPubKeyHash :--&gt; PScriptContext :--&gt; PUnit)
--   checkSignatory = plam $ ph ctx' -&gt; unTermCont $ do
--     ctx &lt;- pletFieldsC <tt>["txInfo", "purpose"] ctx'
--     purph &lt;- pmatchC ctx.purpose
--     pure $ case purph of
--       PSpending _ -&gt;
--         let signatories = pfield </tt>"signatories" # ctx.txInfo
--         in pif
--             (pelem # pdata ph # pfromData signatories)
--             -- Success!
--             (pconstant ())
--             -- Signature not present.
--             perror
--       _ -&gt; ptraceError "checkSignatoryCont: not a spending tx"
--   </pre>
--   
--   Prettification result:
--   
--   <pre>
--   let frSndPair = !!sndPair
--       unDataSum = (xF -&gt; frSndPair (unConstrData xF))
--       frTailList = !tailList
--       frHeadList = !headList
--       frIfThenElse = !ifThenElse
--   in (oP4ECBT qsrxlF0Y7 -&gt;
--         let cjlB6yrGk = unDataSum qsrxlF0Y7
--             cRFO = unConstrData (frHeadList (frTailList cjlB6yrGk))
--             cs9iR = !!fstPair cRFO
--             w4 = frSndPair cRFO
--         in if equalsInteger 1 cs9iR
--              then if (vModHwqYB -&gt;
--                         let blM6d67 =
--                               (x5sad ePDSInSEC -&gt;
--                                  !(!!chooseList
--                                      ePDSInSEC
--                                      ~False
--                                      ~(if equalsData
--                                             (frHeadList ePDSInSEC)
--                                             vModHwqYB
--                                          then True
--                                          else x5sad (frTailList ePDSInSEC))))
--                             mC = (jfZs -&gt; blM6d67 (itzT -&gt; jfZs jfZs itzT))
--                         in blM6d67 (ispwp_oeT -&gt; mC mC ispwp_oeT))
--                        (bData oP4ECBT)
--                        (unListData
--                           let q6X3 = frHeadList cjlB6yrGk
--                           in frHeadList
--                                let olbZ = unDataSum q6X3
--                                in frTailList
--                                     (frTailList
--                                        (frTailList
--                                           (frTailList
--                                              (frTailList
--                                                 (frTailList
--                                                    (frTailList olbZ)))))))
--                     then ()
--                     else ERROR
--              else !(!trace "checkSignatoryCont: not a spending tx" ~ERROR))
--   </pre>
--   
--   <h2>Semantics ==</h2>
--   
--   <h3>Constants ===</h3>
--   
--   <ul>
--   <li>Builtin integers are printed as regular integers. [0-9]+</li>
--   <li>Builtin bytestrings are printed in hex notation, prefixed by `0x`.
--   0x[0-9a-f]+/i</li>
--   <li>Builtin strings are printed as is.</li>
--   <li>Builtin unit is printed as the unit literal. ()</li>
--   <li>Builtin booleans are printed as the literal <a>True</a> or
--   <a>False</a>.</li>
--   <li>Builtin lists are prettified as list literals, i.e delimited with
--   `[` and `]`.</li>
--   <li>Builtin pairs are prettified as 2-ary tuple literals, e.g. `(a,
--   b)`.</li>
--   <li><tt>I</tt> data (i.e data encoded integers) are prettified like
--   builtin integers with a <tt>#</tt> prefix. #[0-9]+</li>
--   <li><tt>B</tt> data (i.e data encoded bytestrings) are prettified like
--   builtin bytestrings with a <tt>#</tt> prefix. #0x[0-9a-f]+/i</li>
--   <li><tt>List</tt> data (i.e data encoded lists) are prettified like
--   builtin lists with a <tt>#</tt> prefix.</li>
--   <li><tt>Map</tt> data is printed like record literals. Delimited by
--   `{` and `}`.</li>
--   </ul>
--   
--   Each key value pair is prettified like <a>key</a> = <a>value</a> and
--   multiple pairs are joined with `,`.
--   
--   For example, `Map [(I 42, I 0), (I 100, I 1)]` is prettified as `{ #42
--   = #0, #100 = #1 }` - Constr data has two core elements in its
--   prettified form:
--   
--   <ul>
--   <li>The constructor index, prettified as an integer prefixed with
--   <tt>Σ</tt> (sigma).</li>
--   <li>Its fields, prettified as a list.</li>
--   </ul>
--   
--   These two elements are then joined with a <a>.</a> (period).
--   
--   For example, `Constr 1 [I 42]` is prettified as "Σ1.[#42]".
--   
--   <h3>Builtin functions ===</h3>
--   
--   Builtin functions are prettified into their name, in title case.
--   
--   <h3>Forced term ===</h3>
--   
--   Forced terms are prefixed with a <tt>!</tt>. The unary operator
--   <tt>!</tt> has higher fixity than function application.
--   
--   <h3>Delayed term ===</h3>
--   
--   Delayed terms are prefixed with a <a>~</a>. The unary operator
--   <a>~</a> has higher fixity than function application.
--   
--   <h3>Var ===</h3>
--   
--   Random names are generated for all variable bindings, and these names
--   are used to refer to them.
--   
--   Names are always unique, between 1 and 8 characters in length, and
--   begin with a lowercase letter.
--   
--   Names may consist of alphanumeric characters, underscore, or single
--   quotes.
--   
--   <h3>LamAbs ===</h3>
--   
--   Lambdas are prettified similar to haskell lambdas, i.e `x -&gt; ...`.
--   
--   Lambdas with multiple arguments are detected and simplified: `x y z
--   -&gt; ...`.
--   
--   <h3>Apply ===</h3>
--   
--   Application is, simply, a space - just like haskell. `f x`.
--   
--   Multi arg applications to the same function are detected and
--   simplified: `f x y`.
--   
--   <h3>Error term ===</h3>
--   
--   <tt>perror</tt> is represented by the literal <tt>ERROR</tt>.
--   
--   <h3>Special handling ===</h3>
--   
--   To achieve better prettification, certain AST structures are given
--   special handling logic.
--   
--   <ul>
--   <li>The AST structure produced by <tt>plet</tt> (Single <a>Apply</a> +
--   <a>LamAbs</a> pair) is prettified into Haskell-like let bindings.</li>
--   <li>Lazy if<i>then</i>else (<tt>pif</tt> in particular, not
--   <tt>pif'</tt>) is detected and prettified into Haskell-like syntax:
--   `if cond then expr1 else expr2`.</li>
--   </ul>
--   
--   Chains of if<i>then</i>else are nested:
--   
--   <pre>
--   if cond
--     then expr1
--     else if cond
--       then expr2
--       else expr3
--   
--   </pre>
--   
--   <ul>
--   <li>When generating names for bindings, well known structures are
--   identified and given special names.</li>
--   </ul>
--   
--   This machinery is made to be extensible in the future.
--   
--   For example, the structure of the <tt>pfix</tt> function is well known
--   and constant - so it is simply called <tt>fix</tt> in the output.
--   
--   Bindings to forced builtin functions inherit the builtin function
--   name, prefixed with a <tt>fr</tt>.
prettyTerm :: Config -> ClosedTerm a -> Doc ()

-- | <a>prettyTerm</a> for pre-compiled <a>Script</a>s.
prettyScript :: Script -> Doc ()

-- | Prettyprint a Term via the PLC pretty printer
--   
--   TODO: Heavily improve. It's unreadable right now.
--   
--   We could convert the de Bruijn indices into names with:
--   
--   <pre>
--   show . prettyPlcReadableDef . (\(Right p) -&gt; p) . Scripts.mkTermToEvaluate . compile $ term
--   </pre>
printTerm :: HasCallStack => Config -> ClosedTerm a -> String

-- | Prettyprint a compiled Script via the PLC pretty printer
printScript :: Script -> String
pinl :: Term s a -> (Term s a -> Term s b) -> Term s b

-- | Safely coerce from a Term to it's <a>PInner</a> representation.
pto :: Term s a -> Term s (PInner a)

-- | Fixpoint recursion. Used to encode recursive functions.
--   
--   Example:
--   
--   <pre>
--   iterateN' ::
--    Term s (PInteger :--&gt; (a :--&gt; a) :--&gt; a :--&gt; a) -&gt;
--    Term s PInteger -&gt;
--    Term s (a :--&gt; a) -&gt;
--    Term s a
--   iterateN' self n f x =
--     pif (n #== 0) x (self # n - 1 #$ f x)
--   
--   iterateN :: Term s (PInteger :--&gt; (a :--&gt; a) :--&gt; a :--&gt; a)
--   iterateN = pfix #$ plam iterateN'
--   </pre>
--   
--   Further examples can be found in examples/Recursion.hs
pfix :: Term s (((a :--> b) :--> (a :--> b)) :--> (a :--> b))

-- | An Arbitrary Term with an unknown type
newtype POpaque s
POpaque :: Term s POpaque -> POpaque s

-- | Erase the type of a Term
popaque :: Term s a -> Term s POpaque
plam :: forall c. (PLamN a b s, HasCallStack) => (Term s c -> a) -> Term s (c :--> b)
newtype TermCont :: forall (r :: PType). S -> Type -> Type
[TermCont] :: forall r s a. ((a -> Term s r) -> Term s r) -> TermCont @r s a
hashOpenTerm :: Term s a -> TermCont s Dig
($sel:runTermCont:TermCont) :: TermCont @r s a -> (a -> Term s r) -> Term s r
unTermCont :: TermCont @a s (Term s a) -> Term s a
newtype Config
Config :: TracingMode -> Config
[$sel:tracingMode:Config] :: Config -> TracingMode
data TracingMode
NoTracing :: TracingMode
DetTracing :: TracingMode
DoTracing :: TracingMode
DoTracingAndBinds :: TracingMode
pgetConfig :: (Config -> Term s a) -> Term s a
newtype PForall (b :: a -> PType) s
PForall :: (forall (x :: a). Term s (b x)) -> PForall (b :: a -> PType) s
data PSome (b :: a -> PType) s
PSome :: Term s (b x) -> PSome (b :: a -> PType) s
newtype PScottEncoded a r s
PScottEncoded :: Term s (ScottFn (ScottList a r) r) -> PScottEncoded a r s
data PlutusTypeScott
data PlutusTypeNewtype
class (PInner a ~ DerivedPInner (DPTStrat a) a, PlutusTypeStrat (DPTStrat a), PlutusTypeStratConstraint (DPTStrat a) a, PlutusType a) => DerivePlutusType (a :: PType)
type DPTStrat a :: Type
class (forall t. PCovariant'' t => PCovariant'' (a t)) => PCovariant a
type PCovariant' a :: Constraint
class (forall t. PCovariant'' t => PContravariant'' (a t)) => PContravariant a
type PContravariant' a :: Constraint
class (forall t. PVariant'' t => PVariant'' (a t)) => PVariant a
type PVariant' a :: Constraint

module Plutarch.Unit
data PUnit s
PUnit :: PUnit s
instance Plutarch.Lift.PConstantDecl ()
instance Plutarch.Lift.PUnsafeLiftDecl (Plutarch.Unit.PUnit @{Plutarch.Internal.S})
instance Plutarch.Internal.PlutusType.PlutusType (Plutarch.Unit.PUnit @{Plutarch.Internal.S})
instance Plutarch.Bool.PEq (Plutarch.Unit.PUnit @{Plutarch.Internal.S})
instance Plutarch.Bool.PPartialOrd (Plutarch.Unit.PUnit @{Plutarch.Internal.S})
instance Plutarch.Bool.POrd (Plutarch.Unit.PUnit @{Plutarch.Internal.S})
instance forall (s :: Plutarch.Internal.S). GHC.Base.Semigroup (Plutarch.Internal.Term s (Plutarch.Unit.PUnit @{Plutarch.Internal.S}))
instance forall (s :: Plutarch.Internal.S). GHC.Base.Monoid (Plutarch.Internal.Term s (Plutarch.Unit.PUnit @{Plutarch.Internal.S}))
instance Plutarch.Show.PShow (Plutarch.Unit.PUnit @{Plutarch.Internal.S})

module Plutarch.Pair

-- | Plutus encoding of Pairs.
--   
--   Note: This is represented differently than <tt>BuiltinPair</tt>. It is
--   scott-encoded.
data PPair (a :: PType) (b :: PType) (s :: S)
PPair :: Term s a -> Term s b -> PPair (a :: PType) (b :: PType) (s :: S)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). (Plutarch.Show.PShow a, Plutarch.Show.PShow b) => Plutarch.Show.PShow (Plutarch.Pair.PPair a b)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). (Plutarch.Bool.PEq a, Plutarch.Bool.PEq b) => Plutarch.Bool.PEq (Plutarch.Pair.PPair a b)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Pair.PPair a b)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Pair.PPair a b s)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Pair.PPair a b)

module Plutarch.Maybe

-- | Plutus Maybe type, with Scott-encoded repr
data PMaybe (a :: PType) (s :: S)
PJust :: Term s a -> PMaybe (a :: PType) (s :: S)
PNothing :: PMaybe (a :: PType) (s :: S)

-- | fallible unwrapping from <tt>PMaybe</tt>
pfromJust :: Term s (PMaybe a :--> a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Show.PShow a => Plutarch.Show.PShow (Plutarch.Maybe.PMaybe a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Bool.PEq a => Plutarch.Bool.PEq (Plutarch.Maybe.PMaybe a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Maybe.PMaybe a)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Maybe.PMaybe a s)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Maybe.PMaybe a)


-- | Scott-encoded lists and ListLike typeclass
module Plutarch.List
data PList (a :: PType) (s :: S)
PSCons :: Term s a -> Term s (PList a) -> PList (a :: PType) (s :: S)
PSNil :: PList (a :: PType) (s :: S)

-- | Plutarch types that behave like lists.
class PListLike (list :: PType -> PType) where {
    type PElemConstraint list (a :: PType) :: Constraint;
}

-- | Canonical eliminator for list-likes.
pelimList :: (PListLike list, PElemConstraint list a) => (Term s a -> Term s (list a) -> Term s r) -> Term s r -> Term s (list a) -> Term s r

-- | Cons an element onto an existing list.
pcons :: (PListLike list, PElemConstraint list a) => Term s (a :--> (list a :--> list a))

-- | The empty list
pnil :: (PListLike list, PElemConstraint list a) => Term s (list a)

-- | Return the first element of a list. Partial, throws an error upon
--   encountering an empty list.
phead :: (PListLike list, PElemConstraint list a) => Term s (list a :--> a)

-- | Take the tail of a list, meaning drop its head. Partial, throws an
--   error upon encountering an empty list.
ptail :: (PListLike list, PElemConstraint list a) => Term s (list a :--> list a)

-- | <i> O(1) </i>. Check if a list is empty
pnull :: (PListLike list, PElemConstraint list a) => Term s (list a :--> PBool)

-- | 'PIsListLike list a' constraints <tt>list</tt> be a <a>PListLike</a>
--   with valid element type, <tt>a</tt>.
type PIsListLike list a = (PListLike list, PElemConstraint list a)

-- | <i> O(n) </i>. Convert from any ListLike to any ListLike, provided
--   both lists' element constraints are met.
pconvertLists :: forall f g a s. (PIsListLike f a, PIsListLike g a) => Term s (f a :--> g a)
pshowList :: forall list a s. (PShow a, PIsListLike list a) => Term s (list a :--> PString)

-- | <i> O(min(n, m)) </i>. Check if two lists are equal.
plistEquals :: (PIsListLike list a, PEq a) => Term s (list a :--> (list a :--> PBool))

-- | <i> O(n) </i>. Check if element is in the list
pelem :: (PIsListLike list a, PEq a) => Term s (a :--> (list a :--> PBool))

-- | <i> O(n) </i>. Count the number of elements in the list
plength :: PIsListLike list a => Term s (list a :--> PInteger)

-- | Index a BuiltinList, throwing an error if the index is out of bounds.
ptryIndex :: PIsListLike list a => Natural -> Term s (list a) -> Term s a

-- | Drop the first n fields of a List.
--   
--   The term will be statically generated as repeated applications of
--   <a>ptail</a>, which will be more efficient in many circumstances.
pdrop :: PIsListLike list a => Natural -> Term s (list a) -> Term s (list a)

-- | <i> O(n) </i>. like haskell level <tt>find</tt> but on plutarch level
pfind :: PIsListLike l a => Term s ((a :--> PBool) :--> (l a :--> PMaybe a))

-- | <i> O(n) </i>. Like Haskell level <a>(!!)</a> but on the Plutarch
--   level, not infix and with arguments reversed, errors if the specified
--   index is greater than or equal to the lists length
pelemAt :: PIsListLike l a => Term s (PInteger :--> (l a :--> a))

-- | <i> O(n) </i>. Like Haskell level <a>(!!)</a> but on the plutarch
--   level
(#!!) :: PIsListLike l a => Term s (l a) -> Term s PInteger -> Term s a

-- | <i> O(1) </i>. Create a singleton list from an element
psingleton :: PIsListLike list a => Term s (a :--> list a)

-- | Extract head and tail of the list, if list is not empty.
puncons :: PIsListLike list a => Term s (list a :--> PMaybe (PPair a (list a)))

-- | Extract head and tail of the list, throws error if list is empty.
ptryUncons :: PIsListLike list a => Term s (list a :--> PPair a (list a))

-- | <i> O(n) </i>. Concatenate two lists
--   
--   Example: &gt; pconcat # psingleton x # psingleton y == plistLiteral
--   [x, y]
--   
--   pconcat exhibits identities with empty lists such that &gt; forall x.
--   pconcat # pnil # x == x &gt; forall x. pconcat # x # pnil == x
pconcat :: PIsListLike list a => Term s (list a :--> (list a :--> list a))

-- | <i> O(min(n, m)) </i>. Zip two lists together with a passed function.
--   
--   If the lists are of differing lengths, cut to the shortest.
pzipWith :: (PListLike list, PElemConstraint list a, PElemConstraint list b, PElemConstraint list c) => Term s ((a :--> (b :--> c)) :--> (list a :--> (list b :--> list c)))

-- | Like <a>pzipWith</a> but with Haskell-level merge function.
pzipWith' :: (PListLike list, PElemConstraint list a, PElemConstraint list b, PElemConstraint list c) => (Term s a -> Term s b -> Term s c) -> Term s (list a :--> (list b :--> list c))

-- | <i> O(min(n, m)) </i>. Zip two lists together, creating pairs of the
--   elements.
--   
--   If the lists are of differing lengths, cut to the shortest.
pzip :: (PListLike list, PElemConstraint list a, PElemConstraint list b, PElemConstraint list (PPair a b)) => Term s (list a :--> (list b :--> list (PPair a b)))

-- | <i> O(n) </i>. Map a function over a list of elements
pmap :: (PListLike list, PElemConstraint list a, PElemConstraint list b) => Term s ((a :--> b) :--> (list a :--> list b))

-- | <i> O(n) </i>. Filter elements from a list that don't match the
--   predicate.
pfilter :: PIsListLike list a => Term s ((a :--> PBool) :--> (list a :--> list a))

-- | Like <a>pelimList</a>, but with a fixpoint recursion hatch.
precList :: PIsListLike list a => (Term s (list a :--> r) -> Term s a -> Term s (list a) -> Term s r) -> (Term s (list a :--> r) -> Term s r) -> Term s (list a :--> r)

-- | <i> O(n) </i>. Fold on a list right-associatively.
pfoldr :: PIsListLike list a => Term s ((a :--> (b :--> b)) :--> (b :--> (list a :--> b)))

-- | The same as <a>pfoldr'</a>, but with Haskell-level reduction function.
pfoldr' :: PIsListLike list a => (forall s. Term s a -> Term s b -> Term s b) -> Term s (b :--> (list a :--> b))

-- | <i> O(n) </i>. Fold on a list right-associatively, with opportunity
--   for short circuting.
--   
--   May short circuit when given reducer function is lazy in its second
--   argument.
pfoldrLazy :: PIsListLike list a => Term s ((a :--> (PDelayed b :--> b)) :--> (b :--> (list a :--> b)))

-- | <i> O(n) </i>. Fold on a list left-associatively.
pfoldl :: PIsListLike list a => Term s ((b :--> (a :--> b)) :--> (b :--> (list a :--> b)))

-- | The same as <a>pfoldl</a>, but with Haskell-level reduction function.
pfoldl' :: PIsListLike list a => (forall s. Term s b -> Term s a -> Term s b) -> Term s (b :--> (list a :--> b))

-- | <i> O(n) </i>. Check that predicate holds for all elements in a list.
pall :: PIsListLike list a => Term s ((a :--> PBool) :--> (list a :--> PBool))

-- | <i> O(n) </i>. Check that predicate holds for any element in a list.
pany :: PIsListLike list a => Term s ((a :--> PBool) :--> (list a :--> PBool))
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.List.PList a)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.List.PList a s)
instance Plutarch.List.PListLike Plutarch.List.PList
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.List.PList a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Show.PShow a => Plutarch.Show.PShow (Plutarch.List.PList a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Bool.PEq a => Plutarch.Bool.PEq (Plutarch.List.PList a)

module Plutarch.Either
data PEither (a :: PType) (b :: PType) (s :: S)
PLeft :: Term s a -> PEither (a :: PType) (b :: PType) (s :: S)
PRight :: Term s b -> PEither (a :: PType) (b :: PType) (s :: S)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). (Plutarch.Show.PShow a, Plutarch.Show.PShow b) => Plutarch.Show.PShow (Plutarch.Either.PEither a b)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). (Plutarch.Bool.PEq a, Plutarch.Bool.PEq b) => Plutarch.Bool.PEq (Plutarch.Either.PEither a b)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Either.PEither a b)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Either.PEither a b s)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Either.PEither a b)

module Plutarch.Crypto

-- | Hash a <a>PByteString</a> using SHA-256.
psha2_256 :: Term s (PByteString :--> PByteString)

-- | Hash a <a>PByteString</a> using SHA3-256.
psha3_256 :: Term s (PByteString :--> PByteString)

-- | Hash a <a>PByteString</a> using Blake2B-256.
pblake2b_256 :: Term s (PByteString :--> PByteString)

-- | Verify the signature against the public key and message.

-- | <i>Deprecated: use one of the Ed25519, Schnorr- or ECDSA Secp256k1
--   signature verification functions</i>
pverifySignature :: Term s (PByteString :--> (PByteString :--> (PByteString :--> PBool)))

-- | Verify an ED25519 signature arguments are in this order: pubkey,
--   message, signature
pverifyEd25519Signature :: Term s (PByteString :--> (PByteString :--> (PByteString :--> PBool)))

-- | Verify an ECDSA SECP256k1 signature arguments are in this order:
--   pubkey, message, signature
pverifyEcdsaSecp256k1Signature :: Term s (PByteString :--> (PByteString :--> (PByteString :--> PBool)))

-- | Verify a Schnorr SECP256k1 signature arguments are in this order:
--   pubkey, message, signature
pverifySchnorrSecp256k1Signature :: Term s (PByteString :--> (PByteString :--> (PByteString :--> PBool)))

module Plutarch.Builtin
data PData (s :: S)
pfstBuiltin :: Term s (PBuiltinPair a b :--> a)
psndBuiltin :: Term s (PBuiltinPair a b :--> b)
pasConstr :: Term s (PData :--> PBuiltinPair PInteger (PBuiltinList PData))
pasMap :: Term s (PData :--> PBuiltinList (PBuiltinPair PData PData))
pasList :: Term s (PData :--> PBuiltinList PData)
pasInt :: Term s (PData :--> PInteger)
plistData :: Term s (PBuiltinList PData :--> PData)

-- | Create a Plutarch-level <a>PAsData</a> constant, from a Haskell value.
--   Example: &gt; pconstantData @PInteger 42
pconstantData :: forall p h s. (ToData h, PLifted p ~ h, PConstanted h ~ p) => h -> Term s (PAsData p)
pconstrBuiltin :: Term s (PInteger :--> (PBuiltinList PData :--> PAsData (PBuiltinPair PInteger (PBuiltinList PData))))
pasByteStr :: Term s (PData :--> PByteString)

-- | Plutus <tt>BuiltinPair</tt>
data PBuiltinPair (a :: PType) (b :: PType) (s :: S)

-- | Plutus <tt>BuiltinList</tt>
data PBuiltinList (a :: PType) (s :: S)
PCons :: Term s a -> Term s (PBuiltinList a) -> PBuiltinList (a :: PType) (s :: S)
PNil :: PBuiltinList (a :: PType) (s :: S)

-- | <i>Deprecated: Use <a>pconstant</a> instead.</i>
pdataLiteral :: Data -> Term s PData

-- | Laws: - If <tt>PSubtype PData a</tt>, then <tt>pdataImpl a</tt> must
--   be <a>pupcast</a>. - pdataImpl . pupcast . pfromDataImpl ≡ id -
--   pfromDataImpl . punsafeDowncast . pdataImpl ≡ id
class PIsData a
pfromDataImpl :: PIsData a => Term s (PAsData a) -> Term s a
pfromDataImpl :: (PIsData a, PIsData (PInner a)) => Term s (PAsData a) -> Term s a
pdataImpl :: PIsData a => Term s a -> Term s PData
pdataImpl :: (PIsData a, PIsData (PInner a)) => Term s a -> Term s PData
pdata :: PIsData a => Term s a -> Term s (PAsData a)
pfromData :: PIsData a => Term s (PAsData a) -> Term s a
data PAsData (a :: PType) (s :: S)
pforgetData :: forall s a. Term s (PAsData a) -> Term s PData

-- | Inverse of <a>pforgetData'</a>.
prememberData :: forall (p :: PType -> PType) s. PVariant p => Proxy p -> Term s (p PData) -> Term s (p (PAsData PData))

-- | Like <a>prememberData</a> but generalised.
prememberData' :: forall a (p :: PType -> PType) s. (PSubtype PData a, PVariant p) => Proxy p -> Term s (p a) -> Term s (p (PAsData a))

-- | Serialise any builtin data to its cbor represented by a builtin
--   bytestring
pserialiseData :: Term s (PData :--> PByteString)

-- | Construct a builtin pair of <a>PData</a> elements.
--   
--   Uses <a>PAsData</a> to preserve more information about the underlying
--   <a>PData</a>.
ppairDataBuiltin :: Term s (PAsData a :--> (PAsData b :--> PBuiltinPair (PAsData a) (PAsData b)))
pchooseListBuiltin :: Term s (PBuiltinList a :--> (b :--> (b :--> b)))
pchooseData :: Term s (PData :--> (a :--> (a :--> (a :--> (a :--> (a :--> a))))))
instance forall k (f :: k -> Plutarch.Internal.PType) (a :: k). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Builtin.Helper2 @{k} f a)
instance forall k (f :: k -> Plutarch.Internal.PType) (a :: k) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Builtin.Helper2 @{k} f a s)
instance forall k1 k2 (f :: k2 -> k1 -> Plutarch.Internal.PType) (b :: k1) (a :: k2). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Builtin.Helper3 @{k2} @{k1} f b a)
instance forall k1 k2 (f :: k2 -> k1 -> Plutarch.Internal.PType) (b :: k1) (a :: k2) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Builtin.Helper3 @{k2} @{k1} f b a s)
instance forall k1 k2 (f :: k2 -> k1 -> Plutarch.Internal.PType) (b :: k1) (a :: k2). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Builtin.Helper4 @{k2} @{k1} f b a)
instance forall k1 k2 (f :: k2 -> k1 -> Plutarch.Internal.PType) (b :: k1) (a :: k2) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Builtin.Helper4 @{k2} @{k1} f b a s)
instance forall k1 k2 (f :: k2 -> k1 -> GHC.Types.Type) (a :: k1) (b :: k2). GHC.Generics.Generic (Plutarch.Builtin.Flip @{k2} @{k1} f a b)
instance Plutarch.Lift.PConstantDecl PlutusCore.Data.Data
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.Integer.PInteger)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.ByteString.PByteString)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.Builtin.PBuiltinList Plutarch.Builtin.PData))
instance forall (a :: Plutarch.Internal.PType). (Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData a), Plutarch.Builtin.PIsData a) => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.Builtin.PBuiltinList (Plutarch.Builtin.PAsData a)))
instance forall (a :: Plutarch.Internal.PType) (a' :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType) (b' :: Plutarch.Internal.PType). (Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData a, (a :: Plutarch.Internal.PType) GHC.Types.~ (Plutarch.Builtin.PAsData a' :: Plutarch.Internal.PType), Plutarch.Builtin.PIsData a', Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData b, (b :: Plutarch.Internal.PType) GHC.Types.~ (Plutarch.Builtin.PAsData b' :: Plutarch.Internal.PType), Plutarch.Builtin.PIsData b') => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.Builtin.PBuiltinPair a b))
instance forall k1 k2 (f :: k1 -> k2 -> Plutarch.Internal.PType) (b :: k2) (a :: k1). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Builtin.Helper4 @{k1} @{k2} f b a)
instance Plutarch.Builtin.PIsData (Plutarch.Builtin.PBuiltinPair Plutarch.Builtin.PData Plutarch.Builtin.PData)
instance forall k1 k2 (f :: k1 -> k2 -> Plutarch.Internal.PType) (b :: k2) (a :: k1). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Builtin.Helper3 @{k1} @{k2} f b a)
instance forall k (f :: k -> Plutarch.Internal.PType) (a :: k). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Builtin.Helper2 @{k} f a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Builtin.PIsData (Plutarch.Builtin.PBuiltinList a) => Plutarch.Builtin.Fc 'GHC.Types.True a
instance forall (a :: Plutarch.Internal.PType). Plutarch.Builtin.PIsData a => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Builtin.PAsData a)
instance Plutarch.Builtin.PIsData Plutarch.Builtin.PData
instance forall (a :: Plutarch.Internal.PType). Plutarch.TryFrom.PSubtype Plutarch.Builtin.PData a => Plutarch.Builtin.PIsData (Plutarch.Builtin.PBuiltinList a)
instance Plutarch.Builtin.PIsData Plutarch.Integer.PInteger
instance Plutarch.Builtin.PIsData Plutarch.ByteString.PByteString
instance Plutarch.Builtin.PIsData Plutarch.Bool.PBool
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). Plutarch.Builtin.PIsData (Plutarch.Builtin.PBuiltinPair (Plutarch.Builtin.PAsData a) (Plutarch.Builtin.PAsData b))
instance Plutarch.Builtin.PIsData (Plutarch.Unit.PUnit @{Plutarch.Internal.S})
instance Plutarch.Builtin.PIsData (Plutarch.Builtin.PBuiltinPair Plutarch.Integer.PInteger (Plutarch.Builtin.PBuiltinList Plutarch.Builtin.PData))
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Builtin.PIsData a, Plutarch.Show.PShow a) => Plutarch.Show.PShow (Plutarch.Builtin.PAsData a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Lift.PConstantDecl (Plutarch.Builtin.PAsDataLifted a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Lift.PUnsafeLiftDecl (Plutarch.Builtin.PAsData a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Builtin.Fc (Plutarch.Builtin.F a) a => Plutarch.Bool.PEq (Plutarch.Builtin.PBuiltinList a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Bool.PEq (Plutarch.Builtin.PAsData a)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.Builtin.PData)
instance Plutarch.Show.PShow Plutarch.Builtin.PData
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Builtin.PData
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Builtin.PData
instance Plutarch.Bool.PEq Plutarch.Builtin.PData
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData Plutarch.Builtin.PData
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Lift.PLift a, Plutarch.Bool.PEq a) => Plutarch.Builtin.Fc 'GHC.Types.False a
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Show.PShow a, Plutarch.Lift.PLift a) => Plutarch.Show.PShow (Plutarch.Builtin.PBuiltinList a)
instance forall a. Plutarch.Lift.PConstant a => Plutarch.Lift.PConstantDecl [a]
instance forall (a :: Plutarch.Internal.PType). Plutarch.Lift.PUnsafeLiftDecl a => Plutarch.Lift.PUnsafeLiftDecl (Plutarch.Builtin.PBuiltinList a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Lift.PLift a => Plutarch.Internal.PlutusType.PlutusType (Plutarch.Builtin.PBuiltinList a)
instance Plutarch.List.PListLike Plutarch.Builtin.PBuiltinList
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Builtin.PBuiltinPair a b)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). (Plutarch.Lift.PLift a, Plutarch.Lift.PLift b) => Plutarch.Lift.PUnsafeLiftDecl (Plutarch.Builtin.PBuiltinPair a b)
instance forall a b. (Plutarch.Lift.PConstant a, Plutarch.Lift.PConstant b) => Plutarch.Lift.PConstantDecl (a, b)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). (Plutarch.Show.PShow a, Plutarch.Show.PShow b) => Plutarch.Show.PShow (Plutarch.Builtin.PBuiltinPair a b)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). (Plutarch.Bool.PEq a, Plutarch.Bool.PEq b) => Plutarch.Bool.PEq (Plutarch.Builtin.PBuiltinPair a b)

module Plutarch.Positive
data PPositive s

-- | Build a <a>PPositive</a> from a <a>PInteger</a>. Yields
--   <a>PNothing</a> if argument is zero.
ppositive :: Term s (PInteger :--> PMaybe PPositive)

-- | Partial version of <a>PPositive</a>. Errors if argument is zero.
ptryPositive :: Term s (PInteger :--> PPositive)
instance Plutarch.Show.PShow Plutarch.Positive.PPositive
instance Plutarch.Integer.PIntegral Plutarch.Positive.PPositive
instance Plutarch.Bool.POrd Plutarch.Positive.PPositive
instance Plutarch.Bool.PPartialOrd Plutarch.Positive.PPositive
instance Plutarch.Bool.PEq Plutarch.Positive.PPositive
instance Plutarch.Builtin.PIsData Plutarch.Positive.PPositive
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Positive.PPositive
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Positive.PPositive s)
instance forall k1 k2 (f :: k2 -> k1 -> GHC.Types.Type) (a :: k1) (b :: k2). GHC.Generics.Generic (Plutarch.Positive.Flip @{k2} @{k1} f a b)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.Positive.PPositive)
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Positive.PPositive
instance Plutarch.Num.PNum Plutarch.Positive.PPositive
instance Plutarch.TryFrom.PTryFrom Plutarch.Integer.PInteger Plutarch.Positive.PPositive

module Plutarch.Rational

-- | Note: This type is _not_ the synonym of <a>Rational</a>.
data PRational s
PRational :: Term s PInteger -> Term s PPositive -> PRational s
preduce :: Term s (PRational :--> PRational)
pnumerator :: Term s (PRational :--> PInteger)
pdenominator :: Term s (PRational :--> PPositive)
pfromInteger :: Term s (PInteger :--> PRational)
pround :: Term s (PRational :--> PInteger)
ptruncate :: Term s (PRational :--> PInteger)
pproperFraction :: Term s (PRational :--> PPair PInteger PRational)
class PFractional (a :: PType)
(#/) :: PFractional a => Term s a -> Term s a -> Term s a
precip :: PFractional a => Term s (a :--> a)
pfromRational :: PFractional a => Term s (PRational :--> a)
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Rational.PRational
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Rational.PRational s)
instance forall k1 k2 (f :: k2 -> k1 -> GHC.Types.Type) (a :: k1) (b :: k2). GHC.Generics.Generic (Plutarch.Rational.Flip @{k2} @{k1} f a b)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.Rational.PRational)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). (Plutarch.Num.PNum a, Plutarch.Rational.PFractional a) => GHC.Real.Fractional (Plutarch.Internal.Term s a)
instance Plutarch.Rational.PFractional Plutarch.Rational.PRational
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Rational.PRational
instance Plutarch.Bool.PEq Plutarch.Rational.PRational
instance Plutarch.Show.PShow Plutarch.Rational.PRational
instance Plutarch.Builtin.PIsData Plutarch.Rational.PRational
instance Plutarch.Bool.PPartialOrd Plutarch.Rational.PRational
instance Plutarch.Bool.POrd Plutarch.Rational.PRational
instance Plutarch.Num.PNum Plutarch.Rational.PRational

module Plutarch.FFI

-- | Equality of inner types - Plutarch on the left and Haskell on the
--   right.
type family (p :: PType) >~< (t :: Type) :: Constraint

-- | Plutarch type of lists compatible with the PlutusTx encoding of
--   Haskell lists and convertible with the regular <a>PList</a> using
--   <a>plistToTx</a> and <a>plistFromTx</a>.
data PTxList (a :: PType) (s :: S)
PTxCons :: Term s a -> Term s (PTxList a) -> PTxList (a :: PType) (s :: S)
PTxNil :: PTxList (a :: PType) (s :: S)

-- | Plutarch type compatible with the PlutusTx encoding of Haskell
--   <a>Maybe</a> and convertible with the regular <a>PMaybe</a> using
--   <a>pmaybeToTx</a> and <a>pmaybeFromTx</a>.
data PTxMaybe (a :: PType) (s :: S)
PTxJust :: Term s a -> PTxMaybe (a :: PType) (s :: S)
PTxNothing :: PTxMaybe (a :: PType) (s :: S)

-- | Compile and export a Plutarch term so it can be used by
--   <a>applyCode</a>.
foreignExport :: forall p t. p >~< t => Config -> ClosedTerm p -> CompiledCode t

-- | Import compiled UPLC code (such as a spliced <a>compile</a> result) as
--   a Plutarch term.
foreignImport :: forall p t. p >~< t => CompiledCode t -> ClosedTerm p

-- | Export Plutarch term of any type as <tt>CompiledCode Void</tt>.
opaqueExport :: Config -> ClosedTerm p -> CompiledCode Void

-- | Import compiled UPLC code of any type as a Plutarch opaque term.
opaqueImport :: CompiledCode t -> ClosedTerm POpaque

-- | Convert a <a>PTxList</a> to a <a>PList</a>, probably after importing
--   it with <a>foreignImport</a>.
plistFromTx :: Term s (PTxList a :--> PList a)

-- | Convert a <a>PList</a> to a <a>PTxList</a>, perhaps before exporting
--   it with <a>foreignExport</a>.
plistToTx :: Term s (PList a :--> PTxList a)

-- | Convert a <a>PTxMaybe</a> to a <a>PMaybe</a>, probably after importing
--   it with <a>foreignImport</a>.
pmaybeFromTx :: Term s (PTxMaybe a :--> PMaybe a)

-- | Convert a <a>PMaybe</a> to a <a>PTxMaybe</a>, perhaps before exporting
--   it with <a>foreignExport</a>.
pmaybeToTx :: Term s (PMaybe a :--> PTxMaybe a)

-- | Seriously unsafe, may fail at run time or result in unexpected
--   behaviour in your on-chain validator.
unsafeForeignExport :: Config -> ClosedTerm p -> CompiledCode t

-- | Seriously unsafe, may fail at run time or result in unexpected
--   behaviour in your on-chain validator.
unsafeForeignImport :: CompiledCode t -> ClosedTerm p
instance forall (a :: Plutarch.Internal.PType). Plutarch.Show.PShow a => Plutarch.Show.PShow (Plutarch.FFI.PTxList a)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). Generics.SOP.Universe.HasDatatypeInfo (Plutarch.FFI.PTxList a s)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). Generics.SOP.Universe.Generic (Plutarch.FFI.PTxList a s)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.FFI.PTxList a s)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Show.PShow a => Plutarch.Show.PShow (Plutarch.FFI.PTxMaybe a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Bool.PEq a => Plutarch.Bool.PEq (Plutarch.FFI.PTxMaybe a)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). Generics.SOP.Universe.HasDatatypeInfo (Plutarch.FFI.PTxMaybe a s)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). Generics.SOP.Universe.Generic (Plutarch.FFI.PTxMaybe a s)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.FFI.PTxMaybe a s)
instance forall (a :: Plutarch.Internal.PType) (r :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.FFI.PTxList' a r)
instance forall (a :: Plutarch.Internal.PType) (r :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.FFI.PTxList' a r s)
instance forall (a :: Plutarch.Internal.PType) (r :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.FFI.PTxMaybe' a r)
instance forall (a :: Plutarch.Internal.PType) (r :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.FFI.PTxMaybe' a r s)
instance forall (a :: Plutarch.Internal.PType) (r :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.FFI.PTxMaybe' a r)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.FFI.PTxMaybe a)
instance forall (a :: Plutarch.Internal.PType) (r :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.FFI.PTxList' a r)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.FFI.PTxList a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Bool.PEq a => Plutarch.Bool.PEq (Plutarch.FFI.PTxList a)
instance Plutarch.List.PListLike Plutarch.FFI.PTxList

module Plutarch.DataRepr.Internal.FromData

-- | removes the PAsData if the hole requires it but leaves it there if it
--   doesn't
--   
--   <pre>
--   &gt;&gt;&gt; :t pmaybeFromAsData (pdata 3 :: (Term s (PAsData PInteger))) :: (Term (s::S) PInteger)
--   pmaybeFromAsData (pdata 3 :: (Term s (PAsData PInteger))) :: (Term (s::S) PInteger)
--   :: forall (s :: S). Term s (PInteger @{S})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :t pmaybeFromAsData (pdata 3 :: (Term s (PAsData PInteger))) :: (Term (s::S) (PAsData PInteger))
--   pmaybeFromAsData (pdata 3 :: (Term s (PAsData PInteger))) :: (Term (s::S) (PAsData PInteger))
--   :: forall (s :: S). Term s (PAsData (PInteger @{S}))
--   </pre>
class PFromDataable (a :: PType) (b :: PType) | b -> a, a -> b
pmaybeFromAsData :: PFromDataable a b => Term s (PAsData a) -> Term s b
instance forall (a :: Plutarch.Internal.PType). Plutarch.DataRepr.Internal.FromData.PFromDataable a (Plutarch.Builtin.PAsData a)
instance forall (a :: Plutarch.Internal.PType) (b :: Plutarch.Internal.PType). (Plutarch.Builtin.PIsData a, (b :: Plutarch.Internal.PType) GHC.Types.~ (a :: Plutarch.Internal.PType)) => Plutarch.DataRepr.Internal.FromData.PFromDataable a b

module Plutarch.DataRepr.Internal.HList
data HRec as
[HNil] :: HRec '[]
[HCons] :: Labeled name a -> HRec as -> HRec ('(name, a) ': as)
newtype HRecGeneric as
HRecGeneric :: HRec as -> HRecGeneric as
newtype Labeled sym a
Labeled :: a -> Labeled sym a
[$sel:unLabeled:Labeled] :: Labeled sym a -> a

-- | Index a <a>HRec</a> with a field in a provided list of data fields.
--   Implicitly unwraps `PAsData a` to <tt>a</tt> when necessary.
--   
--   <pre>
--   &gt;&gt;&gt; xs = HRec @["x", "y", "z"] (HCons 1 (HCons 2 (HCons 3 HNil)))
--   
--   &gt;&gt;&gt; hrecField @"y" @["x", "y", "z"] xs
--   
--   &gt;&gt;&gt; 2
--   </pre>

-- | <i>Deprecated: please use getField from GHC.Records</i>
hrecField :: forall name c as a b s. (ElemOf name a as, Term s (PAsData b) ~ a, PFromDataable b c) => HRec as -> Term s c

-- | Index a HList with a field in a provided list of fields.
--   
--   <pre>
--   &gt;&gt;&gt; xs = HRec @["x", "y", "z"] (HCons 1 (HCons 2 (HCons 3 HNil)))
--   
--   &gt;&gt;&gt; hrecField @"y" @["x", "y", "z"] xs
--   
--   &gt;&gt;&gt; 2
--   </pre>
hrecField' :: forall name a as. ElemOf name a as => HRec as -> a

-- | Indexing type-level lists
type family IndexList (n :: Nat) (l :: [k]) :: k

-- | Indexing list of labeled pairs by label
type family IndexLabel name as

-- | Return the single item from a singleton list
type family SingleItem (as :: [k]) :: k

-- | Drop first n fields of a list
type family Drop (n :: Nat) (as :: [k]) :: [k]

-- | GADT proof-witness of HList membership, usable as an index
data Elem (a :: k) (as :: [k])
[Here] :: Elem a (a ': as)
[There] :: Elem a as -> Elem a (b ': as)

-- | Construct an <a>Elem</a> via Nat.
--   
--   This class could instead be a more direct version of
--   <tt>indexHList</tt>, but perhaps the <a>Elem</a> encoding will be
--   useful.
class IndexLabel name as ~ a => ElemOf name a as | as name -> a

-- | Construct the <a>Elem</a> corresponding to a Nat index.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; natElem @_ @0
--   Here
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; natElem @_ @3
--   There (There (There Here))
--   </pre>
elemOf :: ElemOf name a as => Elem '(name, a) as
instance forall (name :: GHC.Types.Symbol) a (as :: [(GHC.Types.Symbol, GHC.Types.Type)]). ((Plutarch.DataRepr.Internal.HList.Utils.IndexLabel name as :: GHC.Types.Type) GHC.Types.~ (a :: GHC.Types.Type), Plutarch.DataRepr.Internal.HList.ElemOf name a as) => GHC.Records.HasField @{GHC.Types.Symbol} name (Plutarch.DataRepr.Internal.HList.HRecGeneric as) a
instance forall (name :: GHC.Types.Symbol) a (as :: [(GHC.Types.Symbol, GHC.Types.Type)]). Plutarch.DataRepr.Internal.HList.ElemOf name a ((':) @(GHC.Types.Symbol, GHC.Types.Type) '(name, a) as)
instance forall (name :: GHC.Types.Symbol) (b :: (GHC.Types.Symbol, GHC.Types.Type)) (as :: [(GHC.Types.Symbol, GHC.Types.Type)]) a. ((Plutarch.DataRepr.Internal.HList.Utils.IndexLabel name ((':) @(GHC.Types.Symbol, GHC.Types.Type) b as) :: GHC.Types.Type) GHC.Types.~ (a :: GHC.Types.Type), Plutarch.DataRepr.Internal.HList.ElemOf name a as) => Plutarch.DataRepr.Internal.HList.ElemOf name a ((':) @(GHC.Types.Symbol, GHC.Types.Type) b as)
instance forall (name :: GHC.Types.Symbol) (c :: Plutarch.Internal.PType) (as :: [(GHC.Types.Symbol, GHC.Types.Type)]) a (b :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). ((Plutarch.DataRepr.Internal.HList.Utils.IndexLabel name as :: GHC.Types.Type) GHC.Types.~ (a :: GHC.Types.Type), Plutarch.DataRepr.Internal.HList.ElemOf name a as, (Plutarch.Internal.Term s (Plutarch.Builtin.PAsData b) :: GHC.Types.Type) GHC.Types.~ (a :: GHC.Types.Type), Plutarch.DataRepr.Internal.FromData.PFromDataable b c) => GHC.Records.HasField @{GHC.Types.Symbol} name (Plutarch.DataRepr.Internal.HList.HRec as) (Plutarch.Internal.Term s c)

module Plutarch.DataRepr.Internal

-- | A sum of <a>PDataRecord</a>s. The underlying representation is the
--   <tt>Constr</tt> constructor, where the integer is the index of the
--   variant and the list is the record.
newtype PDataSum defs s
PDataSum :: NS (Compose (Term s) PDataRecord) defs -> PDataSum defs s

-- | If there is only a single variant, then we can safely extract it.
punDataSum :: Term s (PDataSum '[def] :--> PDataRecord def)

-- | Try getting the nth variant. Errs if it's another variant.
ptryIndexDataSum :: KnownNat n => Proxy n -> Term s (PDataSum (def ': defs) :--> PDataRecord (IndexList n (def ': defs)))

-- | Cons a field to a data record.
--   
--   You can specify the label to associate with the field using type
--   applications-
--   
--   <pre>
--   foo :: Term s (PDataRecord '[ "fooField" ':= PByteString ])
--   foo = pdcons @"fooField" # pdata (phexByteStr "ab") # pdnil
--   </pre>
pdcons :: forall label a l s. Term s (PAsData a :--> (PDataRecord l :--> PDataRecord ((label ':= a) ': l)))

-- | An empty <a>PDataRecord</a>.
pdnil :: Term s (PDataRecord '[])
data DataReprHandlers (out :: PType) (defs :: [[PLabeledType]]) (s :: S)
[DRHNil] :: DataReprHandlers out '[] s
[DRHCons] :: (Term s (PDataRecord def) -> Term s out) -> DataReprHandlers out defs s -> DataReprHandlers out (def ': defs) s

-- | Type synonym to simplify deriving of <tt>PConstant</tt> via
--   <tt>DerivePConstantViaData</tt>.
--   
--   A type <tt>Foo a</tt> is considered <a>ConstantableData</a> if:
--   
--   <ul>
--   <li>The wrapped type <tt>a</tt> has a <tt>PConstant</tt>
--   instance.</li>
--   <li>The lifted type of <tt>a</tt> has a <tt>PUnsafeLiftDecl</tt>
--   instance.</li>
--   <li>There is type equality between <tt>a</tt> and <tt>PLifted
--   (PConstanted a)</tt>.</li>
--   <li>The newtype has <tt>FromData</tt> and <tt>ToData</tt>
--   instances</li>
--   </ul>
--   
--   These constraints are sufficient to derive a <tt>PConstant</tt>
--   instance for the newtype.
--   
--   For deriving <tt>PConstant</tt> for a wrapped type represented in UPLC
--   as <tt>Data</tt>, see <tt>DerivePConstantViaData</tt>.
--   
--   Polymorphic types can be derived as follows:
--   
--   <pre>
--   data Bar a = Bar a deriving stock (GHC.Generic)
--   
--   PlutusTx.makeLift ''Bar
--   PlutusTx.makeIsDataIndexed ''Bar [('Bar, 0)]
--   
--   data PBar (a :: PType) (s :: S)
--     = PBar (Term s (PDataRecord '["_0" ':= a]))
--     deriving stock (GHC.Generic)
--     deriving anyclass (SOP.Generic, PIsDataRepr)
--     deriving (PlutusType, PIsData, PDataFields) via PIsDataReprInstances (PBar a)
--   
--   instance
--     forall a.
--     PLiftData a =&gt;
--     PUnsafeLiftDecl (PBar a)
--     where
--     type PLifted (PBar a) = Bar (PLifted a)
--   
--   deriving via
--     ( DerivePConstantViaData
--         (Bar a)
--         (PBar (PConstanted a))
--     )
--     instance
--       PConstantData a =&gt;
--       PConstantDecl (Bar a)
--   </pre>
type PConstantData h = (PConstant h, FromData h, ToData h, PIsData (PConstanted h))

-- | A "record" of `exists a. PAsData a`. The underlying representation is
--   `PBuiltinList PData`.
data PDataRecord (as :: [PLabeledType]) (s :: S)
[PDCons] :: forall name_x x xs s. PUnLabel name_x ~ x => Term s (PAsData x) -> Term s (PDataRecord xs) -> PDataRecord (name_x ': xs) s
[PDNil] :: PDataRecord '[] s
type PLiftData p = (PLift p, FromData (PLifted p), ToData (PLifted p), PIsData p)
data PLabeledType
(:=) :: Symbol -> PType -> PLabeledType
type family PLabelIndex (name :: Symbol) (as :: [PLabeledType]) :: Nat
type family PUnLabel (a :: PLabeledType) :: PType
type family PLookupLabel name as

-- | Safely index a <a>PDataRecord</a>.
pindexDataRecord :: KnownNat n => Proxy n -> Term s (PDataRecord as) -> Term s (PAsData (PUnLabel (IndexList n as)))

-- | Safely drop the first n items of a <a>PDataRecord</a>.
pdropDataRecord :: KnownNat n => Proxy n -> Term s (PDataRecord xs) -> Term s (PDataRecord (Drop n xs))

-- | For deriving <tt>PConstant</tt> for a wrapped type represented by a
--   builtin type, see <tt>DerivePConstantViaNewtype</tt>.
newtype DerivePConstantViaData (h :: Type) (p :: PType)

-- | The Haskell type for which @PConstant is being derived.
DerivePConstantViaData :: h -> DerivePConstantViaData (h :: Type) (p :: PType)
newtype DualReprHandler s out def
DualRepr :: (Term s (PDataRecord def) -> Term s (PDataRecord def) -> Term s out) -> DualReprHandler s out def
data PlutusTypeData
instance forall (as :: [Plutarch.DataRepr.Internal.PLabeledType]). Plutarch.Internal.PlutusType.PlutusType (Plutarch.DataRepr.Internal.PDataRecordShowHelper as)
instance forall (as :: [Plutarch.DataRepr.Internal.PLabeledType]) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.DataRepr.Internal.PDataRecordShowHelper as s)
instance forall (as :: [(GHC.Types.Symbol, Plutarch.Internal.PType)]) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.DataRepr.Internal.HRecP as s)
instance forall k1 k2 (f :: k2 -> k1 -> GHC.Types.Type) (a :: k1) (b :: k2). GHC.Generics.Generic (Plutarch.DataRepr.Internal.Flip @{k2} @{k1} f a b)
instance forall (b :: Plutarch.TryFrom.PSubtypeRelation) (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.DataRepr.Internal.ExcessForField b a s)
instance forall k (a :: k -> GHC.Types.Type) (b :: k -> GHC.Types.Type) (s :: k). GHC.Generics.Generic (Plutarch.DataRepr.Internal.Helper @{k} a b s)
instance forall (n :: GHC.TypeNats.Nat) (x :: [Plutarch.DataRepr.Internal.PLabeledType]) (xs :: [[Plutarch.DataRepr.Internal.PLabeledType]]). (Plutarch.TryFrom.PTryFrom (Plutarch.Builtin.PBuiltinList Plutarch.Builtin.PData) (Plutarch.DataRepr.Internal.PDataRecord x), Plutarch.DataRepr.Internal.SumValidation (n GHC.TypeNats.+ 1) xs, GHC.TypeNats.KnownNat n) => Plutarch.DataRepr.Internal.SumValidation n ((':) @[Plutarch.DataRepr.Internal.PLabeledType] x xs)
instance forall (n :: GHC.TypeNats.Nat). Plutarch.DataRepr.Internal.SumValidation n ('[] @[Plutarch.DataRepr.Internal.PLabeledType])
instance forall (ys :: [[Plutarch.DataRepr.Internal.PLabeledType]]). Plutarch.DataRepr.Internal.SumValidation 0 ys => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.DataRepr.Internal.PDataSum ys)
instance forall (as :: [Plutarch.DataRepr.Internal.PLabeledType]) (ase :: [(GHC.Types.Symbol, Plutarch.Internal.PType)]). (Plutarch.TryFrom.PTryFrom (Plutarch.Builtin.PBuiltinList Plutarch.Builtin.PData) (Plutarch.DataRepr.Internal.PDataRecord as), (Plutarch.TryFrom.PTryFromExcess (Plutarch.Builtin.PBuiltinList Plutarch.Builtin.PData) (Plutarch.DataRepr.Internal.PDataRecord as) :: Plutarch.Internal.PType) GHC.Types.~ (Plutarch.DataRepr.Internal.HRecP ase :: Plutarch.Internal.PType)) => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.DataRepr.Internal.PDataRecord as))
instance forall (pty :: Plutarch.Internal.PType) (as :: [Plutarch.DataRepr.Internal.PLabeledType]) (ase :: [(GHC.Types.Symbol, Plutarch.Internal.PType)]) (name :: GHC.Types.Symbol). (Plutarch.DataRepr.Internal.Helper2 (Plutarch.TryFrom.PSubtype' Plutarch.Builtin.PData pty) pty, Plutarch.TryFrom.PTryFrom (Plutarch.Builtin.PBuiltinList Plutarch.Builtin.PData) (Plutarch.DataRepr.Internal.PDataRecord as), (Plutarch.TryFrom.PTryFromExcess (Plutarch.Builtin.PBuiltinList Plutarch.Builtin.PData) (Plutarch.DataRepr.Internal.PDataRecord as) :: Plutarch.Internal.PType) GHC.Types.~ (Plutarch.DataRepr.Internal.HRecP ase :: Plutarch.Internal.PType)) => Plutarch.TryFrom.PTryFrom (Plutarch.Builtin.PBuiltinList Plutarch.Builtin.PData) (Plutarch.DataRepr.Internal.PDataRecord ((':) @Plutarch.DataRepr.Internal.PLabeledType (name 'Plutarch.DataRepr.Internal.:= pty) as))
instance forall (a :: Plutarch.Internal.PType). Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData a) => Plutarch.DataRepr.Internal.Helper2 'Plutarch.TryFrom.PNoSubtypeRelation a
instance forall (a :: Plutarch.Internal.PType). Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData a => Plutarch.DataRepr.Internal.Helper2 'Plutarch.TryFrom.PSubtypeRelation a
instance Plutarch.TryFrom.PTryFrom (Plutarch.Builtin.PBuiltinList Plutarch.Builtin.PData) (Plutarch.DataRepr.Internal.PDataRecord ('[] @Plutarch.DataRepr.Internal.PLabeledType))
instance forall (p :: Plutarch.Internal.PType) h. (Plutarch.TryFrom.PSubtype Plutarch.Builtin.PData p, Plutarch.Lift.PLift p, PlutusTx.IsData.Class.FromData h, PlutusTx.IsData.Class.ToData h) => Plutarch.Lift.PConstantDecl (Plutarch.DataRepr.Internal.DerivePConstantViaData h p)
instance forall (a :: Plutarch.Internal.PType). (Plutarch.DataRepr.Internal.IsPDataSum (Plutarch.Internal.Generic.PCode a), Data.SOP.Constraint.SListI @{[Plutarch.DataRepr.Internal.PLabeledType]} (Plutarch.DataRepr.Internal.IsPDataSumDefs (Plutarch.Internal.Generic.PCode a)), Plutarch.Internal.Generic.PGeneric a) => Plutarch.DataRepr.Internal.PlutusTypeDataConstraint a
instance Plutarch.Internal.PlutusType.PlutusTypeStrat Plutarch.DataRepr.Internal.PlutusTypeData
instance forall (defs :: [[Plutarch.DataRepr.Internal.PLabeledType]]). Data.SOP.Constraint.SListI @{[Plutarch.DataRepr.Internal.PLabeledType]} defs => Plutarch.Internal.PlutusType.PlutusType (Plutarch.DataRepr.Internal.PDataSum defs)
instance Plutarch.DataRepr.Internal.IsPDataSum ('[] @[Plutarch.Internal.PType])
instance forall (xs :: [[Plutarch.Internal.PType]]) (l :: [Plutarch.DataRepr.Internal.PLabeledType]). Plutarch.DataRepr.Internal.IsPDataSum xs => Plutarch.DataRepr.Internal.IsPDataSum ((':) @[Plutarch.Internal.S -> GHC.Types.Type] ((':) @(Plutarch.Internal.S -> GHC.Types.Type) (Plutarch.DataRepr.Internal.PDataRecord l) ('[] @(Plutarch.Internal.S -> GHC.Types.Type))) xs)
instance forall (defs :: [[Plutarch.DataRepr.Internal.PLabeledType]]). (Data.SOP.Constraint.All @[Plutarch.DataRepr.Internal.PLabeledType] (Data.SOP.Constraint.Top @{[Plutarch.DataRepr.Internal.PLabeledType]}) defs, Data.SOP.Constraint.All @[Plutarch.DataRepr.Internal.PLabeledType] (Data.SOP.Constraint.Compose @{Plutarch.Internal.PType} @{[Plutarch.DataRepr.Internal.PLabeledType]} Plutarch.Show.PShow Plutarch.DataRepr.Internal.PDataRecord) defs) => Plutarch.Show.PShow (Plutarch.DataRepr.Internal.PDataSum defs)
instance forall (defs :: [[Plutarch.DataRepr.Internal.PLabeledType]]). Plutarch.Builtin.PIsData (Plutarch.DataRepr.Internal.PDataSum defs)
instance forall (defs :: [[Plutarch.DataRepr.Internal.PLabeledType]]). Plutarch.Bool.PEq (Plutarch.DataRepr.Internal.PDataSum defs)
instance forall (defs :: [[Plutarch.DataRepr.Internal.PLabeledType]]). Data.SOP.Constraint.All @[Plutarch.DataRepr.Internal.PLabeledType] (Data.SOP.Constraint.Compose @{Plutarch.Internal.PType} @{[Plutarch.DataRepr.Internal.PLabeledType]} Plutarch.Bool.POrd Plutarch.DataRepr.Internal.PDataRecord) defs => Plutarch.Bool.PPartialOrd (Plutarch.DataRepr.Internal.PDataSum defs)
instance forall (defs :: [[Plutarch.DataRepr.Internal.PLabeledType]]). Data.SOP.Constraint.All @[Plutarch.DataRepr.Internal.PLabeledType] (Data.SOP.Constraint.Compose @{Plutarch.Internal.PType} @{[Plutarch.DataRepr.Internal.PLabeledType]} Plutarch.Bool.POrd Plutarch.DataRepr.Internal.PDataRecord) defs => Plutarch.Bool.POrd (Plutarch.DataRepr.Internal.PDataSum defs)
instance forall (ys :: [[Plutarch.DataRepr.Internal.PLabeledType]]). Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.DataRepr.Internal.PDataSum ys) => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.DataRepr.Internal.PDataSum ys))
instance forall (l :: [Plutarch.DataRepr.Internal.PLabeledType]). Data.SOP.Constraint.SListI @{Plutarch.DataRepr.Internal.PLabeledType} l => Plutarch.Internal.PlutusType.PlutusType (Plutarch.DataRepr.Internal.PDataRecord l)
instance forall (xs :: [Plutarch.DataRepr.Internal.PLabeledType]) (label :: GHC.Types.Symbol) (x :: Plutarch.Internal.PType). (Data.SOP.Constraint.All @Plutarch.DataRepr.Internal.PLabeledType (Data.SOP.Constraint.Top @{Plutarch.DataRepr.Internal.PLabeledType}) xs, GHC.TypeLits.KnownSymbol label, Plutarch.Builtin.PIsData x, Plutarch.Show.PShow x, Plutarch.Show.PShow (Plutarch.DataRepr.Internal.PDataRecordShowHelper xs)) => Plutarch.Show.PShow (Plutarch.DataRepr.Internal.PDataRecord ((':) @Plutarch.DataRepr.Internal.PLabeledType (label 'Plutarch.DataRepr.Internal.:= x) xs))
instance forall (as :: [Plutarch.DataRepr.Internal.PLabeledType]). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.DataRepr.Internal.PDataRecordShowHelper as)
instance Plutarch.Show.PShow (Plutarch.DataRepr.Internal.PDataRecordShowHelper ('[] @Plutarch.DataRepr.Internal.PLabeledType))
instance forall (xs :: [Plutarch.DataRepr.Internal.PLabeledType]) (label :: GHC.Types.Symbol) (x :: Plutarch.Internal.PType). (Data.SOP.Constraint.All @Plutarch.DataRepr.Internal.PLabeledType (Data.SOP.Constraint.Top @{Plutarch.DataRepr.Internal.PLabeledType}) xs, GHC.TypeLits.KnownSymbol label, Plutarch.Builtin.PIsData x, Plutarch.Show.PShow x, Plutarch.Show.PShow (Plutarch.DataRepr.Internal.PDataRecordShowHelper xs)) => Plutarch.Show.PShow (Plutarch.DataRepr.Internal.PDataRecordShowHelper ((':) @Plutarch.DataRepr.Internal.PLabeledType (label 'Plutarch.DataRepr.Internal.:= x) xs))
instance forall (xs :: [Plutarch.DataRepr.Internal.PLabeledType]). Plutarch.Bool.PEq (Plutarch.DataRepr.Internal.PDataRecord xs)
instance Plutarch.Bool.PPartialOrd (Plutarch.DataRepr.Internal.PDataRecord ('[] @Plutarch.DataRepr.Internal.PLabeledType))
instance Plutarch.Bool.POrd (Plutarch.DataRepr.Internal.PDataRecord ('[] @Plutarch.DataRepr.Internal.PLabeledType))
instance Plutarch.Show.PShow (Plutarch.DataRepr.Internal.PDataRecord ('[] @Plutarch.DataRepr.Internal.PLabeledType))
instance forall (x :: Plutarch.Internal.PType) (label :: GHC.Types.Symbol). (Plutarch.Bool.POrd x, Plutarch.Builtin.PIsData x) => Plutarch.Bool.PPartialOrd (Plutarch.DataRepr.Internal.PDataRecord ((':) @Plutarch.DataRepr.Internal.PLabeledType (label 'Plutarch.DataRepr.Internal.:= x) ('[] @Plutarch.DataRepr.Internal.PLabeledType)))
instance forall (x :: Plutarch.Internal.PType) (label :: GHC.Types.Symbol). (Plutarch.Bool.POrd x, Plutarch.Builtin.PIsData x) => Plutarch.Bool.POrd (Plutarch.DataRepr.Internal.PDataRecord ((':) @Plutarch.DataRepr.Internal.PLabeledType (label 'Plutarch.DataRepr.Internal.:= x) ('[] @Plutarch.DataRepr.Internal.PLabeledType)))
instance forall (xs :: [Plutarch.DataRepr.Internal.PLabeledType]) (x :: Plutarch.Internal.PType) (x' :: Plutarch.DataRepr.Internal.PLabeledType) (label :: GHC.Types.Symbol). (Data.SOP.Constraint.SListI @{Plutarch.DataRepr.Internal.PLabeledType} xs, Plutarch.Bool.POrd x, Plutarch.Builtin.PIsData x, Plutarch.Bool.POrd (Plutarch.DataRepr.Internal.PDataRecord ((':) @Plutarch.DataRepr.Internal.PLabeledType x' xs))) => Plutarch.Bool.PPartialOrd (Plutarch.DataRepr.Internal.PDataRecord ((':) @Plutarch.DataRepr.Internal.PLabeledType (label 'Plutarch.DataRepr.Internal.:= x) ((':) @Plutarch.DataRepr.Internal.PLabeledType x' xs)))
instance forall (xs :: [Plutarch.DataRepr.Internal.PLabeledType]) (x :: Plutarch.Internal.PType) (x' :: Plutarch.DataRepr.Internal.PLabeledType) (label :: GHC.Types.Symbol). (Data.SOP.Constraint.SListI @{Plutarch.DataRepr.Internal.PLabeledType} xs, Plutarch.Bool.POrd x, Plutarch.Builtin.PIsData x, Plutarch.Bool.POrd (Plutarch.DataRepr.Internal.PDataRecord ((':) @Plutarch.DataRepr.Internal.PLabeledType x' xs))) => Plutarch.Bool.POrd (Plutarch.DataRepr.Internal.PDataRecord ((':) @Plutarch.DataRepr.Internal.PLabeledType (label 'Plutarch.DataRepr.Internal.:= x) ((':) @Plutarch.DataRepr.Internal.PLabeledType x' xs)))
instance forall (xs :: [Plutarch.DataRepr.Internal.PLabeledType]). Plutarch.Builtin.PIsData (Plutarch.DataRepr.Internal.PDataRecord xs)

module Plutarch.DataRepr.Internal.Field

-- | Class allowing <tt>letFields</tt> to work for a PType, usually via
--   <tt>PIsDataRepr</tt>, but is derived for some other types for
--   convenience.
class PDataFields (a :: PType) where {
    
    -- | Fields in HRec bound by <tt>letFields</tt>
    type PFields a :: [PLabeledType];
    type PFields a = Helper (PInner a);
}

-- | Convert a Term to a <tt>PDataList</tt>
ptoFields :: PDataFields a => Term s a -> Term s (PDataRecord (PFields a))

-- | Convert a Term to a <tt>PDataList</tt>
ptoFields :: (PDataFields a, PDataFields (PInner a), PFields (PInner a) ~ PFields a) => Term s a -> Term s (PDataRecord (PFields a))

-- | Bind a HRec of named fields containing all the specified fields.
pletFields :: forall fs a s b ps bs. (PDataFields a, ps ~ PFields a, bs ~ Bindings ps fs, BindFields ps bs) => Term s a -> (HRecOf a fs s -> Term s b) -> Term s b

-- | Get a single field from a Term.
--   
--   <ul>
--   <li>NB*: If you access more than one field from the same value you
--   should use <a>pletFields</a> instead, which will generate the bindings
--   more efficiently.</li>
--   </ul>
pfield :: forall name b p s a as n. (PDataFields p, as ~ PFields p, n ~ PLabelIndex name as, KnownNat n, a ~ PUnLabel (IndexList n as), PFromDataable a b) => Term s (p :--> b)
class BindFields (ps :: [PLabeledType]) (bs :: [ToBind])

-- | Bind all the fields in a <tt>PDataList</tt> term to a corresponding
--   HList of Terms.
--   
--   A continuation is returned to enable sharing of the generated
--   bound-variables.
bindFields :: BindFields ps bs => Proxy bs -> Term s (PDataRecord ps) -> TermCont s (HRec (BoundTerms ps bs s))

-- | Map <a>BindField</a> over <tt>[PLabeledType]</tt>, with <tt>Skips</tt>
--   removed at tail
type family Bindings (ps :: [PLabeledType]) (fs :: [Symbol]) :: [ToBind]

-- | Get the <a>Term</a> representations to be bound based on the result of
--   <a>Bindings</a>.
type family BoundTerms ps bs s

-- | Drop first n fields of a list
type family Drop (n :: Nat) (as :: [k]) :: [k]

-- | The <a>HRec</a> yielded by 'pletFields @fs t'.
type HRecOf t fs s = HRec (BoundTerms (PFields t) (Bindings (PFields t) fs) s)

-- | Constrain an <a>HRec</a> to contain the specified fields from the
--   given Plutarch type.
--   
--   <h3>Example ===</h3>
--   
--   <pre>
--   import qualified GHC.Generics as GHC
--   import Generics.SOP
--   
--   import Plutarch.Prelude
--   import Plutarch.DataRepr
--   
--   newtype PFooType s = PFooType (Term s (PDataRecord '["frst" ':= PInteger, "scnd" ':= PBool, "thrd" ':= PString]))
--     deriving stock (GHC.Generic)
--     deriving anyclass (Generic)
--     deriving anyclass (PIsDataRepr)
--     deriving
--       (PlutusType, PIsData, PDataFields, PEq)
--       via PIsDataReprInstances PFooType
--   
--   foo :: PMemberFields PFooType '["scnd", "frst"] s as =&gt; HRec as -&gt; Term s PInteger
--   foo h = pif (getField <tt>"scnd" h) (getField </tt>"frst" h) 0
--   </pre>
type family PMemberFields t fs s as

-- | Single field version of <a>PMemberFields</a>.
type family PMemberField t name s as
data HRec as
[HNil] :: HRec '[]
[HCons] :: Labeled name a -> HRec as -> HRec ('(name, a) ': as)
newtype Labeled sym a
Labeled :: a -> Labeled sym a
[$sel:unLabeled:Labeled] :: Labeled sym a -> a

-- | Index a <a>HRec</a> with a field in a provided list of data fields.
--   Implicitly unwraps `PAsData a` to <tt>a</tt> when necessary.
--   
--   <pre>
--   &gt;&gt;&gt; xs = HRec @["x", "y", "z"] (HCons 1 (HCons 2 (HCons 3 HNil)))
--   
--   &gt;&gt;&gt; hrecField @"y" @["x", "y", "z"] xs
--   
--   &gt;&gt;&gt; 2
--   </pre>

-- | <i>Deprecated: please use getField from GHC.Records</i>
hrecField :: forall name c as a b s. (ElemOf name a as, Term s (PAsData b) ~ a, PFromDataable b c) => HRec as -> Term s c
instance forall (l :: GHC.Types.Symbol) (p :: Plutarch.Internal.PType) (ps :: [Plutarch.DataRepr.Internal.PLabeledType]). Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType (l 'Plutarch.DataRepr.Internal.:= p) ps) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Bind ('[] @Plutarch.DataRepr.Internal.Field.ToBind))
instance forall (ps :: [Plutarch.DataRepr.Internal.PLabeledType]) (bs :: [Plutarch.DataRepr.Internal.Field.ToBind]) (l :: GHC.Types.Symbol) (p :: Plutarch.Internal.PType). Plutarch.DataRepr.Internal.Field.BindFields ps bs => Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType (l 'Plutarch.DataRepr.Internal.:= p) ps) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Bind bs)
instance forall (ps :: [Plutarch.DataRepr.Internal.PLabeledType]) (bs :: [Plutarch.DataRepr.Internal.Field.ToBind]) (p1 :: Plutarch.DataRepr.Internal.PLabeledType). Plutarch.DataRepr.Internal.Field.BindFields ps bs => Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType p1 ps) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip bs)
instance forall (ps :: [Plutarch.DataRepr.Internal.PLabeledType]) (bs :: [Plutarch.DataRepr.Internal.Field.ToBind]) (p1 :: Plutarch.DataRepr.Internal.PLabeledType) (p2 :: Plutarch.DataRepr.Internal.PLabeledType). Plutarch.DataRepr.Internal.Field.BindFields ps bs => Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType p1 ((':) @Plutarch.DataRepr.Internal.PLabeledType p2 ps)) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip bs))
instance forall (ps :: [Plutarch.DataRepr.Internal.PLabeledType]) (bs :: [Plutarch.DataRepr.Internal.Field.ToBind]) (p1 :: Plutarch.DataRepr.Internal.PLabeledType) (p2 :: Plutarch.DataRepr.Internal.PLabeledType) (p3 :: Plutarch.DataRepr.Internal.PLabeledType). Plutarch.DataRepr.Internal.Field.BindFields ps bs => Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType p1 ((':) @Plutarch.DataRepr.Internal.PLabeledType p2 ((':) @Plutarch.DataRepr.Internal.PLabeledType p3 ps))) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip bs)))
instance forall (ps :: [Plutarch.DataRepr.Internal.PLabeledType]) (bs :: [Plutarch.DataRepr.Internal.Field.ToBind]) (p1 :: Plutarch.DataRepr.Internal.PLabeledType) (p2 :: Plutarch.DataRepr.Internal.PLabeledType) (p3 :: Plutarch.DataRepr.Internal.PLabeledType) (p4 :: Plutarch.DataRepr.Internal.PLabeledType). Plutarch.DataRepr.Internal.Field.BindFields ps bs => Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType p1 ((':) @Plutarch.DataRepr.Internal.PLabeledType p2 ((':) @Plutarch.DataRepr.Internal.PLabeledType p3 ((':) @Plutarch.DataRepr.Internal.PLabeledType p4 ps)))) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip bs))))
instance forall (ps :: [Plutarch.DataRepr.Internal.PLabeledType]) (bs :: [Plutarch.DataRepr.Internal.Field.ToBind]) (p1 :: Plutarch.DataRepr.Internal.PLabeledType) (p2 :: Plutarch.DataRepr.Internal.PLabeledType) (p3 :: Plutarch.DataRepr.Internal.PLabeledType) (p4 :: Plutarch.DataRepr.Internal.PLabeledType) (p5 :: Plutarch.DataRepr.Internal.PLabeledType). Plutarch.DataRepr.Internal.Field.BindFields ps bs => Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType p1 ((':) @Plutarch.DataRepr.Internal.PLabeledType p2 ((':) @Plutarch.DataRepr.Internal.PLabeledType p3 ((':) @Plutarch.DataRepr.Internal.PLabeledType p4 ((':) @Plutarch.DataRepr.Internal.PLabeledType p5 ps))))) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip bs)))))
instance forall (ps :: [Plutarch.DataRepr.Internal.PLabeledType]) (bs :: [Plutarch.DataRepr.Internal.Field.ToBind]) (p1 :: Plutarch.DataRepr.Internal.PLabeledType) (p2 :: Plutarch.DataRepr.Internal.PLabeledType) (p3 :: Plutarch.DataRepr.Internal.PLabeledType) (p4 :: Plutarch.DataRepr.Internal.PLabeledType) (p5 :: Plutarch.DataRepr.Internal.PLabeledType) (p6 :: Plutarch.DataRepr.Internal.PLabeledType). Plutarch.DataRepr.Internal.Field.BindFields ps bs => Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType p1 ((':) @Plutarch.DataRepr.Internal.PLabeledType p2 ((':) @Plutarch.DataRepr.Internal.PLabeledType p3 ((':) @Plutarch.DataRepr.Internal.PLabeledType p4 ((':) @Plutarch.DataRepr.Internal.PLabeledType p5 ((':) @Plutarch.DataRepr.Internal.PLabeledType p6 ps)))))) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip bs))))))
instance forall (ps :: [Plutarch.DataRepr.Internal.PLabeledType]) (bs :: [Plutarch.DataRepr.Internal.Field.ToBind]) (p1 :: Plutarch.DataRepr.Internal.PLabeledType) (p2 :: Plutarch.DataRepr.Internal.PLabeledType) (p3 :: Plutarch.DataRepr.Internal.PLabeledType) (p4 :: Plutarch.DataRepr.Internal.PLabeledType) (p5 :: Plutarch.DataRepr.Internal.PLabeledType) (p6 :: Plutarch.DataRepr.Internal.PLabeledType) (p7 :: Plutarch.DataRepr.Internal.PLabeledType). Plutarch.DataRepr.Internal.Field.BindFields ps bs => Plutarch.DataRepr.Internal.Field.BindFields ((':) @Plutarch.DataRepr.Internal.PLabeledType p1 ((':) @Plutarch.DataRepr.Internal.PLabeledType p2 ((':) @Plutarch.DataRepr.Internal.PLabeledType p3 ((':) @Plutarch.DataRepr.Internal.PLabeledType p4 ((':) @Plutarch.DataRepr.Internal.PLabeledType p5 ((':) @Plutarch.DataRepr.Internal.PLabeledType p6 ((':) @Plutarch.DataRepr.Internal.PLabeledType p7 ps))))))) ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip ((':) @Plutarch.DataRepr.Internal.Field.ToBind 'Plutarch.DataRepr.Internal.Field.Skip bs)))))))
instance forall (as :: [Plutarch.DataRepr.Internal.PLabeledType]). Plutarch.DataRepr.Internal.Field.PDataFields (Plutarch.DataRepr.Internal.PDataRecord as)
instance forall (as :: [Plutarch.DataRepr.Internal.PLabeledType]). Plutarch.DataRepr.Internal.Field.PDataFields (Plutarch.DataRepr.Internal.PDataSum ((':) @[Plutarch.DataRepr.Internal.PLabeledType] as ('[] @[Plutarch.DataRepr.Internal.PLabeledType])))
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Builtin.PIsData a, Plutarch.DataRepr.Internal.Field.PDataFields a) => Plutarch.DataRepr.Internal.Field.PDataFields (Plutarch.Builtin.PAsData a)

module Plutarch.DataRepr

-- | A sum of <a>PDataRecord</a>s. The underlying representation is the
--   <tt>Constr</tt> constructor, where the integer is the index of the
--   variant and the list is the record.
newtype PDataSum defs s
PDataSum :: NS (Compose (Term s) PDataRecord) defs -> PDataSum defs s

-- | If there is only a single variant, then we can safely extract it.
punDataSum :: Term s (PDataSum '[def] :--> PDataRecord def)

-- | Try getting the nth variant. Errs if it's another variant.
ptryIndexDataSum :: KnownNat n => Proxy n -> Term s (PDataSum (def ': defs) :--> PDataRecord (IndexList n (def ': defs)))
data DataReprHandlers (out :: PType) (defs :: [[PLabeledType]]) (s :: S)
[DRHNil] :: DataReprHandlers out '[] s
[DRHCons] :: (Term s (PDataRecord def) -> Term s out) -> DataReprHandlers out defs s -> DataReprHandlers out (def ': defs) s

-- | A "record" of `exists a. PAsData a`. The underlying representation is
--   `PBuiltinList PData`.
data PDataRecord (as :: [PLabeledType]) (s :: S)
[PDCons] :: forall name_x x xs s. PUnLabel name_x ~ x => Term s (PAsData x) -> Term s (PDataRecord xs) -> PDataRecord (name_x ': xs) s
[PDNil] :: PDataRecord '[] s

-- | Cons a field to a data record.
--   
--   You can specify the label to associate with the field using type
--   applications-
--   
--   <pre>
--   foo :: Term s (PDataRecord '[ "fooField" ':= PByteString ])
--   foo = pdcons @"fooField" # pdata (phexByteStr "ab") # pdnil
--   </pre>
pdcons :: forall label a l s. Term s (PAsData a :--> (PDataRecord l :--> PDataRecord ((label ':= a) ': l)))

-- | An empty <a>PDataRecord</a>.
pdnil :: Term s (PDataRecord '[])
data PLabeledType
(:=) :: Symbol -> PType -> PLabeledType

-- | Safely index a <a>PDataRecord</a>.
pindexDataRecord :: KnownNat n => Proxy n -> Term s (PDataRecord as) -> Term s (PAsData (PUnLabel (IndexList n as)))

-- | Safely drop the first n items of a <a>PDataRecord</a>.
pdropDataRecord :: KnownNat n => Proxy n -> Term s (PDataRecord xs) -> Term s (PDataRecord (Drop n xs))

-- | For deriving <tt>PConstant</tt> for a wrapped type represented by a
--   builtin type, see <tt>DerivePConstantViaNewtype</tt>.
newtype DerivePConstantViaData (h :: Type) (p :: PType)

-- | The Haskell type for which @PConstant is being derived.
DerivePConstantViaData :: h -> DerivePConstantViaData (h :: Type) (p :: PType)

-- | Type synonym to simplify deriving of <tt>PConstant</tt> via
--   <tt>DerivePConstantViaData</tt>.
--   
--   A type <tt>Foo a</tt> is considered <a>ConstantableData</a> if:
--   
--   <ul>
--   <li>The wrapped type <tt>a</tt> has a <tt>PConstant</tt>
--   instance.</li>
--   <li>The lifted type of <tt>a</tt> has a <tt>PUnsafeLiftDecl</tt>
--   instance.</li>
--   <li>There is type equality between <tt>a</tt> and <tt>PLifted
--   (PConstanted a)</tt>.</li>
--   <li>The newtype has <tt>FromData</tt> and <tt>ToData</tt>
--   instances</li>
--   </ul>
--   
--   These constraints are sufficient to derive a <tt>PConstant</tt>
--   instance for the newtype.
--   
--   For deriving <tt>PConstant</tt> for a wrapped type represented in UPLC
--   as <tt>Data</tt>, see <tt>DerivePConstantViaData</tt>.
--   
--   Polymorphic types can be derived as follows:
--   
--   <pre>
--   data Bar a = Bar a deriving stock (GHC.Generic)
--   
--   PlutusTx.makeLift ''Bar
--   PlutusTx.makeIsDataIndexed ''Bar [('Bar, 0)]
--   
--   data PBar (a :: PType) (s :: S)
--     = PBar (Term s (PDataRecord '["_0" ':= a]))
--     deriving stock (GHC.Generic)
--     deriving anyclass (SOP.Generic, PIsDataRepr)
--     deriving (PlutusType, PIsData, PDataFields) via PIsDataReprInstances (PBar a)
--   
--   instance
--     forall a.
--     PLiftData a =&gt;
--     PUnsafeLiftDecl (PBar a)
--     where
--     type PLifted (PBar a) = Bar (PLifted a)
--   
--   deriving via
--     ( DerivePConstantViaData
--         (Bar a)
--         (PBar (PConstanted a))
--     )
--     instance
--       PConstantData a =&gt;
--       PConstantDecl (Bar a)
--   </pre>
type PConstantData h = (PConstant h, FromData h, ToData h, PIsData (PConstanted h))
type PLiftData p = (PLift p, FromData (PLifted p), ToData (PLifted p), PIsData p)
data PlutusTypeData

-- | Class allowing <tt>letFields</tt> to work for a PType, usually via
--   <tt>PIsDataRepr</tt>, but is derived for some other types for
--   convenience.
class PDataFields (a :: PType) where {
    
    -- | Fields in HRec bound by <tt>letFields</tt>
    type PFields a :: [PLabeledType];
    type PFields a = Helper (PInner a);
}

-- | Convert a Term to a <tt>PDataList</tt>
ptoFields :: PDataFields a => Term s a -> Term s (PDataRecord (PFields a))

-- | Convert a Term to a <tt>PDataList</tt>
ptoFields :: (PDataFields a, PDataFields (PInner a), PFields (PInner a) ~ PFields a) => Term s a -> Term s (PDataRecord (PFields a))

-- | Bind a HRec of named fields containing all the specified fields.
pletFields :: forall fs a s b ps bs. (PDataFields a, ps ~ PFields a, bs ~ Bindings ps fs, BindFields ps bs) => Term s a -> (HRecOf a fs s -> Term s b) -> Term s b

-- | Get a single field from a Term.
--   
--   <ul>
--   <li>NB*: If you access more than one field from the same value you
--   should use <a>pletFields</a> instead, which will generate the bindings
--   more efficiently.</li>
--   </ul>
pfield :: forall name b p s a as n. (PDataFields p, as ~ PFields p, n ~ PLabelIndex name as, KnownNat n, a ~ PUnLabel (IndexList n as), PFromDataable a b) => Term s (p :--> b)
data HRec as

-- | The <a>HRec</a> yielded by 'pletFields @fs t'.
type HRecOf t fs s = HRec (BoundTerms (PFields t) (Bindings (PFields t) fs) s)

-- | Constrain an <a>HRec</a> to contain the specified fields from the
--   given Plutarch type.
--   
--   <h3>Example ===</h3>
--   
--   <pre>
--   import qualified GHC.Generics as GHC
--   import Generics.SOP
--   
--   import Plutarch.Prelude
--   import Plutarch.DataRepr
--   
--   newtype PFooType s = PFooType (Term s (PDataRecord '["frst" ':= PInteger, "scnd" ':= PBool, "thrd" ':= PString]))
--     deriving stock (GHC.Generic)
--     deriving anyclass (Generic)
--     deriving anyclass (PIsDataRepr)
--     deriving
--       (PlutusType, PIsData, PDataFields, PEq)
--       via PIsDataReprInstances PFooType
--   
--   foo :: PMemberFields PFooType '["scnd", "frst"] s as =&gt; HRec as -&gt; Term s PInteger
--   foo h = pif (getField <tt>"scnd" h) (getField </tt>"frst" h) 0
--   </pre>
type family PMemberFields t fs s as

-- | Single field version of <a>PMemberFields</a>.
type family PMemberField t name s as

module Plutarch.Prelude
data (:-->) (a :: PType) (b :: PType) (s :: S)
infixr 0 :-->
data PDelayed (a :: PType) (s :: S)
data Term (s :: S) (a :: PType)

-- | <ul>
--   <li>Closed* terms with no free variables.</li>
--   </ul>
type ClosedTerm (a :: PType) = forall (s :: S). Term s a
plam :: forall c. (PLamN a b s, HasCallStack) => (Term s c -> a) -> Term s (c :--> b)

-- | Lambda Application.
papp :: Term s (a :--> b) -> Term s a -> Term s b

-- | Plutus 'delay', used for laziness.
pdelay :: Term s a -> Term s (PDelayed a)

-- | Plutus 'force', used to force evaluation of <a>PDelayed</a> terms.
pforce :: Term s (PDelayed a) -> Term s a
phoistAcyclic :: HasCallStack => ClosedTerm a -> Term s a

-- | Plutus 'error'.
--   
--   When using this explicitly, it should be ensured that the containing
--   term is delayed, avoiding premature evaluation.
perror :: Term s a

-- | Low precedence infixr synonym of <a>papp</a>, to be used like
--   <a>$</a>, in combination with <a>#</a>. e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; f # x #$ g # y # z
--   f x (g y z)
--   </pre>
(#$) :: Term s (a :--> b) -> Term s a -> Term s b
infixr 0 #$

-- | High precedence infixl synonym of <a>papp</a>, to be used like
--   function juxtaposition. e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; f # x # y
--   f x y
--   </pre>
(#) :: Term s (a :--> b) -> Term s a -> Term s b
infixl 8 #

-- | Let bindings.
--   
--   This is approximately a shorthand for a lambda and application:
--   
--   <tt>plet v f</tt> == <tt> papp (plam f) v</tt>
--   
--   But sufficiently small terms in WHNF may be inlined for efficiency.
plet :: Term s a -> (Term s a -> Term s b) -> Term s b
pinl :: Term s a -> (Term s a -> Term s b) -> Term s b

-- | Safely coerce from a Term to it's <a>PInner</a> representation.
pto :: Term s a -> Term s (PInner a)

-- | Fixpoint recursion. Used to encode recursive functions.
--   
--   Example:
--   
--   <pre>
--   iterateN' ::
--    Term s (PInteger :--&gt; (a :--&gt; a) :--&gt; a :--&gt; a) -&gt;
--    Term s PInteger -&gt;
--    Term s (a :--&gt; a) -&gt;
--    Term s a
--   iterateN' self n f x =
--     pif (n #== 0) x (self # n - 1 #$ f x)
--   
--   iterateN :: Term s (PInteger :--&gt; (a :--&gt; a) :--&gt; a :--&gt; a)
--   iterateN = pfix #$ plam iterateN'
--   </pre>
--   
--   Further examples can be found in examples/Recursion.hs
pfix :: Term s (((a :--> b) :--> (a :--> b)) :--> (a :--> b))
pthrow :: HasCallStack => Text -> Term s a

-- | The kind of types with lifted values. For example <tt>Int ::
--   Type</tt>.
type Type = TYPE LiftedRep
data S

-- | Shorthand for Plutarch types.
type PType = S -> Type
class PlutusType (a :: PType) where {
    type PInner a :: PType;
    type PInner a = DerivedPInner (DPTStrat a) a;
    type PCovariant' a = All2 PCovariant'' (PCode a);
    type PContravariant' a = All2 PContravariant'' (PCode a);
    type PVariant' a = All2 PVariant'' (PCode a);
}
class (PInner a ~ DerivedPInner (DPTStrat a) a, PlutusTypeStrat (DPTStrat a), PlutusTypeStratConstraint (DPTStrat a) a, PlutusType a) => DerivePlutusType (a :: PType)
type DPTStrat a :: Type
data PlutusTypeScott
data PlutusTypeNewtype
data PlutusTypeData

-- | <i>Deprecated: Use PlutusType</i>
type PCon = PlutusType

-- | <i>Deprecated: Use PlutusType</i>
type PMatch = PlutusType

-- | Construct a Plutarch Term via a Haskell datatype
pcon :: PlutusType a => a s -> Term s a

-- | Pattern match over Plutarch Terms via a Haskell datatype
pmatch :: PlutusType a => Term s a -> (a s -> Term s b) -> Term s b
newtype PForall (b :: a -> PType) s
PForall :: (forall (x :: a). Term s (b x)) -> PForall (b :: a -> PType) s

-- | Plutus BuiltinInteger
data PInteger s
class PIntegral a
pdiv :: PIntegral a => Term s (a :--> (a :--> a))
pdiv :: (PIntegral a, PIntegral (PInner a)) => Term s (a :--> (a :--> a))
pmod :: PIntegral a => Term s (a :--> (a :--> a))
pmod :: (PIntegral a, PIntegral (PInner a)) => Term s (a :--> (a :--> a))
pquot :: PIntegral a => Term s (a :--> (a :--> a))
pquot :: (PIntegral a, PIntegral (PInner a)) => Term s (a :--> (a :--> a))
prem :: PIntegral a => Term s (a :--> (a :--> a))
prem :: (PIntegral a, PIntegral (PInner a)) => Term s (a :--> (a :--> a))

-- | Note: This type is _not_ the synonym of <a>Rational</a>.
data PRational s
PRational :: Term s PInteger -> Term s PPositive -> PRational s
pnumerator :: Term s (PRational :--> PInteger)
pdenominator :: Term s (PRational :--> PPositive)
pround :: Term s (PRational :--> PInteger)

-- | Plutus <tt>BuiltinBool</tt>
data PBool (s :: S)
PTrue :: PBool (s :: S)
PFalse :: PBool (s :: S)
class PEq t
(#==) :: PEq t => Term s t -> Term s t -> Term s PBool
(#==) :: (PEq t, PGeneric t, PlutusType t, All2 PEq (PCode t)) => Term s t -> Term s t -> Term s PBool
infix 4 #==

-- | Partial ordering relation.
class PEq t => PPartialOrd t
(#<=) :: PPartialOrd t => Term s t -> Term s t -> Term s PBool
(#<=) :: (PPartialOrd t, POrd (PInner t)) => Term s t -> Term s t -> Term s PBool
(#<) :: PPartialOrd t => Term s t -> Term s t -> Term s PBool
(#<) :: (PPartialOrd t, POrd (PInner t)) => Term s t -> Term s t -> Term s PBool
infix 4 #<=
infix 4 #<

-- | Total ordering relation.
class PPartialOrd t => POrd t

-- | Lazy if-then-else.
pif :: Term s PBool -> Term s a -> Term s a -> Term s a

-- | Boolean negation for <a>PBool</a> terms.
pnot :: Term s (PBool :--> PBool)

-- | Lazily evaluated boolean and for <a>PBool</a> terms.
(#&&) :: Term s PBool -> Term s PBool -> Term s PBool
infixr 3 #&&

-- | Lazily evaluated boolean or for <a>PBool</a> terms.
(#||) :: Term s PBool -> Term s PBool -> Term s PBool
infixr 2 #||

-- | Plutus <tt>BuiltinByteString</tt>
data PByteString s

-- | Interpret a hex string as a PByteString.
phexByteStr :: HasCallStack => String -> Term s PByteString

-- | Prepend a byte, represented by a non negative <a>PInteger</a>, to a
--   <tt>PBytestring</tt>.
pconsBS :: Term s (PInteger :--> (PByteString :--> PByteString))

-- | Slice a <a>PByteString</a> with given start index and slice length.
--   
--   <pre>
--   &gt;&gt;&gt; (pslice # 2 # 3 phexByteStr "4102afde5b2a") #== phexByteStr "afde5b"
--   </pre>
psliceBS :: Term s (PInteger :--> (PInteger :--> (PByteString :--> PByteString)))

-- | Find the length of a <a>PByteString</a>.
plengthBS :: Term s (PByteString :--> PInteger)

-- | <a>PByteString</a> indexing function.
pindexBS :: Term s (PByteString :--> (PInteger :--> PInteger))

-- | Plutus <tt>BuiltinString</tt> values
data PString s

-- | Encode a <a>PString</a> using UTF-8.
pencodeUtf8 :: Term s (PString :--> PByteString)

-- | Decode a <a>PByteString</a> using UTF-8.
pdecodeUtf8 :: Term s (PByteString :--> PString)
data PUnit s
PUnit :: PUnit s

-- | Plutarch types that behave like lists.
class PListLike (list :: PType -> PType) where {
    type PElemConstraint list (a :: PType) :: Constraint;
}

-- | Canonical eliminator for list-likes.
pelimList :: (PListLike list, PElemConstraint list a) => (Term s a -> Term s (list a) -> Term s r) -> Term s r -> Term s (list a) -> Term s r

-- | Cons an element onto an existing list.
pcons :: (PListLike list, PElemConstraint list a) => Term s (a :--> (list a :--> list a))

-- | The empty list
pnil :: (PListLike list, PElemConstraint list a) => Term s (list a)

-- | Return the first element of a list. Partial, throws an error upon
--   encountering an empty list.
phead :: (PListLike list, PElemConstraint list a) => Term s (list a :--> a)

-- | Take the tail of a list, meaning drop its head. Partial, throws an
--   error upon encountering an empty list.
ptail :: (PListLike list, PElemConstraint list a) => Term s (list a :--> list a)

-- | <i> O(1) </i>. Check if a list is empty
pnull :: (PListLike list, PElemConstraint list a) => Term s (list a :--> PBool)

-- | 'PIsListLike list a' constraints <tt>list</tt> be a <a>PListLike</a>
--   with valid element type, <tt>a</tt>.
type PIsListLike list a = (PListLike list, PElemConstraint list a)

-- | <i> O(min(n, m)) </i>. Check if two lists are equal.
plistEquals :: (PIsListLike list a, PEq a) => Term s (list a :--> (list a :--> PBool))

-- | <i> O(n) </i>. Check if element is in the list
pelem :: (PIsListLike list a, PEq a) => Term s (a :--> (list a :--> PBool))

-- | <i> O(n) </i>. Like Haskell level <a>(!!)</a> but on the Plutarch
--   level, not infix and with arguments reversed, errors if the specified
--   index is greater than or equal to the lists length
pelemAt :: PIsListLike l a => Term s (PInteger :--> (l a :--> a))

-- | <i> O(n) </i>. Count the number of elements in the list
plength :: PIsListLike list a => Term s (list a :--> PInteger)

-- | Index a BuiltinList, throwing an error if the index is out of bounds.
ptryIndex :: PIsListLike list a => Natural -> Term s (list a) -> Term s a

-- | Drop the first n fields of a List.
--   
--   The term will be statically generated as repeated applications of
--   <a>ptail</a>, which will be more efficient in many circumstances.
pdrop :: PIsListLike list a => Natural -> Term s (list a) -> Term s (list a)

-- | <i> O(1) </i>. Create a singleton list from an element
psingleton :: PIsListLike list a => Term s (a :--> list a)

-- | <i> O(n) </i>. Concatenate two lists
--   
--   Example: &gt; pconcat # psingleton x # psingleton y == plistLiteral
--   [x, y]
--   
--   pconcat exhibits identities with empty lists such that &gt; forall x.
--   pconcat # pnil # x == x &gt; forall x. pconcat # x # pnil == x
pconcat :: PIsListLike list a => Term s (list a :--> (list a :--> list a))

-- | <i> O(min(n, m)) </i>. Zip two lists together with a passed function.
--   
--   If the lists are of differing lengths, cut to the shortest.
pzipWith :: (PListLike list, PElemConstraint list a, PElemConstraint list b, PElemConstraint list c) => Term s ((a :--> (b :--> c)) :--> (list a :--> (list b :--> list c)))

-- | Like <a>pzipWith</a> but with Haskell-level merge function.
pzipWith' :: (PListLike list, PElemConstraint list a, PElemConstraint list b, PElemConstraint list c) => (Term s a -> Term s b -> Term s c) -> Term s (list a :--> (list b :--> list c))

-- | <i> O(min(n, m)) </i>. Zip two lists together, creating pairs of the
--   elements.
--   
--   If the lists are of differing lengths, cut to the shortest.
pzip :: (PListLike list, PElemConstraint list a, PElemConstraint list b, PElemConstraint list (PPair a b)) => Term s (list a :--> (list b :--> list (PPair a b)))

-- | <i> O(n) </i>. Map a function over a list of elements
pmap :: (PListLike list, PElemConstraint list a, PElemConstraint list b) => Term s ((a :--> b) :--> (list a :--> list b))

-- | <i> O(n) </i>. Filter elements from a list that don't match the
--   predicate.
pfilter :: PIsListLike list a => Term s ((a :--> PBool) :--> (list a :--> list a))

-- | <i> O(n) </i>. like haskell level <tt>find</tt> but on plutarch level
pfind :: PIsListLike l a => Term s ((a :--> PBool) :--> (l a :--> PMaybe a))

-- | Like <a>pelimList</a>, but with a fixpoint recursion hatch.
precList :: PIsListLike list a => (Term s (list a :--> r) -> Term s a -> Term s (list a) -> Term s r) -> (Term s (list a :--> r) -> Term s r) -> Term s (list a :--> r)

-- | <i> O(n) </i>. Fold on a list right-associatively.
pfoldr :: PIsListLike list a => Term s ((a :--> (b :--> b)) :--> (b :--> (list a :--> b)))

-- | <i> O(n) </i>. Fold on a list right-associatively, with opportunity
--   for short circuting.
--   
--   May short circuit when given reducer function is lazy in its second
--   argument.
pfoldrLazy :: PIsListLike list a => Term s ((a :--> (PDelayed b :--> b)) :--> (b :--> (list a :--> b)))

-- | <i> O(n) </i>. Fold on a list left-associatively.
pfoldl :: PIsListLike list a => Term s ((b :--> (a :--> b)) :--> (b :--> (list a :--> b)))

-- | <i> O(n) </i>. Check that predicate holds for all elements in a list.
pall :: PIsListLike list a => Term s ((a :--> PBool) :--> (list a :--> PBool))

-- | <i> O(n) </i>. Check that predicate holds for any element in a list.
pany :: PIsListLike list a => Term s ((a :--> PBool) :--> (list a :--> PBool))

-- | <i> O(n) </i>. Like Haskell level <a>(!!)</a> but on the plutarch
--   level
(#!!) :: PIsListLike l a => Term s (l a) -> Term s PInteger -> Term s a
data PList (a :: PType) (s :: S)
PSCons :: Term s a -> Term s (PList a) -> PList (a :: PType) (s :: S)
PSNil :: PList (a :: PType) (s :: S)

-- | Plutus Maybe type, with Scott-encoded repr
data PMaybe (a :: PType) (s :: S)
PJust :: Term s a -> PMaybe (a :: PType) (s :: S)
PNothing :: PMaybe (a :: PType) (s :: S)
data PEither (a :: PType) (b :: PType) (s :: S)
PLeft :: Term s a -> PEither (a :: PType) (b :: PType) (s :: S)
PRight :: Term s b -> PEither (a :: PType) (b :: PType) (s :: S)

-- | Plutus encoding of Pairs.
--   
--   Note: This is represented differently than <tt>BuiltinPair</tt>. It is
--   scott-encoded.
data PPair (a :: PType) (b :: PType) (s :: S)
PPair :: Term s a -> Term s b -> PPair (a :: PType) (b :: PType) (s :: S)

-- | An Arbitrary Term with an unknown type
newtype POpaque s
POpaque :: Term s POpaque -> POpaque s

-- | Erase the type of a Term
popaque :: Term s a -> Term s POpaque
data PData (s :: S)
pfstBuiltin :: Term s (PBuiltinPair a b :--> a)
psndBuiltin :: Term s (PBuiltinPair a b :--> b)

-- | Plutus <tt>BuiltinPair</tt>
data PBuiltinPair (a :: PType) (b :: PType) (s :: S)

-- | Plutus <tt>BuiltinList</tt>
data PBuiltinList (a :: PType) (s :: S)
PCons :: Term s a -> Term s (PBuiltinList a) -> PBuiltinList (a :: PType) (s :: S)
PNil :: PBuiltinList (a :: PType) (s :: S)

-- | Laws: - If <tt>PSubtype PData a</tt>, then <tt>pdataImpl a</tt> must
--   be <a>pupcast</a>. - pdataImpl . pupcast . pfromDataImpl ≡ id -
--   pfromDataImpl . punsafeDowncast . pdataImpl ≡ id
class PIsData a
pfromData :: PIsData a => Term s (PAsData a) -> Term s a
pdata :: PIsData a => Term s a -> Term s (PAsData a)
data PAsData (a :: PType) (s :: S)

-- | A "record" of `exists a. PAsData a`. The underlying representation is
--   `PBuiltinList PData`.
data PDataRecord (as :: [PLabeledType]) (s :: S)

-- | A sum of <a>PDataRecord</a>s. The underlying representation is the
--   <tt>Constr</tt> constructor, where the integer is the index of the
--   variant and the list is the record.
data PDataSum defs s
data PLabeledType
(:=) :: Symbol -> PType -> PLabeledType

-- | Cons a field to a data record.
--   
--   You can specify the label to associate with the field using type
--   applications-
--   
--   <pre>
--   foo :: Term s (PDataRecord '[ "fooField" ':= PByteString ])
--   foo = pdcons @"fooField" # pdata (phexByteStr "ab") # pdnil
--   </pre>
pdcons :: forall label a l s. Term s (PAsData a :--> (PDataRecord l :--> PDataRecord ((label ':= a) ': l)))

-- | An empty <a>PDataRecord</a>.
pdnil :: Term s (PDataRecord '[])

-- | Get a single field from a Term.
--   
--   <ul>
--   <li>NB*: If you access more than one field from the same value you
--   should use <a>pletFields</a> instead, which will generate the bindings
--   more efficiently.</li>
--   </ul>
pfield :: forall name b p s a as n. (PDataFields p, as ~ PFields p, n ~ PLabelIndex name as, KnownNat n, a ~ PUnLabel (IndexList n as), PFromDataable a b) => Term s (p :--> b)

-- | Selector function to extract the field from the record.
getField :: HasField x r a => r -> a

-- | Bind a HRec of named fields containing all the specified fields.
pletFields :: forall fs a s b ps bs. (PDataFields a, ps ~ PFields a, bs ~ Bindings ps fs, BindFields ps bs) => Term s a -> (HRecOf a fs s -> Term s b) -> Term s b
class PShow t

-- | Return the string representation of a Plutarch value
pshow :: PShow a => Term s a -> Term s PString

-- | Trace the given message before evaluating the argument.
ptrace :: Term s PString -> Term s a -> Term s a

-- | Like Haskell's <tt>traceShowId</tt> but for Plutarch
ptraceShowId :: PShow a => Term s a -> Term s a

-- | Trace the given message if the argument evaluates to False.
ptraceIfFalse :: Term s PString -> Term s PBool -> Term s PBool

-- | Trace the given message if the argument evaluates to true.
ptraceIfTrue :: Term s PString -> Term s PBool -> Term s PBool

-- | Trace the given message and terminate evaluation with a <a>perror</a>.
ptraceError :: Term s PString -> Term s a

-- | Hash a <a>PByteString</a> using SHA-256.
psha2_256 :: Term s (PByteString :--> PByteString)

-- | Hash a <a>PByteString</a> using SHA3-256.
psha3_256 :: Term s (PByteString :--> PByteString)

-- | Verify the signature against the public key and message.

-- | <i>Deprecated: use one of the Ed25519, Schnorr- or ECDSA Secp256k1
--   signature verification functions</i>
pverifySignature :: Term s (PByteString :--> (PByteString :--> (PByteString :--> PBool)))

-- | Create a Plutarch-level constant, from a Haskell value. Example: &gt;
--   pconstant @PInteger 42
pconstant :: forall p s. PLift p => PLifted p -> Term s p

-- | Create a Plutarch-level <a>PAsData</a> constant, from a Haskell value.
--   Example: &gt; pconstantData @PInteger 42
pconstantData :: forall p h s. (ToData h, PLifted p ~ h, PConstanted h ~ p) => h -> Term s (PAsData p)

-- | Like <a>plift'</a> but throws on failure.
plift :: forall p. (HasCallStack, PLift p) => ClosedTerm p -> PLifted p

-- | Type synonym to simplify deriving of <tt>PConstant</tt> via
--   <tt>DerivePConstantViaNewtype</tt>.
--   
--   A newtype <tt>Foo a</tt> is considered <a>Constantable</a> if:
--   
--   <ul>
--   <li>The wrapped type <tt>a</tt> has a <tt>PConstant</tt>
--   instance.</li>
--   <li>The lifted type of <tt>a</tt> has a <tt>PUnsafeLiftDecl</tt>
--   instance.</li>
--   <li>There is type equality between <tt>a</tt> and <tt>PLifted
--   (PConstanted a)</tt>.</li>
--   </ul>
--   
--   These constraints are sufficient to derive a <tt>PConstant</tt>
--   instance for the newtype.
--   
--   For deriving <tt>PConstant</tt> for a wrapped type represented in UPLC
--   as <tt>Data</tt>, see <tt>DerivePConstantViaData</tt>.
type PConstant a = (a ~ PLifted (PConstanted a), PConstantDecl a)

-- | Class of Plutarch types <tt>p</tt> that can be converted to/from a
--   Haskell type.
--   
--   The Haskell type is determined by `PLifted p`.
--   
--   This typeclass is closely tied with <a>PConstant</a>.
type PLift = PUnsafeLiftDecl

-- | Type synonym to simplify deriving of <tt>PConstant</tt> via
--   <tt>DerivePConstantViaData</tt>.
--   
--   A type <tt>Foo a</tt> is considered <a>ConstantableData</a> if:
--   
--   <ul>
--   <li>The wrapped type <tt>a</tt> has a <tt>PConstant</tt>
--   instance.</li>
--   <li>The lifted type of <tt>a</tt> has a <tt>PUnsafeLiftDecl</tt>
--   instance.</li>
--   <li>There is type equality between <tt>a</tt> and <tt>PLifted
--   (PConstanted a)</tt>.</li>
--   <li>The newtype has <tt>FromData</tt> and <tt>ToData</tt>
--   instances</li>
--   </ul>
--   
--   These constraints are sufficient to derive a <tt>PConstant</tt>
--   instance for the newtype.
--   
--   For deriving <tt>PConstant</tt> for a wrapped type represented in UPLC
--   as <tt>Data</tt>, see <tt>DerivePConstantViaData</tt>.
--   
--   Polymorphic types can be derived as follows:
--   
--   <pre>
--   data Bar a = Bar a deriving stock (GHC.Generic)
--   
--   PlutusTx.makeLift ''Bar
--   PlutusTx.makeIsDataIndexed ''Bar [('Bar, 0)]
--   
--   data PBar (a :: PType) (s :: S)
--     = PBar (Term s (PDataRecord '["_0" ':= a]))
--     deriving stock (GHC.Generic)
--     deriving anyclass (SOP.Generic, PIsDataRepr)
--     deriving (PlutusType, PIsData, PDataFields) via PIsDataReprInstances (PBar a)
--   
--   instance
--     forall a.
--     PLiftData a =&gt;
--     PUnsafeLiftDecl (PBar a)
--     where
--     type PLifted (PBar a) = Bar (PLifted a)
--   
--   deriving via
--     ( DerivePConstantViaData
--         (Bar a)
--         (PBar (PConstanted a))
--     )
--     instance
--       PConstantData a =&gt;
--       PConstantDecl (Bar a)
--   </pre>
type PConstantData h = (PConstant h, FromData h, ToData h, PIsData (PConstanted h))
type PLiftData p = (PLift p, FromData (PLifted p), ToData (PLifted p), PIsData p)
newtype TermCont :: forall (r :: PType). S -> Type -> Type
[TermCont] :: forall r s a. ((a -> Term s r) -> Term s r) -> TermCont @r s a
unTermCont :: TermCont @a s (Term s a) -> Term s a
tcont :: ((a -> Term s r) -> Term s r) -> TermCont @r s a
pupcast :: forall a b s. PSubtype a b => Term s b -> Term s a
ptryFrom :: forall b a s r. PTryFrom a b => Term s a -> ((Term s b, Reduce (PTryFromExcess a b s)) -> Term s r) -> Term s r

-- | <tt>PTryFrom a b</tt> represents a subtyping relationship between
--   <tt>a</tt> and <tt>b</tt>, and a way to go from <tt>a</tt> to
--   <tt>b</tt>. Laws: - <tt>(punsafeCoerce . fst) <a>$</a> tcont (ptryFrom
--   x) ≡ pure x</tt>
class PSubtype a b => PTryFrom (a :: PType) (b :: PType)
type family PSubtype (a :: PType) (b :: PType) :: Constraint

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <a>id</a>
--   <a>to</a> . <a>from</a> ≡ <a>id</a>
--   </pre>
class () => Generic a

module Plutarch.Monadic

-- | Bind function used within do syntax.
--   
--   Enables elegant usage of <a>pmatch</a> and similar. <tt>P.do { y &lt;-
--   x ; z }</tt> is equivalent to <tt>x $ y -&gt; z</tt>.
--   
--   <pre>
--   import qualified Plutarch.Monadic as P
--   
--   f :: Term s (PTxInfo :--&gt; PBuiltinList (PAsData PTxInInfo))
--   f = plam $ x -&gt; P.do
--     PTxInfo txInfoFields &lt;- pmatch x
--     pfromData $ pdhead # txInfoFields
--   </pre>
(>>=) :: (x -> Term s a) -> x -> Term s a

-- | Forgetful bind function used within do syntax.
--   
--   Enables elegant usage of <a>ptrace</a> and similar. <tt>P.do { x ; y
--   }</tt> is equivalent to <tt>x y</tt>.
--   
--   <pre>
--   import qualified Plutarch.Monadic as P
--   
--   P.do
--     ptrace "yielding unit"
--     pconstant ()
--   </pre>
(>>) :: (x -> Term s a) -> x -> Term s a

-- | Implicitly invoked upon pattern match failure within do syntax.
--   
--   <pre>
--   import qualified Plutarch.Monadic as P
--   
--   P.do
--     -- calls <a>fail</a>, traces an error message, and invokes <a>perror</a>.
--     PTrue &lt;- pconstant False
--   </pre>
fail :: String -> Term s a

module Plutarch.Api.V1.Interval
newtype PInterval a (s :: S)
PInterval :: Term s (PDataRecord '["from" ':= PLowerBound a, "to" ':= PUpperBound a]) -> PInterval a (s :: S)
newtype PLowerBound a (s :: S)
PLowerBound :: Term s (PDataRecord '["_0" ':= PExtended a, "_1" ':= PClosure]) -> PLowerBound a (s :: S)
newtype PUpperBound a (s :: S)
PUpperBound :: Term s (PDataRecord '["_0" ':= PExtended a, "_1" ':= PClosure]) -> PUpperBound a (s :: S)
data PExtended a (s :: S)
PNegInf :: Term s (PDataRecord '[]) -> PExtended a (s :: S)
PFinite :: Term s (PDataRecord '["_0" ':= a]) -> PExtended a (s :: S)
PPosInf :: Term s (PDataRecord '[]) -> PExtended a (s :: S)
type PClosure = PBool
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Builtin.PIsData a, Plutarch.Show.PShow a) => Plutarch.Show.PShow (Plutarch.Api.V1.Interval.PExtended a)
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Bool.POrd a, Plutarch.Builtin.PIsData a) => Plutarch.Bool.POrd (Plutarch.Api.V1.Interval.PExtended a)
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Bool.POrd a, Plutarch.Builtin.PIsData a) => Plutarch.Bool.PPartialOrd (Plutarch.Api.V1.Interval.PExtended a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Bool.PEq (Plutarch.Api.V1.Interval.PExtended a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Builtin.PIsData (Plutarch.Api.V1.Interval.PExtended a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Api.V1.Interval.PExtended a)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Interval.PExtended a s)
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Builtin.PIsData a, Plutarch.Show.PShow a) => Plutarch.Show.PShow (Plutarch.Api.V1.Interval.PUpperBound a)
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Bool.POrd a, Plutarch.Builtin.PIsData a) => Plutarch.Bool.POrd (Plutarch.Api.V1.Interval.PUpperBound a)
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Bool.POrd a, Plutarch.Builtin.PIsData a) => Plutarch.Bool.PPartialOrd (Plutarch.Api.V1.Interval.PUpperBound a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Bool.PEq (Plutarch.Api.V1.Interval.PUpperBound a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.DataRepr.Internal.Field.PDataFields (Plutarch.Api.V1.Interval.PUpperBound a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Builtin.PIsData (Plutarch.Api.V1.Interval.PUpperBound a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Api.V1.Interval.PUpperBound a)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Interval.PUpperBound a s)
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Builtin.PIsData a, Plutarch.Show.PShow a) => Plutarch.Show.PShow (Plutarch.Api.V1.Interval.PLowerBound a)
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Bool.POrd a, Plutarch.Builtin.PIsData a) => Plutarch.Bool.POrd (Plutarch.Api.V1.Interval.PLowerBound a)
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Bool.POrd a, Plutarch.Builtin.PIsData a) => Plutarch.Bool.PPartialOrd (Plutarch.Api.V1.Interval.PLowerBound a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Bool.PEq (Plutarch.Api.V1.Interval.PLowerBound a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.DataRepr.Internal.Field.PDataFields (Plutarch.Api.V1.Interval.PLowerBound a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Builtin.PIsData (Plutarch.Api.V1.Interval.PLowerBound a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Api.V1.Interval.PLowerBound a)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Interval.PLowerBound a s)
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Builtin.PIsData a, Plutarch.Show.PShow a) => Plutarch.Show.PShow (Plutarch.Api.V1.Interval.PInterval a)
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Bool.POrd a, Plutarch.Builtin.PIsData a) => Plutarch.Bool.POrd (Plutarch.Api.V1.Interval.PInterval a)
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Bool.POrd a, Plutarch.Builtin.PIsData a) => Plutarch.Bool.PPartialOrd (Plutarch.Api.V1.Interval.PInterval a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Bool.PEq (Plutarch.Api.V1.Interval.PInterval a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.DataRepr.Internal.Field.PDataFields (Plutarch.Api.V1.Interval.PInterval a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Builtin.PIsData (Plutarch.Api.V1.Interval.PInterval a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Api.V1.Interval.PInterval a)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Interval.PInterval a s)
instance forall a. Plutarch.DataRepr.Internal.PConstantData a => Plutarch.Lift.PConstantDecl (PlutusLedgerApi.V1.Interval.Interval a)
instance forall a. Plutarch.DataRepr.Internal.PConstantData a => Plutarch.Lift.PConstantDecl (PlutusLedgerApi.V1.Interval.LowerBound a)
instance forall a. Plutarch.DataRepr.Internal.PConstantData a => Plutarch.Lift.PConstantDecl (PlutusLedgerApi.V1.Interval.UpperBound a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Api.V1.Interval.PInterval a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.DataRepr.Internal.PLiftData a => Plutarch.Lift.PUnsafeLiftDecl (Plutarch.Api.V1.Interval.PInterval a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Api.V1.Interval.PLowerBound a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.DataRepr.Internal.PLiftData a => Plutarch.Lift.PUnsafeLiftDecl (Plutarch.Api.V1.Interval.PLowerBound a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Api.V1.Interval.PUpperBound a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.DataRepr.Internal.PLiftData a => Plutarch.Lift.PUnsafeLiftDecl (Plutarch.Api.V1.Interval.PUpperBound a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Api.V1.Interval.PExtended a)

module Plutarch.Api.V1.Tuple
type PTuple a b = PDataSum '[ '["_0" ':= a, "_1" ':= b]]
ptuple :: Term s (PAsData a :--> (PAsData b :--> PTuple a b))
ptupleFromBuiltin :: Term s (PAsData (PBuiltinPair (PAsData a) (PAsData b))) -> Term s (PAsData (PTuple a b))
pbuiltinPairFromTuple :: Term s (PAsData (PTuple a b)) -> Term s (PAsData (PBuiltinPair (PAsData a) (PAsData b)))

module Plutarch.Api.V1.Time
newtype PPOSIXTime (s :: S)
PPOSIXTime :: Term s PInteger -> PPOSIXTime (s :: S)
type PPOSIXTimeRange = PInterval PPOSIXTime
instance Plutarch.Show.PShow Plutarch.Api.V1.Time.PPOSIXTime
instance Plutarch.Num.PNum Plutarch.Api.V1.Time.PPOSIXTime
instance Plutarch.Integer.PIntegral Plutarch.Api.V1.Time.PPOSIXTime
instance Plutarch.Bool.POrd Plutarch.Api.V1.Time.PPOSIXTime
instance Plutarch.Bool.PPartialOrd Plutarch.Api.V1.Time.PPOSIXTime
instance Plutarch.Bool.PEq Plutarch.Api.V1.Time.PPOSIXTime
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Time.PPOSIXTime
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Time.PPOSIXTime
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Time.PPOSIXTime s)
instance forall k1 k2 (f :: k2 -> k1 -> GHC.Types.Type) (a :: k1) (b :: k2). GHC.Generics.Generic (Plutarch.Api.V1.Time.Flip @{k2} @{k1} f a b)
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Time.POSIXTime
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.Api.V1.Time.PPOSIXTime)
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Time.PPOSIXTime
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Time.PPOSIXTime

module Plutarch.Api.V1.Scripts
newtype PDatum (s :: S)
PDatum :: Term s PData -> PDatum (s :: S)
newtype PDatumHash (s :: S)
PDatumHash :: Term s PByteString -> PDatumHash (s :: S)
newtype PRedeemer (s :: S)
PRedeemer :: Term s PData -> PRedeemer (s :: S)
newtype PRedeemerHash (s :: S)
PRedeemerHash :: Term s PByteString -> PRedeemerHash (s :: S)
newtype PScriptHash (s :: S)
PScriptHash :: Term s PByteString -> PScriptHash (s :: S)
instance Plutarch.Show.PShow Plutarch.Api.V1.Scripts.PDatum
instance Plutarch.Bool.PEq Plutarch.Api.V1.Scripts.PDatum
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Scripts.PDatum
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Scripts.PDatum
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Scripts.PDatum s)
instance Plutarch.Show.PShow Plutarch.Api.V1.Scripts.PRedeemer
instance Plutarch.Bool.PEq Plutarch.Api.V1.Scripts.PRedeemer
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Scripts.PRedeemer
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Scripts.PRedeemer
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Scripts.PRedeemer s)
instance Plutarch.Show.PShow Plutarch.Api.V1.Scripts.PDatumHash
instance Plutarch.Bool.POrd Plutarch.Api.V1.Scripts.PDatumHash
instance Plutarch.Bool.PPartialOrd Plutarch.Api.V1.Scripts.PDatumHash
instance Plutarch.Bool.PEq Plutarch.Api.V1.Scripts.PDatumHash
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Scripts.PDatumHash
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Scripts.PDatumHash
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Scripts.PDatumHash s)
instance Plutarch.Show.PShow Plutarch.Api.V1.Scripts.PRedeemerHash
instance Plutarch.Bool.POrd Plutarch.Api.V1.Scripts.PRedeemerHash
instance Plutarch.Bool.PPartialOrd Plutarch.Api.V1.Scripts.PRedeemerHash
instance Plutarch.Bool.PEq Plutarch.Api.V1.Scripts.PRedeemerHash
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Scripts.PRedeemerHash
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Scripts.PRedeemerHash
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Scripts.PRedeemerHash s)
instance Plutarch.Show.PShow Plutarch.Api.V1.Scripts.PScriptHash
instance Plutarch.Bool.POrd Plutarch.Api.V1.Scripts.PScriptHash
instance Plutarch.Bool.PPartialOrd Plutarch.Api.V1.Scripts.PScriptHash
instance Plutarch.Bool.PEq Plutarch.Api.V1.Scripts.PScriptHash
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Scripts.PScriptHash
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Scripts.PScriptHash
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Scripts.PScriptHash s)
instance forall k1 k2 (f :: k2 -> k1 -> GHC.Types.Type) (a :: k1) (b :: k2). GHC.Generics.Generic (Plutarch.Api.V1.Scripts.Flip @{k2} @{k1} f a b)
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Scripts.Datum
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Scripts.Redeemer
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Scripts.DatumHash
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Scripts.RedeemerHash
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Scripts.ScriptHash
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.Api.V1.Scripts.PScriptHash)
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Scripts.PScriptHash
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Scripts.PScriptHash
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Scripts.PRedeemerHash
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Scripts.PRedeemerHash
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Scripts.PDatumHash
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Scripts.PDatumHash
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Scripts.PRedeemer
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Scripts.PRedeemer
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Scripts.PDatum
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Scripts.PDatum

module Plutarch.Api.V1.Maybe

-- | Data encoded Maybe type. Used in various ledger api types.
data PMaybeData a (s :: S)
PDJust :: Term s (PDataRecord '["_0" ':= a]) -> PMaybeData a (s :: S)
PDNothing :: Term s (PDataRecord '[]) -> PMaybeData a (s :: S)
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Builtin.PIsData a, Plutarch.Show.PShow a) => Plutarch.Show.PShow (Plutarch.Api.V1.Maybe.PMaybeData a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Bool.PEq (Plutarch.Api.V1.Maybe.PMaybeData a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Builtin.PIsData (Plutarch.Api.V1.Maybe.PMaybeData a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Api.V1.Maybe.PMaybeData a)
instance forall (a :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Maybe.PMaybeData a s)
instance forall a. Plutarch.DataRepr.Internal.PConstantData a => Plutarch.Lift.PConstantDecl (GHC.Maybe.Maybe a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Api.V1.Maybe.PMaybeData a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData a => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Api.V1.Maybe.PMaybeData a)
instance forall (a :: Plutarch.Internal.PType). Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData a => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.Api.V1.Maybe.PMaybeData a))
instance forall (a :: Plutarch.Internal.PType). Plutarch.DataRepr.Internal.PLiftData a => Plutarch.Lift.PUnsafeLiftDecl (Plutarch.Api.V1.Maybe.PMaybeData a)
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Builtin.PIsData a, Plutarch.Bool.POrd a) => Plutarch.Bool.PPartialOrd (Plutarch.Api.V1.Maybe.PMaybeData a)
instance forall (a :: Plutarch.Internal.PType). (Plutarch.Builtin.PIsData a, Plutarch.Bool.POrd a) => Plutarch.Bool.POrd (Plutarch.Api.V1.Maybe.PMaybeData a)

module Plutarch.Api.V1.Crypto
newtype PPubKeyHash (s :: S)
PPubKeyHash :: Term s PByteString -> PPubKeyHash (s :: S)
newtype PubKey
PubKey :: LedgerBytes -> PubKey
[$sel:getPubKey:PubKey] :: PubKey -> LedgerBytes
pubKeyHash :: PubKey -> PubKeyHash
instance Plutarch.Show.PShow Plutarch.Api.V1.Crypto.PPubKeyHash
instance Plutarch.Bool.POrd Plutarch.Api.V1.Crypto.PPubKeyHash
instance Plutarch.Bool.PPartialOrd Plutarch.Api.V1.Crypto.PPubKeyHash
instance Plutarch.Bool.PEq Plutarch.Api.V1.Crypto.PPubKeyHash
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Crypto.PPubKeyHash
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Crypto.PPubKeyHash
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Crypto.PPubKeyHash s)
instance GHC.Show.Show Plutarch.Api.V1.Crypto.PubKey
instance GHC.Classes.Ord Plutarch.Api.V1.Crypto.PubKey
instance GHC.Classes.Eq Plutarch.Api.V1.Crypto.PubKey
instance forall k1 k2 (f :: k2 -> k1 -> GHC.Types.Type) (a :: k1) (b :: k2). GHC.Generics.Generic (Plutarch.Api.V1.Crypto.Flip @{k2} @{k1} f a b)
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Crypto.PubKeyHash
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.Api.V1.Crypto.PPubKeyHash)
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Crypto.PPubKeyHash
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Crypto.PPubKeyHash

module Plutarch.Api.V1.Address
data PCredential (s :: S)
PPubKeyCredential :: Term s (PDataRecord '["_0" ':= PPubKeyHash]) -> PCredential (s :: S)
PScriptCredential :: Term s (PDataRecord '["_0" ':= PScriptHash]) -> PCredential (s :: S)
data PStakingCredential (s :: S)
PStakingHash :: Term s (PDataRecord '["_0" ':= PCredential]) -> PStakingCredential (s :: S)
PStakingPtr :: Term s (PDataRecord '["_0" ':= PInteger, "_1" ':= PInteger, "_2" ':= PInteger]) -> PStakingCredential (s :: S)
newtype PAddress (s :: S)
PAddress :: Term s (PDataRecord '["credential" ':= PCredential, "stakingCredential" ':= PMaybeData PStakingCredential]) -> PAddress (s :: S)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData Plutarch.Api.V1.Address.PCredential
instance Plutarch.Show.PShow Plutarch.Api.V1.Address.PCredential
instance Plutarch.Bool.POrd Plutarch.Api.V1.Address.PCredential
instance Plutarch.Bool.PPartialOrd Plutarch.Api.V1.Address.PCredential
instance Plutarch.Bool.PEq Plutarch.Api.V1.Address.PCredential
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Address.PCredential
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Address.PCredential
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Address.PCredential s)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData Plutarch.Api.V1.Address.PStakingCredential
instance Plutarch.Show.PShow Plutarch.Api.V1.Address.PStakingCredential
instance Plutarch.Bool.POrd Plutarch.Api.V1.Address.PStakingCredential
instance Plutarch.Bool.PPartialOrd Plutarch.Api.V1.Address.PStakingCredential
instance Plutarch.Bool.PEq Plutarch.Api.V1.Address.PStakingCredential
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Address.PStakingCredential
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Address.PStakingCredential
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Address.PStakingCredential s)
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData Plutarch.Api.V1.Address.PAddress
instance Plutarch.Show.PShow Plutarch.Api.V1.Address.PAddress
instance Plutarch.Bool.POrd Plutarch.Api.V1.Address.PAddress
instance Plutarch.Bool.PPartialOrd Plutarch.Api.V1.Address.PAddress
instance Plutarch.Bool.PEq Plutarch.Api.V1.Address.PAddress
instance Plutarch.DataRepr.Internal.Field.PDataFields Plutarch.Api.V1.Address.PAddress
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Address.PAddress
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Address.PAddress
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Address.PAddress s)
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Credential.Credential
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Credential.StakingCredential
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Address.Address
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Address.PAddress
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Address.PAddress
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.Api.V1.Address.PAddress)
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Address.PStakingCredential
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Address.PStakingCredential
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.Api.V1.Address.PStakingCredential)
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Address.PCredential
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Address.PCredential
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.Api.V1.Address.PCredential)

module Plutarch.Api.V1.DCert
data PDCert (s :: S)
PDCertDelegRegKey :: Term s (PDataRecord '["_0" ':= PStakingCredential]) -> PDCert (s :: S)
PDCertDelegDeRegKey :: Term s (PDataRecord '["_0" ':= PStakingCredential]) -> PDCert (s :: S)
PDCertDelegDelegate :: Term s (PDataRecord '["_0" ':= PStakingCredential, "_1" ':= PPubKeyHash]) -> PDCert (s :: S)
PDCertPoolRegister :: Term s (PDataRecord '["_0" ':= PPubKeyHash, "_1" ':= PPubKeyHash]) -> PDCert (s :: S)
PDCertPoolRetire :: Term s (PDataRecord '["_0" ':= PPubKeyHash, "_1" ':= PInteger]) -> PDCert (s :: S)
PDCertGenesis :: Term s (PDataRecord '[]) -> PDCert (s :: S)
PDCertMir :: Term s (PDataRecord '[]) -> PDCert (s :: S)
instance Plutarch.Show.PShow Plutarch.Api.V1.DCert.PDCert
instance Plutarch.Bool.POrd Plutarch.Api.V1.DCert.PDCert
instance Plutarch.Bool.PPartialOrd Plutarch.Api.V1.DCert.PDCert
instance Plutarch.Bool.PEq Plutarch.Api.V1.DCert.PDCert
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.DCert.PDCert
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.DCert.PDCert
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.DCert.PDCert s)
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.DCert.DCert
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.DCert.PDCert
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.DCert.PDCert

module Plutarch.Api.V1.AssocMap
newtype PMap (keysort :: KeyGuarantees) (k :: PType) (v :: PType) (s :: S)
PMap :: Term s (PBuiltinList (PBuiltinPair (PAsData k) (PAsData v))) -> PMap (keysort :: KeyGuarantees) (k :: PType) (v :: PType) (s :: S)
data KeyGuarantees
Sorted :: KeyGuarantees
Unsorted :: KeyGuarantees

-- | Construct an empty <a>PMap</a>.
pempty :: Term s (PMap 'Sorted k v)

-- | Construct a singleton <a>PMap</a> with the given key and value.
psingleton :: (PIsData k, PIsData v) => Term s (k :--> (v :--> PMap 'Sorted k v))

-- | Construct a singleton <a>PMap</a> with the given data-encoded key and
--   value.
psingletonData :: Term s (PAsData k :--> (PAsData v :--> PMap 'Sorted k v))

-- | Insert a new key/value pair into the map, overriding the previous if
--   any.
pinsert :: (POrd k, PIsData k, PIsData v) => Term s (k :--> (v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v)))

-- | Insert a new data-encoded key/value pair into the map, overriding the
--   previous if any.
pinsertData :: (POrd k, PIsData k) => Term s (PAsData k :--> (PAsData v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v)))

-- | Delete a key from the map.
pdelete :: (POrd k, PIsData k) => Term s (k :--> (PMap 'Sorted k v :--> PMap 'Sorted k v))

-- | Construct a <a>PMap</a> from a list of key-value pairs, sorted by
--   ascending key data.
pfromAscList :: (POrd k, PIsData k, PIsData v) => Term s (PBuiltinListOfPairs k v :--> PMap 'Sorted k v)

-- | Assert the map is properly sorted.
passertSorted :: forall k v any s. (POrd k, PIsData k, PIsData v) => Term s (PMap any k v :--> PMap 'Sorted k v)

-- | Forget the knowledge that keys were sorted.
pforgetSorted :: Term s (PMap 'Sorted k v) -> Term s (PMap g k v)

-- | Look up the given key in a <a>PMap</a>.
plookup :: (PIsData k, PIsData v) => Term s (k :--> (PMap any k v :--> PMaybe v))

-- | Look up the given key data in a <a>PMap</a>.
plookupData :: Term s (PAsData k :--> (PMap any k v :--> PMaybe (PAsData v)))

-- | Look up the given key in a <a>PMap</a>, returning the default value if
--   the key is absent.
pfindWithDefault :: (PIsData k, PIsData v) => Term s (v :--> (k :--> (PMap any k v :--> v)))

-- | Look up the given key in a <a>PMap</a>; return the default if the key
--   is absent or apply the argument function to the value data if present.
pfoldAt :: PIsData k => Term s (k :--> (r :--> ((PAsData v :--> r) :--> (PMap any k v :--> r))))

-- | Tests whether the map is empty.
pnull :: Term s (PMap any k v :--> PBool)

-- | Tests if all values in the map satisfy the given predicate.
pall :: PIsData v => Term s ((v :--> PBool) :--> (PMap any k v :--> PBool))

-- | Tests if anu value in the map satisfies the given predicate.
pany :: PIsData v => Term s ((v :--> PBool) :--> (PMap any k v :--> PBool))

-- | Filters the map so it contains only the values that satisfy the given
--   predicate.
pfilter :: PIsData v => Term s ((v :--> PBool) :--> (PMap g k v :--> PMap g k v))

-- | Applies a function to every value in the map, much like <a>map</a>.
pmap :: (PIsData a, PIsData b) => Term s ((a :--> b) :--> (PMap g k a :--> PMap g k b))
pmapData :: Term s ((PAsData a :--> PAsData b) :--> (PMap g k a :--> PMap g k b))

-- | Maps and filters the map, much like <a>mapMaybe</a>.
pmapMaybe :: (PIsData a, PIsData b) => Term s ((a :--> PMaybe b) :--> (PMap g k a :--> PMap g k b))
pmapMaybeData :: Term s ((PAsData a :--> PMaybe (PAsData b)) :--> (PMap g k a :--> PMap g k b))
type BothPresentHandler k v s = BothPresentHandler_ (->) (Term s k) (Term s v)
data BothPresentHandler_ f k v
DropBoth :: BothPresentHandler_ f k v

-- | True ~ left, False ~ right
PassArg :: Bool -> BothPresentHandler_ f k v
HandleBoth :: (k `f` (v `f` (v `f` v))) -> BothPresentHandler_ f k v
type BothPresentHandlerCommutative k v s = BothPresentHandlerCommutative_ (->) (Term s k) (Term s v)
data BothPresentHandlerCommutative_ f k v
DropBothCommutative :: BothPresentHandlerCommutative_ f k v
HandleBothCommutative :: (k `f` (v `f` (v `f` v))) -> BothPresentHandlerCommutative_ f k v
type OnePresentHandler k v s = OnePresentHandler_ (->) (Term s k) (Term s v)
data OnePresentHandler_ f k v
DropOne :: OnePresentHandler_ f k v
PassOne :: OnePresentHandler_ f k v
HandleOne :: (k `f` (v `f` v)) -> OnePresentHandler_ f k v
type MergeHandler k v s = MergeHandler_ (->) (Term s k) (Term s v)

-- | Signals how to handle value merging for matching keys in
--   <a>pzipWith</a>.
--   
--   No restrictions on commutativity: Safe to use for both commutative and
--   non-commutative merging operations.
data MergeHandler_ f k v
MergeHandler :: BothPresentHandler_ f k v -> OnePresentHandler_ f k v -> OnePresentHandler_ f k v -> MergeHandler_ f k v
[$sel:mhBoth:MergeHandler] :: MergeHandler_ f k v -> BothPresentHandler_ f k v
[$sel:mhLeft:MergeHandler] :: MergeHandler_ f k v -> OnePresentHandler_ f k v
[$sel:mhRight:MergeHandler] :: MergeHandler_ f k v -> OnePresentHandler_ f k v
type MergeHandlerCommutative k v s = MergeHandlerCommutative_ (->) (Term s k) (Term s v)

-- | Signals how to handle value merging for matching keys in
--   <a>pzipWith</a>.
--   
--   Safe to use for commutative merging operations only.
data MergeHandlerCommutative_ f k v
MergeHandlerCommutative :: BothPresentHandlerCommutative_ f k v -> OnePresentHandler_ f k v -> MergeHandlerCommutative_ f k v
[$sel:mhcBoth:MergeHandlerCommutative] :: MergeHandlerCommutative_ f k v -> BothPresentHandlerCommutative_ f k v
[$sel:mhcOne:MergeHandlerCommutative] :: MergeHandlerCommutative_ f k v -> OnePresentHandler_ f k v
type SomeMergeHandler k v s = SomeMergeHandler_ (->) (Term s k) (Term s v)

-- | Signals how to handle value merging for matching keys in
--   <a>pzipWith</a>.
data SomeMergeHandler_ f k v
SomeMergeHandlerCommutative :: MergeHandlerCommutative_ f k v -> SomeMergeHandler_ f k v
SomeMergeHandler :: MergeHandler_ f k v -> SomeMergeHandler_ f k v
data Commutativity
Commutative :: Commutativity
NonCommutative :: Commutativity

-- | Zip two <a>PMap</a>s, using a <a>SomeMergeHandler</a> to decide how to
--   merge based on key presence on the left and right.
--   
--   Note that using a <a>MergeHandlerCommutative</a> is less costly than a
--   <a>MergeHandler</a>.
pzipWith :: forall (s :: S) (k :: PType) (v :: PType). (POrd k, PIsData k, PIsData v) => SomeMergeHandler k v s -> Term s (PMap 'Sorted k v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v))

-- | Zip two <a>PMap</a>s, using a <a>SomeMergeHandler</a> to decide how to
--   merge based on key presence on the left and right.
--   
--   Note that using a <a>MergeHandlerCommutative</a> is less costly than a
--   <a>MergeHandler</a>.
pzipWithData :: forall (s :: S) (k :: PType) (v :: PType). (POrd k, PIsData k) => SomeMergeHandler (PAsData k) (PAsData v) s -> Term s (PMap 'Sorted k v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v))

-- | Zip two <a>PMap</a>s, using the given value merge function for key
--   collisions, the commutativity of the merge function, and a default
--   value that can stand in for both sides.
--   
--   Note that using <a>Commutative</a> is less costly than
--   <a>NonCommutative</a>.
pzipWithDefault :: forall (s :: S) (k :: PType) (v :: PType). (POrd k, PIsData k, PIsData v) => ClosedTerm v -> Commutativity -> Term s ((v :--> (v :--> v)) :--> (PMap 'Sorted k v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v)))

-- | Zip two <a>PMap</a>s, using the given value merge function for key
--   collisions, the commutativity of the merge function, and a default
--   value that can stand in for both sides.
--   
--   Note that using <a>Commutative</a> is less costly than
--   <a>NonCommutative</a>.
pzipWithDataDefault :: forall (s :: S) (k :: PType) (v :: PType). (POrd k, PIsData k) => ClosedTerm (PAsData v) -> Commutativity -> Term s ((PAsData v :--> (PAsData v :--> PAsData v)) :--> (PMap 'Sorted k v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v)))

-- | Zip two <a>PMap</a>s, using the given potentially non-commutative
--   value merge function for key collisions, and different values for the
--   sides.
--   
--   Use <a>pzipWithDefault</a> if your merge function is commutative for
--   better performance.
pzipWithDefaults :: forall (s :: S) (k :: PType) (v :: PType). (POrd k, PIsData k, PIsData v) => ClosedTerm v -> ClosedTerm v -> Term s ((v :--> (v :--> v)) :--> (PMap 'Sorted k v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v)))

-- | Zip two <a>PMap</a>s, using the given potentially non-commutative
--   value merge function for key collisions, and different values for the
--   sides.
--   
--   Use <a>pzipWithDataDefault</a> if your merge function is commutative
--   for better performance.
pzipWithDataDefaults :: forall (s :: S) (k :: PType) (v :: PType). (POrd k, PIsData k) => ClosedTerm (PAsData v) -> ClosedTerm (PAsData v) -> Term s ((PAsData v :--> (PAsData v :--> PAsData v)) :--> (PMap 'Sorted k v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v)))

-- | Build the intersection of two <a>PMap</a>s, merging values that share
--   the same key using the given function.
pintersectionWith :: (POrd k, PIsData k, PIsData v) => Commutativity -> Term s ((v :--> (v :--> v)) :--> (PMap 'Sorted k v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v)))

-- | Build the intersection of two <a>PMap</a>s, merging data-encoded
--   values that share the same key using the given function.
pintersectionWithData :: (POrd k, PIsData k) => Commutativity -> Term s ((PAsData v :--> (PAsData v :--> PAsData v)) :--> (PMap 'Sorted k v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v)))

-- | Build the union of two <a>PMap</a>s. Take the value from the left
--   argument for colliding keys.
--   
--   Prefer this over 'punionResolvingCollisionsWith NonCommutative # plam
--   const'. It performs better.
pleftBiasedUnion :: (POrd k, PIsData k, PIsData v) => Term s (PMap 'Sorted k v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v))

-- | Build the union of two <a>PMap</a>s, merging values that share the
--   same key using the given function.
punionResolvingCollisionsWith :: (POrd k, PIsData k, PIsData v) => Commutativity -> Term s ((v :--> (v :--> v)) :--> (PMap 'Sorted k v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v)))

-- | Build the union of two <a>PMap</a>s, merging values that share the
--   same key using the given function.
punionResolvingCollisionsWithData :: (POrd k, PIsData k) => Commutativity -> Term s ((PAsData v :--> (PAsData v :--> PAsData v)) :--> (PMap 'Sorted k v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v)))

-- | Difference of two maps. Return elements of the first map not existing
--   in the second map.
pdifference :: (PIsData k, POrd k, PIsData v) => Term s (PMap 'Sorted k v :--> (PMap 'Sorted k v :--> PMap 'Sorted k v))

-- | Difference of two maps. Return elements of the first map not existing
--   in the second map. Warning: O(n^2).
punsortedDifference :: PIsData k => Term s (PMap g k a :--> (PMap any k b :--> PMap g k a))

-- | Given a comparison function and a "zero" value, check whether a binary
--   relation holds over 2 sorted <a>PMap</a>s.
--   
--   This is primarily intended to be used with <tt>PValue</tt>.
pcheckBinRel :: forall k v s. (POrd k, PIsData k, PIsData v) => Term s ((v :--> (v :--> PBool)) :--> (v :--> (PMap 'Sorted k v :--> (PMap 'Sorted k v :--> PBool))))
instance forall k1 k2 (f :: k2 -> k1 -> GHC.Types.Type) (a :: k1) (b :: k2). GHC.Generics.Generic (Plutarch.Api.V1.AssocMap.Flip @{k2} @{k1} f a b)
instance forall (keysort :: Plutarch.Api.V1.AssocMap.KeyGuarantees) (k :: Plutarch.Internal.PType) (v :: Plutarch.Internal.PType). (Plutarch.Builtin.PIsData k, Plutarch.Builtin.PIsData v, Plutarch.Show.PShow k, Plutarch.Show.PShow v) => Plutarch.Show.PShow (Plutarch.Api.V1.AssocMap.PMap keysort k v)
instance forall (keysort :: Plutarch.Api.V1.AssocMap.KeyGuarantees) (k :: Plutarch.Internal.PType) (v :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Api.V1.AssocMap.PMap keysort k v)
instance forall (keysort :: Plutarch.Api.V1.AssocMap.KeyGuarantees) (k :: Plutarch.Internal.PType) (v :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.AssocMap.PMap keysort k v s)
instance GHC.Show.Show Plutarch.Api.V1.AssocMap.Commutativity
instance GHC.Classes.Ord Plutarch.Api.V1.AssocMap.Commutativity
instance GHC.Classes.Eq Plutarch.Api.V1.AssocMap.Commutativity
instance forall (f :: GHC.Types.Type -> GHC.Types.Type -> GHC.Types.Type) k v. (forall a b. GHC.Show.Show (f a b)) => GHC.Show.Show (Plutarch.Api.V1.AssocMap.BothPresentHandler_ f k v)
instance forall (f :: GHC.Types.Type -> GHC.Types.Type -> GHC.Types.Type) k v. (forall a b. GHC.Show.Show (f a b)) => GHC.Show.Show (Plutarch.Api.V1.AssocMap.BothPresentHandlerCommutative_ f k v)
instance forall (f :: GHC.Types.Type -> GHC.Types.Type -> GHC.Types.Type) k v. (forall a b. GHC.Show.Show (f a b)) => GHC.Show.Show (Plutarch.Api.V1.AssocMap.OnePresentHandler_ f k v)
instance forall (f :: GHC.Types.Type -> GHC.Types.Type -> GHC.Types.Type) k v. (forall a b. GHC.Show.Show (f a b)) => GHC.Show.Show (Plutarch.Api.V1.AssocMap.MergeHandler_ f k v)
instance forall (f :: GHC.Types.Type -> GHC.Types.Type -> GHC.Types.Type) k v. (forall a b. GHC.Show.Show (f a b)) => GHC.Show.Show (Plutarch.Api.V1.AssocMap.MergeHandlerCommutative_ f k v)
instance forall (f :: GHC.Types.Type -> GHC.Types.Type -> GHC.Types.Type) k v. (forall a b. GHC.Show.Show (f a b)) => GHC.Show.Show (Plutarch.Api.V1.AssocMap.SomeMergeHandler_ f k v)
instance forall (k :: Plutarch.Internal.PType) (v :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). (Plutarch.Bool.POrd k, Plutarch.Builtin.PIsData k, Plutarch.Builtin.PIsData v, GHC.Base.Semigroup (Plutarch.Internal.Term s v)) => GHC.Base.Semigroup (Plutarch.Internal.Term s (Plutarch.Api.V1.AssocMap.PMap 'Plutarch.Api.V1.AssocMap.Sorted k v))
instance forall (k :: Plutarch.Internal.PType) (v :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). (Plutarch.Bool.POrd k, Plutarch.Builtin.PIsData k, Plutarch.Builtin.PIsData v, PlutusTx.Semigroup.Semigroup (Plutarch.Internal.Term s v)) => PlutusTx.Semigroup.Semigroup (Plutarch.Internal.Term s (Plutarch.Api.V1.AssocMap.PMap 'Plutarch.Api.V1.AssocMap.Sorted k v))
instance forall (keysort :: Plutarch.Api.V1.AssocMap.KeyGuarantees) (k :: Plutarch.Internal.PType) (v :: Plutarch.Internal.PType). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Api.V1.AssocMap.PMap keysort k v)
instance forall (keysort :: Plutarch.Api.V1.AssocMap.KeyGuarantees) (k :: Plutarch.Internal.PType) (v :: Plutarch.Internal.PType). Plutarch.Builtin.PIsData (Plutarch.Api.V1.AssocMap.PMap keysort k v)
instance forall (k :: Plutarch.Internal.PType) (v :: Plutarch.Internal.PType). Plutarch.Bool.PEq (Plutarch.Api.V1.AssocMap.PMap 'Plutarch.Api.V1.AssocMap.Sorted k v)
instance forall (k :: Plutarch.Internal.PType) (v :: Plutarch.Internal.PType). (Plutarch.DataRepr.Internal.PLiftData k, Plutarch.DataRepr.Internal.PLiftData v, GHC.Classes.Ord (Plutarch.Lift.PLifted k)) => Plutarch.Lift.PUnsafeLiftDecl (Plutarch.Api.V1.AssocMap.PMap 'Plutarch.Api.V1.AssocMap.Unsorted k v)
instance forall k v. (Plutarch.DataRepr.Internal.PConstantData k, Plutarch.DataRepr.Internal.PConstantData v, GHC.Classes.Ord k) => Plutarch.Lift.PConstantDecl (PlutusTx.AssocMap.Map k v)
instance forall (k :: Plutarch.Internal.PType) (v :: Plutarch.Internal.PType). (Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData k), Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData v)) => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.Api.V1.AssocMap.PMap 'Plutarch.Api.V1.AssocMap.Unsorted k v))
instance forall (k :: Plutarch.Internal.PType) (v :: Plutarch.Internal.PType). (Plutarch.Bool.POrd k, Plutarch.Builtin.PIsData k, Plutarch.Builtin.PIsData v, Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData k), Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData v)) => Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.Api.V1.AssocMap.PMap 'Plutarch.Api.V1.AssocMap.Sorted k v))
instance forall (k :: Plutarch.Internal.PType) (v :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). (Plutarch.Builtin.PIsData k, Plutarch.Builtin.PIsData v, Plutarch.Bool.POrd k) => GHC.IsList.IsList (Plutarch.Internal.Term s (Plutarch.Api.V1.AssocMap.PMap 'Plutarch.Api.V1.AssocMap.Unsorted k v))
instance forall (k :: Plutarch.Internal.PType) (v :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). (Plutarch.Builtin.PIsData k, Plutarch.Builtin.PIsData v, Plutarch.Bool.POrd k) => GHC.IsList.IsList (Plutarch.Internal.Term s (Plutarch.Api.V1.AssocMap.PMap 'Plutarch.Api.V1.AssocMap.Sorted k v))
instance forall (k :: Plutarch.Internal.PType) (v :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). (Plutarch.Bool.POrd k, Plutarch.Builtin.PIsData k, Plutarch.Builtin.PIsData v, forall (s' :: Plutarch.Internal.S). GHC.Base.Monoid (Plutarch.Internal.Term s' v)) => GHC.Base.Monoid (Plutarch.Internal.Term s (Plutarch.Api.V1.AssocMap.PMap 'Plutarch.Api.V1.AssocMap.Sorted k v))
instance forall (k :: Plutarch.Internal.PType) (v :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). (Plutarch.Bool.POrd k, Plutarch.Builtin.PIsData k, Plutarch.Builtin.PIsData v, forall (s' :: Plutarch.Internal.S). PlutusTx.Monoid.Monoid (Plutarch.Internal.Term s' v)) => PlutusTx.Monoid.Monoid (Plutarch.Internal.Term s (Plutarch.Api.V1.AssocMap.PMap 'Plutarch.Api.V1.AssocMap.Sorted k v))
instance forall (k :: Plutarch.Internal.PType) (v :: Plutarch.Internal.PType) (s :: Plutarch.Internal.S). (Plutarch.Bool.POrd k, Plutarch.Builtin.PIsData k, Plutarch.Builtin.PIsData v, forall (s' :: Plutarch.Internal.S). PlutusTx.Monoid.Group (Plutarch.Internal.Term s' v)) => PlutusTx.Monoid.Group (Plutarch.Internal.Term s (Plutarch.Api.V1.AssocMap.PMap 'Plutarch.Api.V1.AssocMap.Sorted k v))


-- | Value-related functionality. In order to keep the interface efficient
--   and safe at the same time, there is a type-level distinction between
--   <a>PValue</a>s that are guaranteed to be properly normalized and those
--   that provide no such guarantee.
--   
--   Also for efficiency reasons, the Ada-specific functions assume that
--   there can be only one token name for the Ada currency symbol, and they
--   don't check whether it matches <a>adaToken</a>.
module Plutarch.Api.V1.Value
newtype PValue (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S)
PValue :: Term s (PMap keys PCurrencySymbol (PMap keys PTokenName PInteger)) -> PValue (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S)
newtype PCurrencySymbol (s :: S)
PCurrencySymbol :: Term s PByteString -> PCurrencySymbol (s :: S)
newtype PTokenName (s :: S)
PTokenName :: Term s PByteString -> PTokenName (s :: S)
data KeyGuarantees
Sorted :: KeyGuarantees
Unsorted :: KeyGuarantees
data AmountGuarantees
NoGuarantees :: AmountGuarantees
NonZero :: AmountGuarantees
Positive :: AmountGuarantees

-- | Assert the value is properly sorted and normalized.
passertSorted :: Term s (PValue anyKey anyAmount :--> PValue 'Sorted 'NonZero)

-- | Assert all amounts in the value are positive.
passertPositive :: forall kg ag s. Term s (PValue kg ag :--> PValue kg 'Positive)

-- | Forget the knowledge of value's positivity.
pforgetPositive :: Term s (PValue k 'Positive) -> Term s (PValue k a)

-- | Forget the knowledge of all value's guarantees.
pforgetSorted :: Term s (PValue 'Sorted a) -> Term s (PValue k a)

-- | Normalize the argument to contain no zero quantity nor empty token
--   map.
pnormalize :: Term s (PValue 'Sorted any :--> PValue 'Sorted 'NonZero)

-- | Construct a singleton <a>PValue</a> containing only the given quantity
--   of the given currency.
psingleton :: Term s (PCurrencySymbol :--> (PTokenName :--> (PInteger :--> PValue 'Sorted 'NonZero)))

-- | Construct a singleton <a>PValue</a> containing only the given quantity
--   of the given currency, taking data-encoded parameters.
psingletonData :: Term s (PAsData PCurrencySymbol :--> (PAsData PTokenName :--> (PAsData PInteger :--> PValue 'Sorted 'NonZero)))

-- | Construct a constant singleton <a>PValue</a> containing only the given
--   quantity of the given currency.
pconstantSingleton :: ClosedTerm PCurrencySymbol -> ClosedTerm PTokenName -> ClosedTerm PInteger -> ClosedTerm (PValue 'Sorted 'NonZero)

-- | Construct a constant singleton <a>PValue</a> containing only the given
--   positive quantity of the given currency.
pconstantPositiveSingleton :: ClosedTerm PCurrencySymbol -> ClosedTerm PTokenName -> ClosedTerm PInteger -> ClosedTerm (PValue 'Sorted 'Positive)

-- | Combine two <a>PValue</a>s, taking the tokens from the left only, if a
--   currency occurs on both sides.
pleftBiasedCurrencyUnion :: Term s (PValue 'Sorted any0 :--> (PValue 'Sorted any1 :--> PValue 'Sorted 'NoGuarantees))

-- | Combine two <a>PValue</a>s, taking the tokens from the left only, if a
--   token name of the same currency occurs on both sides.
--   
--   Prefer this over 'punionResolvingCollisionsWith NonCommutative # plam
--   const'. It is equivalent, but performs better.
pleftBiasedTokenUnion :: Term s (PValue 'Sorted any0 :--> (PValue 'Sorted any1 :--> PValue 'Sorted 'NoGuarantees))

-- | Combine two <a>PValue</a>s applying the given function to any pair of
--   quantities with the same asset class. Note that the result is _not_
--   <tt>normalize</tt>d and may contain zero quantities.
punionResolvingCollisionsWith :: Commutativity -> Term s ((PInteger :--> (PInteger :--> PInteger)) :--> (PValue 'Sorted any0 :--> (PValue 'Sorted any1 :--> PValue 'Sorted 'NoGuarantees)))

-- | Combine two <a>PValue</a>s applying the given function to any pair of
--   data-encoded quantities with the same asset class. Note that the
--   result is _not_ <tt>normalize</tt>d and may contain zero quantities.
punionResolvingCollisionsWithData :: Commutativity -> Term s ((PAsData PInteger :--> (PAsData PInteger :--> PAsData PInteger)) :--> (PValue 'Sorted any0 :--> (PValue 'Sorted any1 :--> PValue 'Sorted 'NoGuarantees)))

-- | Given an amount comparison function, check whether a binary relation
--   holds over 2 sorted <a>PValue</a>s.
pcheckBinRel :: Term s ((PInteger :--> (PInteger :--> PBool)) :--> (PValue 'Sorted any0 :--> (PValue 'Sorted any1 :--> PBool)))

-- | Get the quantity of the given currency in the <a>PValue</a>.
pvalueOf :: Term s (PValue anyKey anyAmount :--> (PCurrencySymbol :--> (PTokenName :--> PInteger)))

-- | The amount of Lovelace in value
plovelaceValueOf :: Term s (PValue 'Sorted v :--> PInteger)

-- | The <a>PCurrencySymbol</a> of the Ada currency.
padaSymbol :: Term s PCurrencySymbol

-- | Data-encoded <a>PCurrencySymbol</a> of the Ada currency.
padaSymbolData :: Term s (PAsData PCurrencySymbol)

-- | The <a>PTokenName</a> of the Ada currency.
padaToken :: Term s PTokenName

-- | Data-encoded <a>PTokenName</a> of the Ada currency.
padaTokenData :: Term s (PAsData PTokenName)

-- | Test if the value contains nothing but Ada
pisAdaOnlyValue :: Term s (PValue 'Sorted 'Positive :--> PBool)

-- | Value without any non-Ada
padaOnlyValue :: Term s (PValue 'Sorted v :--> PValue 'Sorted v)

-- | Value without any Ada
pnoAdaValue :: Term s (PValue 'Sorted v :--> PValue 'Sorted v)
instance forall k1 k2 (f :: k2 -> k1 -> GHC.Types.Type) (a :: k1) (b :: k2). GHC.Generics.Generic (Plutarch.Api.V1.Value.Flip @{k2} @{k1} f a b)
instance Plutarch.Show.PShow Plutarch.Api.V1.Value.PTokenName
instance Plutarch.Bool.POrd Plutarch.Api.V1.Value.PTokenName
instance Plutarch.Bool.PPartialOrd Plutarch.Api.V1.Value.PTokenName
instance Plutarch.Bool.PEq Plutarch.Api.V1.Value.PTokenName
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Value.PTokenName
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Value.PTokenName
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Value.PTokenName s)
instance Plutarch.Show.PShow Plutarch.Api.V1.Value.PCurrencySymbol
instance Plutarch.Bool.POrd Plutarch.Api.V1.Value.PCurrencySymbol
instance Plutarch.Bool.PPartialOrd Plutarch.Api.V1.Value.PCurrencySymbol
instance Plutarch.Bool.PEq Plutarch.Api.V1.Value.PCurrencySymbol
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Value.PCurrencySymbol
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Value.PCurrencySymbol
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Value.PCurrencySymbol s)
instance forall (keys :: Plutarch.Api.V1.AssocMap.KeyGuarantees) (amounts :: Plutarch.Api.V1.Value.AmountGuarantees). Plutarch.Show.PShow (Plutarch.Api.V1.Value.PValue keys amounts)
instance forall (keys :: Plutarch.Api.V1.AssocMap.KeyGuarantees) (amounts :: Plutarch.Api.V1.Value.AmountGuarantees). Plutarch.Builtin.PIsData (Plutarch.Api.V1.Value.PValue keys amounts)
instance forall (keys :: Plutarch.Api.V1.AssocMap.KeyGuarantees) (amounts :: Plutarch.Api.V1.Value.AmountGuarantees). Plutarch.Internal.PlutusType.PlutusType (Plutarch.Api.V1.Value.PValue keys amounts)
instance forall (keys :: Plutarch.Api.V1.AssocMap.KeyGuarantees) (amounts :: Plutarch.Api.V1.Value.AmountGuarantees) (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Value.PValue keys amounts s)
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Value.TokenName
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Value.CurrencySymbol
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Value.Value
instance forall (keys :: Plutarch.Api.V1.AssocMap.KeyGuarantees) (amounts :: Plutarch.Api.V1.Value.AmountGuarantees). Plutarch.Internal.PlutusType.DerivePlutusType (Plutarch.Api.V1.Value.PValue keys amounts)
instance Plutarch.Lift.PUnsafeLiftDecl (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Unsorted 'Plutarch.Api.V1.Value.NonZero)
instance Plutarch.Bool.PEq (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted 'Plutarch.Api.V1.Value.Positive)
instance Plutarch.Bool.PEq (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted 'Plutarch.Api.V1.Value.NonZero)
instance Plutarch.Bool.PPartialOrd (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted 'Plutarch.Api.V1.Value.Positive)
instance Plutarch.Bool.PPartialOrd (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted 'Plutarch.Api.V1.Value.NonZero)
instance Plutarch.Bool.PEq (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted 'Plutarch.Api.V1.Value.NoGuarantees)
instance forall (s :: Plutarch.Internal.S). GHC.Base.Semigroup (Plutarch.Internal.Term s (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted 'Plutarch.Api.V1.Value.Positive))
instance forall (s :: Plutarch.Internal.S). PlutusTx.Semigroup.Semigroup (Plutarch.Internal.Term s (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted 'Plutarch.Api.V1.Value.Positive))
instance forall (s :: Plutarch.Internal.S). GHC.Base.Semigroup (Plutarch.Internal.Term s (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted 'Plutarch.Api.V1.Value.NonZero))
instance forall (s :: Plutarch.Internal.S). PlutusTx.Semigroup.Semigroup (Plutarch.Internal.Term s (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted 'Plutarch.Api.V1.Value.NonZero))
instance forall (s :: Plutarch.Internal.S). GHC.Base.Semigroup (Plutarch.Internal.Term s (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted 'Plutarch.Api.V1.Value.NoGuarantees))
instance forall (s :: Plutarch.Internal.S). PlutusTx.Semigroup.Semigroup (Plutarch.Internal.Term s (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted 'Plutarch.Api.V1.Value.NoGuarantees))
instance forall (s :: Plutarch.Internal.S) (normalization :: Plutarch.Api.V1.Value.AmountGuarantees). GHC.Base.Semigroup (Plutarch.Internal.Term s (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted normalization)) => GHC.Base.Monoid (Plutarch.Internal.Term s (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted normalization))
instance forall (s :: Plutarch.Internal.S) (normalization :: Plutarch.Api.V1.Value.AmountGuarantees). PlutusTx.Semigroup.Semigroup (Plutarch.Internal.Term s (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted normalization)) => PlutusTx.Monoid.Monoid (Plutarch.Internal.Term s (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted normalization))
instance forall (s :: Plutarch.Internal.S). PlutusTx.Semigroup.Semigroup (Plutarch.Internal.Term s (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted 'Plutarch.Api.V1.Value.NoGuarantees)) => PlutusTx.Monoid.Group (Plutarch.Internal.Term s (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted 'Plutarch.Api.V1.Value.NoGuarantees))
instance forall (s :: Plutarch.Internal.S). PlutusTx.Semigroup.Semigroup (Plutarch.Internal.Term s (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted 'Plutarch.Api.V1.Value.NonZero)) => PlutusTx.Monoid.Group (Plutarch.Internal.Term s (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted 'Plutarch.Api.V1.Value.NonZero))
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Unsorted 'Plutarch.Api.V1.Value.NoGuarantees))
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted 'Plutarch.Api.V1.Value.NoGuarantees))
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted 'Plutarch.Api.V1.Value.Positive))
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Unsorted 'Plutarch.Api.V1.Value.Positive))
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Sorted 'Plutarch.Api.V1.Value.NonZero))
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData (Plutarch.Api.V1.Value.PValue 'Plutarch.Api.V1.AssocMap.Unsorted 'Plutarch.Api.V1.Value.NonZero))
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Value.PCurrencySymbol
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.Api.V1.Value.PCurrencySymbol)
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Value.PCurrencySymbol
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Value.PTokenName
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Value.PTokenName
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.Api.V1.Value.PTokenName)

module Plutarch.Api.V1.Tx

-- | Reference to a transaction output with a index referencing which of
--   the outputs is being referred to.
newtype PTxOutRef (s :: S)
PTxOutRef :: Term s (PDataRecord '["id" ':= PTxId, "idx" ':= PInteger]) -> PTxOutRef (s :: S)

-- | A transaction output. This consists of a target address, value and
--   maybe a datum hash
newtype PTxOut (s :: S)
PTxOut :: Term s (PDataRecord '["address" ':= PAddress, "value" ':= PValue 'Sorted 'Positive, "datumHash" ':= PMaybeData PDatumHash]) -> PTxOut (s :: S)
newtype PTxId (s :: S)
PTxId :: Term s (PDataRecord '["_0" ':= PByteString]) -> PTxId (s :: S)

-- | A input of the pending transaction.
newtype PTxInInfo (s :: S)
PTxInInfo :: Term s (PDataRecord '["outRef" ':= PTxOutRef, "resolved" ':= PTxOut]) -> PTxInInfo (s :: S)
instance forall k1 k2 (f :: k2 -> k1 -> GHC.Types.Type) (a :: k1) (b :: k2). GHC.Generics.Generic (Plutarch.Api.V1.Tx.Flip @{k2} @{k1} f a b)
instance Plutarch.Show.PShow Plutarch.Api.V1.Tx.PTxId
instance Plutarch.Bool.POrd Plutarch.Api.V1.Tx.PTxId
instance Plutarch.Bool.PPartialOrd Plutarch.Api.V1.Tx.PTxId
instance Plutarch.Bool.PEq Plutarch.Api.V1.Tx.PTxId
instance Plutarch.DataRepr.Internal.Field.PDataFields Plutarch.Api.V1.Tx.PTxId
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Tx.PTxId
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Tx.PTxId
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Tx.PTxId s)
instance Plutarch.Show.PShow Plutarch.Api.V1.Tx.PTxOutRef
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData Plutarch.Api.V1.Tx.PTxOutRef
instance Plutarch.Bool.POrd Plutarch.Api.V1.Tx.PTxOutRef
instance Plutarch.Bool.PPartialOrd Plutarch.Api.V1.Tx.PTxOutRef
instance Plutarch.Bool.PEq Plutarch.Api.V1.Tx.PTxOutRef
instance Plutarch.DataRepr.Internal.Field.PDataFields Plutarch.Api.V1.Tx.PTxOutRef
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Tx.PTxOutRef
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Tx.PTxOutRef
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Tx.PTxOutRef s)
instance Plutarch.Show.PShow Plutarch.Api.V1.Tx.PTxOut
instance Plutarch.Bool.PEq Plutarch.Api.V1.Tx.PTxOut
instance Plutarch.DataRepr.Internal.Field.PDataFields Plutarch.Api.V1.Tx.PTxOut
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Tx.PTxOut
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Tx.PTxOut
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Tx.PTxOut s)
instance Plutarch.Show.PShow Plutarch.Api.V1.Tx.PTxInInfo
instance Plutarch.Bool.PEq Plutarch.Api.V1.Tx.PTxInInfo
instance Plutarch.DataRepr.Internal.Field.PDataFields Plutarch.Api.V1.Tx.PTxInInfo
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Tx.PTxInInfo
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Tx.PTxInInfo
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Tx.PTxInInfo s)
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Tx.TxId
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Tx.TxOutRef
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Contexts.TxInInfo
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Tx.TxOut
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Tx.PTxInInfo
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Tx.PTxInInfo
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Tx.PTxOut
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Tx.PTxOut
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Tx.PTxOutRef
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Tx.PTxOutRef
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.Api.V1.Tx.PTxOutRef)
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Tx.PTxId
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Tx.PTxId
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData Plutarch.Api.V1.Tx.PTxId
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.Api.V1.Tx.PTxId)

module Plutarch.Api.V2.Tx

-- | Reference to a transaction output with a index referencing which of
--   the outputs is being referred to.
newtype PTxOutRef (s :: S)
PTxOutRef :: Term s (PDataRecord '["id" ':= PTxId, "idx" ':= PInteger]) -> PTxOutRef (s :: S)

-- | A transaction output. This consists of a target address, value and
--   maybe a datum hash
newtype PTxOut (s :: S)
PTxOut :: Term s (PDataRecord '["address" ':= PAddress, "value" ':= PValue 'Sorted 'Positive, "datum" ':= POutputDatum, "referenceScript" ':= PMaybeData PScriptHash]) -> PTxOut (s :: S)
newtype PTxId (s :: S)
PTxId :: Term s (PDataRecord '["_0" ':= PByteString]) -> PTxId (s :: S)

-- | A input of the pending transaction.
newtype PTxInInfo (s :: S)
PTxInInfo :: Term s (PDataRecord '["outRef" ':= PTxOutRef, "resolved" ':= PTxOut]) -> PTxInInfo (s :: S)

-- | The datum attached to an output: either nothing, a datum hash or an
--   inline datum (CIP 32)
data POutputDatum (s :: S)
PNoOutputDatum :: Term s (PDataRecord '[]) -> POutputDatum (s :: S)
POutputDatumHash :: Term s (PDataRecord '["datumHash" ':= PDatumHash]) -> POutputDatum (s :: S)
POutputDatum :: Term s (PDataRecord '["outputDatum" ':= PDatum]) -> POutputDatum (s :: S)
instance Plutarch.Show.PShow Plutarch.Api.V2.Tx.POutputDatum
instance Plutarch.Bool.PEq Plutarch.Api.V2.Tx.POutputDatum
instance Plutarch.Builtin.PIsData Plutarch.Api.V2.Tx.POutputDatum
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V2.Tx.POutputDatum
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V2.Tx.POutputDatum s)
instance Plutarch.Show.PShow Plutarch.Api.V2.Tx.PTxOut
instance Plutarch.Bool.PEq Plutarch.Api.V2.Tx.PTxOut
instance Plutarch.DataRepr.Internal.Field.PDataFields Plutarch.Api.V2.Tx.PTxOut
instance Plutarch.Builtin.PIsData Plutarch.Api.V2.Tx.PTxOut
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V2.Tx.PTxOut
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V2.Tx.PTxOut s)
instance Plutarch.Show.PShow Plutarch.Api.V2.Tx.PTxInInfo
instance Plutarch.Bool.PEq Plutarch.Api.V2.Tx.PTxInInfo
instance Plutarch.DataRepr.Internal.Field.PDataFields Plutarch.Api.V2.Tx.PTxInInfo
instance Plutarch.Builtin.PIsData Plutarch.Api.V2.Tx.PTxInInfo
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V2.Tx.PTxInInfo
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V2.Tx.PTxInInfo s)
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V2.Tx.TxOut
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V2.Contexts.TxInInfo
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V2.Tx.OutputDatum
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V2.Tx.PTxInInfo
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V2.Tx.PTxInInfo
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V2.Tx.PTxOut
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V2.Tx.PTxOut
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V2.Tx.POutputDatum
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V2.Tx.POutputDatum

module Plutarch.Api.V1.Contexts
type PTuple a b = PDataSum '[ '["_0" ':= a, "_1" ':= b]]

-- | Script context consists of the script purpose and the pending
--   transaction info.
newtype PScriptContext (s :: S)
PScriptContext :: Term s (PDataRecord '["txInfo" ':= PTxInfo, "purpose" ':= PScriptPurpose]) -> PScriptContext (s :: S)

-- | A pending transaction. This is the view as seen by the validator
--   script.
newtype PTxInfo (s :: S)
PTxInfo :: Term s (PDataRecord '["inputs" ':= PBuiltinList PTxInInfo, "outputs" ':= PBuiltinList PTxOut, "fee" ':= PValue 'Sorted 'Positive, "mint" ':= PValue 'Sorted 'NoGuarantees, "dcert" ':= PBuiltinList PDCert, "wdrl" ':= PBuiltinList (PAsData (PTuple PStakingCredential PInteger)), "validRange" ':= PPOSIXTimeRange, "signatories" ':= PBuiltinList (PAsData PPubKeyHash), "datums" ':= PBuiltinList (PAsData (PTuple PDatumHash PDatum)), "id" ':= PTxId]) -> PTxInfo (s :: S)

-- | The purpose of the script that is currently running
data PScriptPurpose (s :: S)
PMinting :: Term s (PDataRecord '["_0" ':= PCurrencySymbol]) -> PScriptPurpose (s :: S)
PSpending :: Term s (PDataRecord '["_0" ':= PTxOutRef]) -> PScriptPurpose (s :: S)
PRewarding :: Term s (PDataRecord '["_0" ':= PStakingCredential]) -> PScriptPurpose (s :: S)
PCertifying :: Term s (PDataRecord '["_0" ':= PDCert]) -> PScriptPurpose (s :: S)
instance Plutarch.Show.PShow Plutarch.Api.V1.Contexts.PTxInfo
instance Plutarch.Bool.PEq Plutarch.Api.V1.Contexts.PTxInfo
instance Plutarch.DataRepr.Internal.Field.PDataFields Plutarch.Api.V1.Contexts.PTxInfo
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Contexts.PTxInfo
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Contexts.PTxInfo
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Contexts.PTxInfo s)
instance Plutarch.Show.PShow Plutarch.Api.V1.Contexts.PScriptPurpose
instance Plutarch.Bool.PEq Plutarch.Api.V1.Contexts.PScriptPurpose
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Contexts.PScriptPurpose
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Contexts.PScriptPurpose
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Contexts.PScriptPurpose s)
instance Plutarch.Show.PShow Plutarch.Api.V1.Contexts.PScriptContext
instance Plutarch.Bool.PEq Plutarch.Api.V1.Contexts.PScriptContext
instance Plutarch.DataRepr.Internal.Field.PDataFields Plutarch.Api.V1.Contexts.PScriptContext
instance Plutarch.Builtin.PIsData Plutarch.Api.V1.Contexts.PScriptContext
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V1.Contexts.PScriptContext
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V1.Contexts.PScriptContext s)
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Contexts.TxInfo
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Contexts.ScriptContext
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V1.Contexts.ScriptPurpose
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Contexts.PScriptContext
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Contexts.PScriptContext
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Contexts.PScriptPurpose
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Contexts.PScriptPurpose
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V1.Contexts.PTxInfo
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V1.Contexts.PTxInfo

module Plutarch.Api.V1

-- | Script context consists of the script purpose and the pending
--   transaction info.
newtype PScriptContext (s :: S)
PScriptContext :: Term s (PDataRecord '["txInfo" ':= PTxInfo, "purpose" ':= PScriptPurpose]) -> PScriptContext (s :: S)

-- | A pending transaction. This is the view as seen by the validator
--   script.
newtype PTxInfo (s :: S)
PTxInfo :: Term s (PDataRecord '["inputs" ':= PBuiltinList PTxInInfo, "outputs" ':= PBuiltinList PTxOut, "fee" ':= PValue 'Sorted 'Positive, "mint" ':= PValue 'Sorted 'NoGuarantees, "dcert" ':= PBuiltinList PDCert, "wdrl" ':= PBuiltinList (PAsData (PTuple PStakingCredential PInteger)), "validRange" ':= PPOSIXTimeRange, "signatories" ':= PBuiltinList (PAsData PPubKeyHash), "datums" ':= PBuiltinList (PAsData (PTuple PDatumHash PDatum)), "id" ':= PTxId]) -> PTxInfo (s :: S)

-- | The purpose of the script that is currently running
data PScriptPurpose (s :: S)
PMinting :: Term s (PDataRecord '["_0" ':= PCurrencySymbol]) -> PScriptPurpose (s :: S)
PSpending :: Term s (PDataRecord '["_0" ':= PTxOutRef]) -> PScriptPurpose (s :: S)
PRewarding :: Term s (PDataRecord '["_0" ':= PStakingCredential]) -> PScriptPurpose (s :: S)
PCertifying :: Term s (PDataRecord '["_0" ':= PDCert]) -> PScriptPurpose (s :: S)
newtype PDatum (s :: S)
PDatum :: Term s PData -> PDatum (s :: S)
newtype PDatumHash (s :: S)
PDatumHash :: Term s PByteString -> PDatumHash (s :: S)
newtype PRedeemer (s :: S)
PRedeemer :: Term s PData -> PRedeemer (s :: S)
newtype PRedeemerHash (s :: S)
PRedeemerHash :: Term s PByteString -> PRedeemerHash (s :: S)

-- | Hash a Script, with the correct prefix for Plutus V1
scriptHash :: Script -> ScriptHash

-- | Hash a Datum.
datumHash :: Datum -> DatumHash

-- | Hash a Redeemer.
redeemerHash :: Redeemer -> RedeemerHash

-- | Hash the data encoded representation of given argument.
dataHash :: ToData a => a -> BuiltinByteString

-- | a Validator Term
type PValidator = PData :--> PData :--> PScriptContext :--> POpaque

-- | a StakeValidator Term
type PStakeValidator = PData :--> PScriptContext :--> POpaque

-- | a MintingPolicy Term
type PMintingPolicy = PData :--> PScriptContext :--> POpaque
newtype PValue (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S)
PValue :: Term s (PMap keys PCurrencySymbol (PMap keys PTokenName PInteger)) -> PValue (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S)
newtype PCurrencySymbol (s :: S)
PCurrencySymbol :: Term s PByteString -> PCurrencySymbol (s :: S)
newtype PTokenName (s :: S)
PTokenName :: Term s PByteString -> PTokenName (s :: S)
data KeyGuarantees
Sorted :: KeyGuarantees
Unsorted :: KeyGuarantees
data AmountGuarantees
NoGuarantees :: AmountGuarantees
NonZero :: AmountGuarantees
Positive :: AmountGuarantees
newtype PPubKeyHash (s :: S)
PPubKeyHash :: Term s PByteString -> PPubKeyHash (s :: S)
pubKeyHash :: PubKey -> PubKeyHash
data PDCert (s :: S)
PDCertDelegRegKey :: Term s (PDataRecord '["_0" ':= PStakingCredential]) -> PDCert (s :: S)
PDCertDelegDeRegKey :: Term s (PDataRecord '["_0" ':= PStakingCredential]) -> PDCert (s :: S)
PDCertDelegDelegate :: Term s (PDataRecord '["_0" ':= PStakingCredential, "_1" ':= PPubKeyHash]) -> PDCert (s :: S)
PDCertPoolRegister :: Term s (PDataRecord '["_0" ':= PPubKeyHash, "_1" ':= PPubKeyHash]) -> PDCert (s :: S)
PDCertPoolRetire :: Term s (PDataRecord '["_0" ':= PPubKeyHash, "_1" ':= PInteger]) -> PDCert (s :: S)
PDCertGenesis :: Term s (PDataRecord '[]) -> PDCert (s :: S)
PDCertMir :: Term s (PDataRecord '[]) -> PDCert (s :: S)
data PPOSIXTime (s :: S)
type PPOSIXTimeRange = PInterval PPOSIXTime
newtype PInterval a (s :: S)
PInterval :: Term s (PDataRecord '["from" ':= PLowerBound a, "to" ':= PUpperBound a]) -> PInterval a (s :: S)
newtype PLowerBound a (s :: S)
PLowerBound :: Term s (PDataRecord '["_0" ':= PExtended a, "_1" ':= PClosure]) -> PLowerBound a (s :: S)
newtype PUpperBound a (s :: S)
PUpperBound :: Term s (PDataRecord '["_0" ':= PExtended a, "_1" ':= PClosure]) -> PUpperBound a (s :: S)
data PExtended a (s :: S)
PNegInf :: Term s (PDataRecord '[]) -> PExtended a (s :: S)
PFinite :: Term s (PDataRecord '["_0" ':= a]) -> PExtended a (s :: S)
PPosInf :: Term s (PDataRecord '[]) -> PExtended a (s :: S)
type PClosure = PBool
data PCredential (s :: S)
PPubKeyCredential :: Term s (PDataRecord '["_0" ':= PPubKeyHash]) -> PCredential (s :: S)
PScriptCredential :: Term s (PDataRecord '["_0" ':= PScriptHash]) -> PCredential (s :: S)
data PStakingCredential (s :: S)
PStakingHash :: Term s (PDataRecord '["_0" ':= PCredential]) -> PStakingCredential (s :: S)
PStakingPtr :: Term s (PDataRecord '["_0" ':= PInteger, "_1" ':= PInteger, "_2" ':= PInteger]) -> PStakingCredential (s :: S)
newtype PAddress (s :: S)
PAddress :: Term s (PDataRecord '["credential" ':= PCredential, "stakingCredential" ':= PMaybeData PStakingCredential]) -> PAddress (s :: S)

-- | Reference to a transaction output with a index referencing which of
--   the outputs is being referred to.
newtype PTxOutRef (s :: S)
PTxOutRef :: Term s (PDataRecord '["id" ':= PTxId, "idx" ':= PInteger]) -> PTxOutRef (s :: S)

-- | A transaction output. This consists of a target address, value and
--   maybe a datum hash
newtype PTxOut (s :: S)
PTxOut :: Term s (PDataRecord '["address" ':= PAddress, "value" ':= PValue 'Sorted 'Positive, "datumHash" ':= PMaybeData PDatumHash]) -> PTxOut (s :: S)
newtype PTxId (s :: S)
PTxId :: Term s (PDataRecord '["_0" ':= PByteString]) -> PTxId (s :: S)

-- | A input of the pending transaction.
newtype PTxInInfo (s :: S)
PTxInInfo :: Term s (PDataRecord '["outRef" ':= PTxOutRef, "resolved" ':= PTxOut]) -> PTxInInfo (s :: S)
newtype PMap (keysort :: KeyGuarantees) (k :: PType) (v :: PType) (s :: S)
PMap :: Term s (PBuiltinList (PBuiltinPair (PAsData k) (PAsData v))) -> PMap (keysort :: KeyGuarantees) (k :: PType) (v :: PType) (s :: S)

-- | Data encoded Maybe type. Used in various ledger api types.
data PMaybeData a (s :: S)
PDJust :: Term s (PDataRecord '["_0" ':= a]) -> PMaybeData a (s :: S)
PDNothing :: Term s (PDataRecord '[]) -> PMaybeData a (s :: S)
type PTuple a b = PDataSum '[ '["_0" ':= a, "_1" ':= b]]
ptuple :: Term s (PAsData a :--> (PAsData b :--> PTuple a b))

module Plutarch.Api.V2.Contexts

-- | Script context consists of the script purpose and the pending
--   transaction info.
newtype PScriptContext (s :: S)
PScriptContext :: Term s (PDataRecord '["txInfo" ':= PTxInfo, "purpose" ':= PScriptPurpose]) -> PScriptContext (s :: S)

-- | A pending transaction. This is the view as seen by the validator
--   script.
newtype PTxInfo (s :: S)
PTxInfo :: Term s (PDataRecord '["inputs" ':= PBuiltinList PTxInInfo, "referenceInputs" ':= PBuiltinList PTxInInfo, "outputs" ':= PBuiltinList PTxOut, "fee" ':= PValue 'Sorted 'Positive, "mint" ':= PValue 'Sorted 'NoGuarantees, "dcert" ':= PBuiltinList PDCert, "wdrl" ':= PMap 'Unsorted PStakingCredential PInteger, "validRange" ':= PPOSIXTimeRange, "signatories" ':= PBuiltinList (PAsData PPubKeyHash), "redeemers" ':= PMap 'Unsorted PScriptPurpose PRedeemer, "datums" ':= PMap 'Unsorted PDatumHash PDatum, "id" ':= PTxId]) -> PTxInfo (s :: S)

-- | The purpose of the script that is currently running
data PScriptPurpose (s :: S)
PMinting :: Term s (PDataRecord '["_0" ':= PCurrencySymbol]) -> PScriptPurpose (s :: S)
PSpending :: Term s (PDataRecord '["_0" ':= PTxOutRef]) -> PScriptPurpose (s :: S)
PRewarding :: Term s (PDataRecord '["_0" ':= PStakingCredential]) -> PScriptPurpose (s :: S)
PCertifying :: Term s (PDataRecord '["_0" ':= PDCert]) -> PScriptPurpose (s :: S)
instance Plutarch.Show.PShow Plutarch.Api.V2.Contexts.PTxInfo
instance Plutarch.Bool.PEq Plutarch.Api.V2.Contexts.PTxInfo
instance Plutarch.DataRepr.Internal.Field.PDataFields Plutarch.Api.V2.Contexts.PTxInfo
instance Plutarch.Builtin.PIsData Plutarch.Api.V2.Contexts.PTxInfo
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V2.Contexts.PTxInfo
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V2.Contexts.PTxInfo s)
instance Plutarch.Show.PShow Plutarch.Api.V2.Contexts.PScriptContext
instance Plutarch.Bool.PEq Plutarch.Api.V2.Contexts.PScriptContext
instance Plutarch.DataRepr.Internal.Field.PDataFields Plutarch.Api.V2.Contexts.PScriptContext
instance Plutarch.Builtin.PIsData Plutarch.Api.V2.Contexts.PScriptContext
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Api.V2.Contexts.PScriptContext
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Api.V2.Contexts.PScriptContext s)
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V2.Contexts.ScriptContext
instance Plutarch.Lift.PConstantDecl PlutusLedgerApi.V2.Contexts.TxInfo
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V2.Contexts.PScriptContext
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V2.Contexts.PScriptContext
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Api.V2.Contexts.PTxInfo
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Api.V2.Contexts.PTxInfo

module Plutarch.Api.V2

-- | Script context consists of the script purpose and the pending
--   transaction info.
newtype PScriptContext (s :: S)
PScriptContext :: Term s (PDataRecord '["txInfo" ':= PTxInfo, "purpose" ':= PScriptPurpose]) -> PScriptContext (s :: S)

-- | A pending transaction. This is the view as seen by the validator
--   script.
newtype PTxInfo (s :: S)
PTxInfo :: Term s (PDataRecord '["inputs" ':= PBuiltinList PTxInInfo, "referenceInputs" ':= PBuiltinList PTxInInfo, "outputs" ':= PBuiltinList PTxOut, "fee" ':= PValue 'Sorted 'Positive, "mint" ':= PValue 'Sorted 'NoGuarantees, "dcert" ':= PBuiltinList PDCert, "wdrl" ':= PMap 'Unsorted PStakingCredential PInteger, "validRange" ':= PPOSIXTimeRange, "signatories" ':= PBuiltinList (PAsData PPubKeyHash), "redeemers" ':= PMap 'Unsorted PScriptPurpose PRedeemer, "datums" ':= PMap 'Unsorted PDatumHash PDatum, "id" ':= PTxId]) -> PTxInfo (s :: S)

-- | The purpose of the script that is currently running
data PScriptPurpose (s :: S)
PMinting :: Term s (PDataRecord '["_0" ':= PCurrencySymbol]) -> PScriptPurpose (s :: S)
PSpending :: Term s (PDataRecord '["_0" ':= PTxOutRef]) -> PScriptPurpose (s :: S)
PRewarding :: Term s (PDataRecord '["_0" ':= PStakingCredential]) -> PScriptPurpose (s :: S)
PCertifying :: Term s (PDataRecord '["_0" ':= PDCert]) -> PScriptPurpose (s :: S)

-- | Reference to a transaction output with a index referencing which of
--   the outputs is being referred to.
newtype PTxOutRef (s :: S)
PTxOutRef :: Term s (PDataRecord '["id" ':= PTxId, "idx" ':= PInteger]) -> PTxOutRef (s :: S)

-- | A transaction output. This consists of a target address, value and
--   maybe a datum hash
newtype PTxOut (s :: S)
PTxOut :: Term s (PDataRecord '["address" ':= PAddress, "value" ':= PValue 'Sorted 'Positive, "datum" ':= POutputDatum, "referenceScript" ':= PMaybeData PScriptHash]) -> PTxOut (s :: S)
newtype PTxId (s :: S)
PTxId :: Term s (PDataRecord '["_0" ':= PByteString]) -> PTxId (s :: S)

-- | A input of the pending transaction.
newtype PTxInInfo (s :: S)
PTxInInfo :: Term s (PDataRecord '["outRef" ':= PTxOutRef, "resolved" ':= PTxOut]) -> PTxInInfo (s :: S)

-- | The datum attached to an output: either nothing, a datum hash or an
--   inline datum (CIP 32)
data POutputDatum (s :: S)
PNoOutputDatum :: Term s (PDataRecord '[]) -> POutputDatum (s :: S)
POutputDatumHash :: Term s (PDataRecord '["datumHash" ':= PDatumHash]) -> POutputDatum (s :: S)
POutputDatum :: Term s (PDataRecord '["outputDatum" ':= PDatum]) -> POutputDatum (s :: S)

-- | Data encoded Maybe type. Used in various ledger api types.
data PMaybeData a (s :: S)
PDJust :: Term s (PDataRecord '["_0" ':= a]) -> PMaybeData a (s :: S)
PDNothing :: Term s (PDataRecord '[]) -> PMaybeData a (s :: S)
type PTuple a b = PDataSum '[ '["_0" ':= a, "_1" ':= b]]
newtype PDatum (s :: S)
PDatum :: Term s PData -> PDatum (s :: S)
newtype PDatumHash (s :: S)
PDatumHash :: Term s PByteString -> PDatumHash (s :: S)
newtype PAddress (s :: S)
PAddress :: Term s (PDataRecord '["credential" ':= PCredential, "stakingCredential" ':= PMaybeData PStakingCredential]) -> PAddress (s :: S)
data KeyGuarantees
Sorted :: KeyGuarantees
Unsorted :: KeyGuarantees
data AmountGuarantees
NoGuarantees :: AmountGuarantees
NonZero :: AmountGuarantees
Positive :: AmountGuarantees
newtype PScriptHash (s :: S)
PScriptHash :: Term s PByteString -> PScriptHash (s :: S)
newtype PPubKeyHash (s :: S)
PPubKeyHash :: Term s PByteString -> PPubKeyHash (s :: S)
data PStakingCredential (s :: S)
PStakingHash :: Term s (PDataRecord '["_0" ':= PCredential]) -> PStakingCredential (s :: S)
PStakingPtr :: Term s (PDataRecord '["_0" ':= PInteger, "_1" ':= PInteger, "_2" ':= PInteger]) -> PStakingCredential (s :: S)
newtype PValue (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S)
PValue :: Term s (PMap keys PCurrencySymbol (PMap keys PTokenName PInteger)) -> PValue (keys :: KeyGuarantees) (amounts :: AmountGuarantees) (s :: S)
newtype PCurrencySymbol (s :: S)
PCurrencySymbol :: Term s PByteString -> PCurrencySymbol (s :: S)
newtype PTokenName (s :: S)
PTokenName :: Term s PByteString -> PTokenName (s :: S)
newtype PInterval a (s :: S)
PInterval :: Term s (PDataRecord '["from" ':= PLowerBound a, "to" ':= PUpperBound a]) -> PInterval a (s :: S)
data PExtended a (s :: S)
PNegInf :: Term s (PDataRecord '[]) -> PExtended a (s :: S)
PFinite :: Term s (PDataRecord '["_0" ':= a]) -> PExtended a (s :: S)
PPosInf :: Term s (PDataRecord '[]) -> PExtended a (s :: S)
type PClosure = PBool
newtype PLowerBound a (s :: S)
PLowerBound :: Term s (PDataRecord '["_0" ':= PExtended a, "_1" ':= PClosure]) -> PLowerBound a (s :: S)
newtype PUpperBound a (s :: S)
PUpperBound :: Term s (PDataRecord '["_0" ':= PExtended a, "_1" ':= PClosure]) -> PUpperBound a (s :: S)
newtype PPOSIXTime (s :: S)
PPOSIXTime :: Term s PInteger -> PPOSIXTime (s :: S)
type PPOSIXTimeRange = PInterval PPOSIXTime
newtype PMap (keysort :: KeyGuarantees) (k :: PType) (v :: PType) (s :: S)
PMap :: Term s (PBuiltinList (PBuiltinPair (PAsData k) (PAsData v))) -> PMap (keysort :: KeyGuarantees) (k :: PType) (v :: PType) (s :: S)

-- | Hash a Script, with the correct prefix for Plutus V2
scriptHash :: Script -> ScriptHash

-- | Hash a Datum.
datumHash :: Datum -> DatumHash

-- | Hash a Redeemer.
redeemerHash :: Redeemer -> RedeemerHash

-- | Hash the data encoded representation of given argument.
dataHash :: ToData a => a -> BuiltinByteString

-- | a Validator Term
type PValidator = PData :--> PData :--> PScriptContext :--> POpaque

-- | a StakeValidator Term
type PStakeValidator = PData :--> PScriptContext :--> POpaque

-- | a MintingPolicy Term
type PMintingPolicy = PData :--> PScriptContext :--> POpaque
