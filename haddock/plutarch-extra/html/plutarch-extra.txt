-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package plutarch-extra
@version 1.2.1

module Plutarch.Extra

module Plutarch.Extra.Api

-- | Find the output txns corresponding to the input being validated.
--   
--   Takes as arguments the inputs, outputs and the spending transaction
--   referenced from <tt>PScriptPurpose</tt>.
--   
--   <b>Example:</b>
--   
--   <pre>
--   ctx &lt;- tcont $ pletFields <tt>["txInfo", "purpose"] sc
--   pmatchC (getField </tt>"purpose" ctx) &gt;&gt;= case
--     PSpending outRef' -&gt; do
--       let outRef = pfield <tt>"_0" # outRef'
--           inputs = pfield </tt>"inputs" # (getField <tt>"txInfo" ctx)
--           outputs = pfield </tt>"outputs" # (getField @"txInfo" ctx)
--       pure $ pgetContinuingOutputs # inputs # outputs # outRef
--     _ -&gt;
--       pure $ ptraceError "not a spending tx"
--   
--   </pre>
pgetContinuingOutputs :: Term s (PBuiltinList PTxInInfo :--> (PBuiltinList PTxOut :--> (PTxOutRef :--> PBuiltinList PTxOut)))

-- | Find the input being spent in the current transaction.
--   
--   Takes as arguments the inputs, as well as the spending transaction
--   referenced from <tt>PScriptPurpose</tt>.
--   
--   <b>Example:</b>
--   
--   <pre>
--   ctx &lt;- tcont $ pletFields <tt>["txInfo", "purpose"] sc
--   pmatchC (getField </tt>"purpose" ctx) &gt;&gt;= case
--     PSpending outRef' -&gt; do
--       let outRef = pfield <tt>"_0" # outRef'
--           inputs = pfield </tt>"inputs" # (getField @"txInfo" ctx)
--       pure $ pfindOwnInput # inputs # outRef
--     _ -&gt;
--       pure $ ptraceError "not a spending tx"
--   
--   </pre>
pfindOwnInput :: Term s (PBuiltinList PTxInInfo :--> (PTxOutRef :--> PMaybe PTxInInfo))

-- | Lookup up the datum given the datum hash.
--   
--   Takes as argument the datum assoc list from a <tt>PTxInfo</tt>.
--   Validates the datum using <a>PTryFrom</a>.
--   
--   <b>Example:</b>
--   
--   <pre>
--   pparseDatum <tt>MyType # datumHash #$ pfield </tt>"datums" # txinfo
--   
--   </pre>
pparseDatum :: forall a s. PTryFrom PData (PAsData a) => Term s (PDatumHash :--> (PBuiltinList (PAsData (PTuple PDatumHash PDatum)) :--> PMaybe (PAsData a)))

module Plutarch.Extra.ByteString
pallBS :: Term s ((PInteger :--> PBool) :--> (PByteString :--> PBool))
pisHexDigit :: Term s (PInteger :--> PBool)

module Plutarch.Extra.Interval
pmember :: forall a (s :: S). (PEq a, POrd a, PIsData a) => Term s (PAsData a :--> (PInterval a :--> PBool))

-- | create an interval that includes all values that are greater than or
--   equal - to a and smaller than or equal to b
pinterval :: forall a (s :: S). PIsData a => Term s (PAsData a :--> (PAsData a :--> PInterval a))

-- | create an interval that includes all values that are greater than or
--   equal - to a
pfrom :: forall a s. PIsData a => Term s (PAsData a :--> PInterval a)

-- | create an interval that includes all values that are smaller than or
--   equal - to a
pto :: forall a (s :: S). PIsData a => Term s (PAsData a :--> PInterval a)

-- | create an interval that covers every slot
palways :: forall a (s :: S). (PIsData a, PLiftData a) => Term s (PInterval a)

-- | create an interval that is empty
pnever :: forall a (s :: S). (PIsData a, PLiftData a) => Term s (PInterval a)

-- | create and interval [a, a]
psingleton :: forall a (s :: S). PIsData a => Term s (PAsData a :--> PInterval a)

-- | `hull i1 i2` is the smallest interval containing <tt>i1</tt> and
--   <tt>i2</tt>
phull :: forall a (s :: S). (PEq a, POrd a, PIsData a) => Term s (PInterval a :--> (PInterval a :--> PInterval a))

-- | `intersecion i1 i2` is the largest interval contained in <tt>i1</tt>
--   and <tt>i2</tt>
pintersection :: forall a (s :: S). (PEq a, POrd a, PIsData a) => Term s (PInterval a :--> (PInterval a :--> PInterval a))

-- | pcontains # a # b is true if the interval <tt>b</tt> is entirely
--   contained in <tt>a</tt>
pcontains :: forall a (s :: S). (PEq a, POrd a, PIsData a) => Term s (PInterval a :--> (PInterval a :--> PBool))

-- | <tt>a</tt> before interval <tt>i</tt> is true if <tt>a</tt> is earlier
--   than the start of <tt>i</tt>
pbefore :: forall a (s :: S). (PEq a, POrd a, PIsData a) => Term s (a :--> (PInterval a :--> PBool))

-- | <tt>a</tt> after interval <tt>i</tt> is true if <tt>a</tt> is later
--   than the end of <tt>i</tt>
pafter :: forall a s. (PEq a, POrd a, PIsData a) => Term s (a :--> (PInterval a :--> PBool))

module Plutarch.Extra.List

-- | <i> O(n) </i>. reverses a list
preverse :: PIsListLike l a => Term s (l a :--> l a)

-- | <i> O(n) </i>.checks whether a list is sorted
pcheckSorted :: (PIsListLike l a, POrd a) => Term s (l a :--> PBool)

module Plutarch.Extra.Maybe

-- | Extracts the element out of a <a>PJust</a> and throws an error if its
--   argument is <a>PNothing</a>.
pfromJust :: forall (a :: PType) (s :: S). Term s (PMaybe a :--> a)

-- | Extracts the element out of a <a>PJust</a> and throws a custom error
--   if it's given a <a>PNothing</a>.
ptraceIfNothing :: forall (a :: PType) (s :: S). Term s PString -> Term s (PMaybe a) -> Term s a

-- | Yields true if the given <a>PMaybe</a> value is of form
--   <tt><a>PJust</a> _</tt>.
pisJust :: forall (a :: PType) (s :: S). Term s (PMaybe a :--> PBool)

-- | Given a default value, a function and a <a>PMaybe</a> value, yields
--   the default value if the <a>PMaybe</a> value is <a>PNothing</a> and
--   applies the function to the value stored in the <a>PJust</a>
--   otherwise.
pmaybe :: forall (b :: PType) (a :: PType) (s :: S). Term s (b :--> ((a :--> b) :--> (PMaybe a :--> b)))

-- | Extract a <a>PMaybe</a> by providing a default value in case of
--   <a>PJust</a>.
pfromMaybe :: forall (a :: PType) (s :: S). Term s (a :--> (PMaybe a :--> a))

-- | Construct a <a>PJust</a> value.
pjust :: forall (a :: PType) (s :: S). Term s (a :--> PMaybe a)

-- | Construct a <a>PNothing</a> value.
pnothing :: forall (a :: PType) (s :: S). Term s (PMaybe a)

-- | Extracts the element out of a <a>PDJust</a> and throws an error if its
--   argument is <a>PDNothing</a>.
pfromDJust :: forall (a :: PType) (s :: S). PIsData a => Term s (PMaybeData a :--> a)

-- | Yield True if a given <a>PMaybeData</a> is of form <tt><a>PDJust</a>
--   _</tt>.
pisDJust :: forall (a :: PType) (s :: S). Term s (PMaybeData a :--> PBool)

-- | Special version of <a>pmaybe</a> that works with <a>PMaybeData</a>
pmaybeData :: forall (a :: PType) (b :: PType) (s :: S). PIsData a => Term s (b :--> ((a :--> b) :--> (PMaybeData a :--> b)))

-- | Construct a <a>PDJust</a> value
pdjust :: forall (a :: PType) (s :: S). PIsData a => Term s (a :--> PMaybeData a)

-- | Construct a <a>PDNothing</a> value
pdnothing :: forall (a :: PType) (s :: S). Term s (PMaybeData a)

-- | Copnsturct a <a>PMaybeData</a> given a <a>PMaybe</a>. Could be useful
--   if you want to "lift" from <a>PMaybe</a> to <a>Maybe</a>.
pmaybeToMaybeData :: forall (a :: PType) (s :: S). PIsData a => Term s (PMaybe a :--> PMaybeData a)

-- | Escape with a particular value on expecting <a>Just</a>. For use in
--   monadic context.
pexpectJustC :: forall (a :: PType) (r :: PType) (s :: S). Term s r -> Term s (PMaybe a) -> TermCont @r s (Term s a)

-- | Extract the value stored in a PMaybe container. If there's no value,
--   throw an error with the given message.
passertPJust :: forall (a :: PType) (s :: S). Term s (PString :--> (PMaybe a :--> a))

-- | Extract the value stored in a PMaybeData container. If there's no
--   value, throw an error with the given message.
passertPDJust :: forall (a :: PType) (s :: S). PIsData a => Term s (PString :--> (PMaybeData a :--> a))

module Plutarch.Extra.Map

-- | As <a>plookup</a>, but errors when the key is missing.
ptryLookup :: forall (k :: PType) (v :: PType) (keys :: KeyGuarantees) (s :: S). (PIsData k, PIsData v) => Term s (k :--> (PMap keys k v :--> v))

-- | Gives <a>PTrue</a> if both argument <a>PMap</a>s contain mappings for
--   exactly the same set of keys. Requires a number of equality
--   comparisons between keys proportional to the length of the shorter
--   argument.
pkeysEqual :: forall (k :: PType) (a :: PType) (b :: PType) (s :: S). (PIsData k, PEq k) => Term s (PMap 'Sorted k a :--> (PMap 'Sorted k b :--> PBool))

-- | As <a>pkeysEqual</a>, but requires only <a>PEq</a> constraints for the
--   keys, and works for <a>Unsorted</a> <a>PMap</a>s. This requires a
--   number of equality comparisons between keys proportional to the
--   product of the lengths of both arguments: that is, this function is
--   quadratic.
pkeysEqualUnsorted :: forall (k :: PType) (a :: PType) (b :: PType) (s :: S). (PIsData k, PIsData a, PIsData b) => Term s (PMap 'Unsorted k a :--> (PMap 'Unsorted k b :--> PBool))

-- | Given an 'updater' and a key, if the key exists in the <a>PMap</a>,
--   apply the 'updater' to it, otherwise do nothing. If the 'updater'
--   produces <a>PNothing</a>, the value is deleted; otherwise, it is
--   modified to the result.
--   
--   Performance will be equivalent to a lookup followed by an insert (or
--   delete), as well as the cost of calling the 'updater'.
pupdate :: forall (k :: PType) (v :: PType) (s :: S). (PIsData k, PIsData v, POrd k) => Term s ((v :--> PMaybe v) :--> (k :--> (PMap 'Sorted k v :--> PMap 'Sorted k v)))

-- | If a value exists at the specified key, apply the function argument to
--   it; otherwise, do nothing.
padjust :: forall (k :: PType) (v :: PType) (s :: S). (PIsData k, PEq k, PIsData v) => Term s ((v :--> v) :--> (k :--> (PMap 'Unsorted k v :--> PMap 'Unsorted k v)))

-- | Like regular <a>fmap</a> but it provides key of each element that is
--   being modified.
pmapWithKey :: forall (k :: PType) (a :: PType) (b :: PType) (keysort :: KeyGuarantees) (s :: S). (PIsData k, PIsData a, PIsData b) => Term s ((k :--> (a :--> b)) :--> (PMap keysort k a :--> PMap 'Unsorted k b))

-- | Project all key-value pairs into a <a>Monoid</a>, then combine. Keys
--   and values will be presented in key order.
pfoldMapWithKey :: forall (m :: PType) (k :: PType) (v :: PType) (s :: S). (PIsData k, PIsData v, forall (s' :: S). Monoid (Term s' m)) => Term s ((k :--> (v :--> m)) :--> (PMap 'Sorted k v :--> m))

-- | Left-associative fold of a <a>PMap</a> with keys. Keys and values will
--   be presented in key order.
pfoldlWithKey :: forall (a :: PType) (k :: PType) (v :: PType) (s :: S). (PIsData k, PIsData v) => Term s ((a :--> (k :--> (v :--> a))) :--> (a :--> (PMap 'Sorted k v :--> a)))

-- | Get a list-like structure full of the keys of the argument
--   <a>PMap</a>. If the <a>PMap</a> is <a>Sorted</a>, the keys will
--   maintain that order, and will be unique; otherwise, the order is
--   unspecified, and duplicates may exist.
--   
--   <h1>Note</h1>
--   
--   You will need to specify what manner of list-like structure you want;
--   we have arranged the type signature to make specifying this easy with
--   <tt>TypeApplications</tt>.
pkeys :: forall (ell :: PType -> PType) (k :: PType) (v :: PType) (keys :: KeyGuarantees) (s :: S). (PListLike ell, PElemConstraint ell (PAsData k)) => Term s (PMap keys k v :--> ell (PAsData k))

-- | Get the key of a key-value pair.
pkvPairKey :: forall (k :: PType) (v :: PType) (s :: S). PIsData k => Term s (PBuiltinPair (PAsData k) (PAsData v) :--> k)

-- | Get the value of a key-value pair.
pkvPairValue :: forall (k :: PType) (v :: PType) (s :: S). PIsData v => Term s (PBuiltinPair (PAsData k) (PAsData v) :--> v)

-- | Compare two key-value pairs by their keys. Gives <a>PTrue</a> if the
--   key of the first argument pair is less than the key of the second
--   argument pair.
pkvPairLt :: forall (k :: PType) (v :: PType) (s :: S). (PIsData k, PPartialOrd k) => Term s (PBuiltinPair (PAsData k) (PAsData v) :--> (PBuiltinPair (PAsData k) (PAsData v) :--> PBool))


-- | TermCont-related adapters for Plutarch functions.
module Plutarch.Extra.TermCont

-- | Like <a>plet</a> but works in a <a>TermCont</a> monad
pletC :: Term s a -> TermCont s (Term s a)

-- | Like <a>pmatch</a> but works in a <a>TermCont</a> monad
pmatchC :: PlutusType a => Term s a -> TermCont s (a s)

-- | Like <a>pletFields</a> but works in a <a>TermCont</a> monad.
pletFieldsC :: forall fs a s b ps bs. (PDataFields a, ps ~ PFields a, bs ~ Bindings ps fs, BindFields ps bs) => Term s a -> TermCont @b s (HRec (BoundTerms ps bs s))

-- | Like <a>ptrace</a> but works in a <a>TermCont</a> monad.
--   
--   <h3>Example ===</h3>
--   
--   <pre>
--   foo :: Term s PUnit
--   foo = unTermCont $ do
--     ptraceC "returning unit!"
--     pure $ pconstant ()
--   </pre>
ptraceC :: Term s PString -> TermCont s ()

-- | Trace a message and raise error if <tt>cond</tt> is false. Otherwise,
--   continue.
--   
--   <h3>Example ===</h3>
--   
--   <pre>
--   onlyAllow42 :: Term s (PInteger :--&gt; PUnit)
--   onlyAllow42 = plam $ i -&gt; unTermCont $ do
--     pguardC "expected 42" $ i #== 42
--     pure $ pconstant ()
--   </pre>
pguardC :: Term s PString -> Term s PBool -> TermCont s ()

-- | Stop computation and return given term if <tt>cond</tt> is false.
--   Otherwise, continue.
--   
--   <h3>Example ===</h3>
--   
--   <pre>
--   is42 :: Term s (PInteger :--&gt; PBool)
--   is42 = plam $ i -&gt; unTermCont $ do
--     pguardC' (pconstant False) $ i #== 42
--     pure $ pconstant True
--   </pre>
pguardC' :: Term s a -> Term s PBool -> TermCont @a s ()

-- | <a>TermCont</a> producing version of <a>ptryFrom</a>.
ptryFromC :: forall b r a s. PTryFrom a b => Term s a -> TermCont @r s (Term s b, Reduce (PTryFromExcess a b s))

module Plutarch.Extra.RationalData

-- | A Rational type that corresponds to the data encoding used by
--   <a>Rational</a>.
data PRationalData s
prationalFromData :: ClosedTerm (PRationalData :--> PRational)
instance Plutarch.Bool.PEq Plutarch.Extra.RationalData.PRationalData
instance Plutarch.DataRepr.Internal.Field.PDataFields Plutarch.Extra.RationalData.PRationalData
instance Plutarch.Builtin.PIsData Plutarch.Extra.RationalData.PRationalData
instance Plutarch.Internal.PlutusType.PlutusType Plutarch.Extra.RationalData.PRationalData
instance forall (s :: Plutarch.Internal.S). GHC.Generics.Generic (Plutarch.Extra.RationalData.PRationalData s)
instance forall k1 k2 (f :: k2 -> k1 -> GHC.Types.Type) (a :: k1) (b :: k2). GHC.Generics.Generic (Plutarch.Extra.RationalData.Flip @{k2} @{k1} f a b)
instance Plutarch.Lift.PConstantDecl PlutusTx.Ratio.Rational
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData Plutarch.Extra.RationalData.PRationalData
instance Plutarch.TryFrom.PTryFrom Plutarch.Builtin.PData (Plutarch.Builtin.PAsData Plutarch.Extra.RationalData.PRationalData)
instance Plutarch.Bool.PPartialOrd Plutarch.Extra.RationalData.PRationalData
instance Plutarch.Bool.POrd Plutarch.Extra.RationalData.PRationalData
instance Plutarch.Internal.PlutusType.DerivePlutusType Plutarch.Extra.RationalData.PRationalData
instance Plutarch.Lift.PUnsafeLiftDecl Plutarch.Extra.RationalData.PRationalData
