<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Plutarch.Extra.Map</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">plutarch-extra-1.2.0</span><ul class="links" id="page-menu"><li id="quick-jump-button"><a href="#">Quick Jump</a></li><li><a href="src/Plutarch.Extra.Map.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Plutarch.Extra.Map</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Lookup</a></li><li><a href="#g:2">Comparisons</a></li><li><a href="#g:3">Modification</a></li><li><a href="#g:4">Folds</a></li><li><a href="#g:5">Conversion</a></li><li><a href="#g:6">Key-value pair manipulation</a></li></ul></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:ptryLookup">ptryLookup</a> :: <span class="keyword">forall</span> (k :: PType) (v :: PType) (keys :: KeyGuarantees) (s :: S). (PIsData k, PIsData v) =&gt; Term s (k :--&gt; (PMap keys k v :--&gt; v))</li><li class="src short"><a href="#v:pkeysEqual">pkeysEqual</a> :: <span class="keyword">forall</span> (k :: PType) (a :: PType) (b :: PType) (s :: S). (PIsData k, PEq k) =&gt; Term s (PMap 'Sorted k a :--&gt; (PMap 'Sorted k b :--&gt; PBool))</li><li class="src short"><a href="#v:pkeysEqualUnsorted">pkeysEqualUnsorted</a> :: <span class="keyword">forall</span> (k :: PType) (a :: PType) (b :: PType) (s :: S). (PIsData k, PIsData a, PIsData b) =&gt; Term s (PMap 'Unsorted k a :--&gt; (PMap 'Unsorted k b :--&gt; PBool))</li><li class="src short"><a href="#v:pupdate">pupdate</a> :: <span class="keyword">forall</span> (k :: PType) (v :: PType) (s :: S). (PIsData k, PIsData v, POrd k) =&gt; Term s ((v :--&gt; PMaybe v) :--&gt; (k :--&gt; (PMap 'Sorted k v :--&gt; PMap 'Sorted k v)))</li><li class="src short"><a href="#v:padjust">padjust</a> :: <span class="keyword">forall</span> (k :: PType) (v :: PType) (s :: S). (PIsData k, PEq k, PIsData v) =&gt; Term s ((v :--&gt; v) :--&gt; (k :--&gt; (PMap 'Unsorted k v :--&gt; PMap 'Unsorted k v)))</li><li class="src short"><a href="#v:pmapWithKey">pmapWithKey</a> :: <span class="keyword">forall</span> (k :: PType) (a :: PType) (b :: PType) (keysort :: KeyGuarantees) (s :: S). (PIsData k, PIsData a, PIsData b) =&gt; Term s ((k :--&gt; (a :--&gt; b)) :--&gt; (PMap keysort k a :--&gt; PMap 'Unsorted k b))</li><li class="src short"><a href="#v:pfoldMapWithKey">pfoldMapWithKey</a> :: <span class="keyword">forall</span> (m :: PType) (k :: PType) (v :: PType) (s :: S). (PIsData k, PIsData v, <span class="keyword">forall</span> (s' :: S). <a href="../../ghc-9.6.3/html/libraries/base-4.18.1.0/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> (Term s' m)) =&gt; Term s ((k :--&gt; (v :--&gt; m)) :--&gt; (PMap 'Sorted k v :--&gt; m))</li><li class="src short"><a href="#v:pfoldlWithKey">pfoldlWithKey</a> :: <span class="keyword">forall</span> (a :: PType) (k :: PType) (v :: PType) (s :: S). (PIsData k, PIsData v) =&gt; Term s ((a :--&gt; (k :--&gt; (v :--&gt; a))) :--&gt; (a :--&gt; (PMap 'Sorted k v :--&gt; a)))</li><li class="src short"><a href="#v:pkeys">pkeys</a> :: <span class="keyword">forall</span> (ell :: PType -&gt; PType) (k :: PType) (v :: PType) (keys :: KeyGuarantees) (s :: S). (PListLike ell, PElemConstraint ell (PAsData k)) =&gt; Term s (PMap keys k v :--&gt; ell (PAsData k))</li><li class="src short"><a href="#v:pkvPairKey">pkvPairKey</a> :: <span class="keyword">forall</span> (k :: PType) (v :: PType) (s :: S). PIsData k =&gt; Term s (PBuiltinPair (PAsData k) (PAsData v) :--&gt; k)</li><li class="src short"><a href="#v:pkvPairValue">pkvPairValue</a> :: <span class="keyword">forall</span> (k :: PType) (v :: PType) (s :: S). PIsData v =&gt; Term s (PBuiltinPair (PAsData k) (PAsData v) :--&gt; v)</li><li class="src short"><a href="#v:pkvPairLt">pkvPairLt</a> :: <span class="keyword">forall</span> (k :: PType) (v :: PType) (s :: S). (PIsData k, PPartialOrd k) =&gt; Term s (PBuiltinPair (PAsData k) (PAsData v) :--&gt; (PBuiltinPair (PAsData k) (PAsData v) :--&gt; PBool))</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Lookup</h1></a><div class="top"><p class="src"><a id="v:ptryLookup" class="def">ptryLookup</a> :: <span class="keyword">forall</span> (k :: PType) (v :: PType) (keys :: KeyGuarantees) (s :: S). (PIsData k, PIsData v) =&gt; Term s (k :--&gt; (PMap keys k v :--&gt; v)) <a href="src/Plutarch.Extra.Map.html#ptryLookup" class="link">Source</a> <a href="#v:ptryLookup" class="selflink">#</a></p><div class="doc"><p>As <code>plookup</code>, but errors when the key is missing.</p></div></div><a href="#g:2" id="g:2"><h1>Comparisons</h1></a><div class="top"><p class="src"><a id="v:pkeysEqual" class="def">pkeysEqual</a> :: <span class="keyword">forall</span> (k :: PType) (a :: PType) (b :: PType) (s :: S). (PIsData k, PEq k) =&gt; Term s (PMap 'Sorted k a :--&gt; (PMap 'Sorted k b :--&gt; PBool)) <a href="src/Plutarch.Extra.Map.html#pkeysEqual" class="link">Source</a> <a href="#v:pkeysEqual" class="selflink">#</a></p><div class="doc"><p>Gives <code>PTrue</code> if both argument <code>PMap</code>s contain mappings for exactly the
 same set of keys. Requires a number of equality comparisons between keys
 proportional to the length of the shorter argument.</p></div></div><div class="top"><p class="src"><a id="v:pkeysEqualUnsorted" class="def">pkeysEqualUnsorted</a> :: <span class="keyword">forall</span> (k :: PType) (a :: PType) (b :: PType) (s :: S). (PIsData k, PIsData a, PIsData b) =&gt; Term s (PMap 'Unsorted k a :--&gt; (PMap 'Unsorted k b :--&gt; PBool)) <a href="src/Plutarch.Extra.Map.html#pkeysEqualUnsorted" class="link">Source</a> <a href="#v:pkeysEqualUnsorted" class="selflink">#</a></p><div class="doc"><p>As <code><a href="Plutarch-Extra-Map.html#v:pkeysEqual" title="Plutarch.Extra.Map">pkeysEqual</a></code>, but requires only <code>PEq</code> constraints for the keys, and
 works for <code>Unsorted</code> <code>PMap</code>s. This requires a number of equality comparisons
 between keys proportional to the product of the lengths of both arguments:
 that is, this function is quadratic.</p></div></div><a href="#g:3" id="g:3"><h1>Modification</h1></a><div class="top"><p class="src"><a id="v:pupdate" class="def">pupdate</a> :: <span class="keyword">forall</span> (k :: PType) (v :: PType) (s :: S). (PIsData k, PIsData v, POrd k) =&gt; Term s ((v :--&gt; PMaybe v) :--&gt; (k :--&gt; (PMap 'Sorted k v :--&gt; PMap 'Sorted k v))) <a href="src/Plutarch.Extra.Map.html#pupdate" class="link">Source</a> <a href="#v:pupdate" class="selflink">#</a></p><div class="doc"><p>Given an 'updater' and a key, if the key exists in the <code>PMap</code>, apply the
 'updater' to it, otherwise do nothing. If the 'updater' produces
 <code>PNothing</code>, the value is deleted; otherwise, it is modified to the result.</p><p>Performance will be equivalent to a lookup followed by an insert (or delete),
 as well as the cost of calling the 'updater'.</p></div></div><div class="top"><p class="src"><a id="v:padjust" class="def">padjust</a> :: <span class="keyword">forall</span> (k :: PType) (v :: PType) (s :: S). (PIsData k, PEq k, PIsData v) =&gt; Term s ((v :--&gt; v) :--&gt; (k :--&gt; (PMap 'Unsorted k v :--&gt; PMap 'Unsorted k v))) <a href="src/Plutarch.Extra.Map.html#padjust" class="link">Source</a> <a href="#v:padjust" class="selflink">#</a></p><div class="doc"><p>If a value exists at the specified key, apply the function argument to it;
 otherwise, do nothing.</p></div></div><div class="top"><p class="src"><a id="v:pmapWithKey" class="def">pmapWithKey</a> :: <span class="keyword">forall</span> (k :: PType) (a :: PType) (b :: PType) (keysort :: KeyGuarantees) (s :: S). (PIsData k, PIsData a, PIsData b) =&gt; Term s ((k :--&gt; (a :--&gt; b)) :--&gt; (PMap keysort k a :--&gt; PMap 'Unsorted k b)) <a href="src/Plutarch.Extra.Map.html#pmapWithKey" class="link">Source</a> <a href="#v:pmapWithKey" class="selflink">#</a></p><div class="doc"><p>Like regular <code><a href="../../ghc-9.6.3/html/libraries/base-4.18.1.0/Data-Functor.html#v:fmap" title="Data.Functor">fmap</a></code> but it provides key of each element that is being
     modified.</p></div></div><a href="#g:4" id="g:4"><h1>Folds</h1></a><div class="top"><p class="src"><a id="v:pfoldMapWithKey" class="def">pfoldMapWithKey</a> :: <span class="keyword">forall</span> (m :: PType) (k :: PType) (v :: PType) (s :: S). (PIsData k, PIsData v, <span class="keyword">forall</span> (s' :: S). <a href="../../ghc-9.6.3/html/libraries/base-4.18.1.0/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> (Term s' m)) =&gt; Term s ((k :--&gt; (v :--&gt; m)) :--&gt; (PMap 'Sorted k v :--&gt; m)) <a href="src/Plutarch.Extra.Map.html#pfoldMapWithKey" class="link">Source</a> <a href="#v:pfoldMapWithKey" class="selflink">#</a></p><div class="doc"><p>Project all key-value pairs into a <code><a href="../../ghc-9.6.3/html/libraries/base-4.18.1.0/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a></code>, then combine. Keys and values
 will be presented in key order.</p></div></div><div class="top"><p class="src"><a id="v:pfoldlWithKey" class="def">pfoldlWithKey</a> :: <span class="keyword">forall</span> (a :: PType) (k :: PType) (v :: PType) (s :: S). (PIsData k, PIsData v) =&gt; Term s ((a :--&gt; (k :--&gt; (v :--&gt; a))) :--&gt; (a :--&gt; (PMap 'Sorted k v :--&gt; a))) <a href="src/Plutarch.Extra.Map.html#pfoldlWithKey" class="link">Source</a> <a href="#v:pfoldlWithKey" class="selflink">#</a></p><div class="doc"><p>Left-associative fold of a <code>PMap</code> with keys. Keys and values will be
 presented in key order.</p></div></div><a href="#g:5" id="g:5"><h1>Conversion</h1></a><div class="top"><p class="src"><a id="v:pkeys" class="def">pkeys</a> :: <span class="keyword">forall</span> (ell :: PType -&gt; PType) (k :: PType) (v :: PType) (keys :: KeyGuarantees) (s :: S). (PListLike ell, PElemConstraint ell (PAsData k)) =&gt; Term s (PMap keys k v :--&gt; ell (PAsData k)) <a href="src/Plutarch.Extra.Map.html#pkeys" class="link">Source</a> <a href="#v:pkeys" class="selflink">#</a></p><div class="doc"><p>Get a list-like structure full of the keys of the argument <code>PMap</code>. If the
 <code>PMap</code> is <code>Sorted</code>, the keys will maintain that order, and will be unique;
 otherwise, the order is unspecified, and duplicates may exist.</p><h1>Note</h1><p>You will need to specify what manner of list-like structure you want; we have
 arranged the type signature to make specifying this easy with
 <code>TypeApplications</code>.</p></div></div><a href="#g:6" id="g:6"><h1>Key-value pair manipulation</h1></a><div class="top"><p class="src"><a id="v:pkvPairKey" class="def">pkvPairKey</a> :: <span class="keyword">forall</span> (k :: PType) (v :: PType) (s :: S). PIsData k =&gt; Term s (PBuiltinPair (PAsData k) (PAsData v) :--&gt; k) <a href="src/Plutarch.Extra.Map.html#pkvPairKey" class="link">Source</a> <a href="#v:pkvPairKey" class="selflink">#</a></p><div class="doc"><p>Get the key of a key-value pair.</p></div></div><div class="top"><p class="src"><a id="v:pkvPairValue" class="def">pkvPairValue</a> :: <span class="keyword">forall</span> (k :: PType) (v :: PType) (s :: S). PIsData v =&gt; Term s (PBuiltinPair (PAsData k) (PAsData v) :--&gt; v) <a href="src/Plutarch.Extra.Map.html#pkvPairValue" class="link">Source</a> <a href="#v:pkvPairValue" class="selflink">#</a></p><div class="doc"><p>Get the value of a key-value pair.</p></div></div><div class="top"><p class="src"><a id="v:pkvPairLt" class="def">pkvPairLt</a> :: <span class="keyword">forall</span> (k :: PType) (v :: PType) (s :: S). (PIsData k, PPartialOrd k) =&gt; Term s (PBuiltinPair (PAsData k) (PAsData v) :--&gt; (PBuiltinPair (PAsData k) (PAsData v) :--&gt; PBool)) <a href="src/Plutarch.Extra.Map.html#pkvPairLt" class="link">Source</a> <a href="#v:pkvPairLt" class="selflink">#</a></p><div class="doc"><p>Compare two key-value pairs by their keys. Gives <code>PTrue</code> if the key of the
 first argument pair is less than the key of the second argument pair.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.1</p></div></body></html>