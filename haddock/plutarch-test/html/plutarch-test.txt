-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package plutarch-test
@version 1.2.0

module Plutarch.Test.Benchmark
data Benchmark
Benchmark :: ExCPU -> ExMemory -> ScriptSizeBytes -> Benchmark

-- | CPU budget used by the script.
[$sel:exBudgetCPU:Benchmark] :: Benchmark -> ExCPU

-- | Memory budget used by the script.
[$sel:exBudgetMemory:Benchmark] :: Benchmark -> ExMemory

-- | Size of Plutus script in bytes
[$sel:scriptSizeBytes:Benchmark] :: Benchmark -> ScriptSizeBytes
data ScriptSizeBytes
mkBenchmark :: ExBudget -> ScriptSizeBytes -> Benchmark
scriptSize :: Script -> ScriptSizeBytes
instance Data.Aeson.Types.ToJSON.ToJSON Plutarch.Test.Benchmark.ScriptSizeBytes
instance GHC.Num.Num Plutarch.Test.Benchmark.ScriptSizeBytes
instance GHC.Generics.Generic Plutarch.Test.Benchmark.ScriptSizeBytes
instance GHC.Show.Show Plutarch.Test.Benchmark.ScriptSizeBytes
instance GHC.Classes.Ord Plutarch.Test.Benchmark.ScriptSizeBytes
instance GHC.Classes.Eq Plutarch.Test.Benchmark.ScriptSizeBytes
instance Data.Aeson.Types.ToJSON.ToJSON Plutarch.Test.Benchmark.Benchmark
instance GHC.Generics.Generic Plutarch.Test.Benchmark.Benchmark
instance GHC.Show.Show Plutarch.Test.Benchmark.Benchmark

module Plutarch.Test.ListSyntax
type ListSyntax elem = ListSyntaxM elem ()
runListSyntax :: ListSyntax elem -> [elem]
listSyntaxAdd :: elem -> ListSyntax elem
listSyntaxAddSubList :: Semigroup k => k -> ListSyntax (k, v) -> ListSyntax (k, v)
instance forall elem. GHC.Base.Monad (Plutarch.Test.ListSyntax.ListSyntaxM elem)
instance forall elem. GHC.Base.Applicative (Plutarch.Test.ListSyntax.ListSyntaxM elem)
instance forall elem. GHC.Base.Functor (Plutarch.Test.ListSyntax.ListSyntaxM elem)

module Plutarch.Test.Golden

-- | Create golden specs for pre/post-eval UPLC and benchmarks.
--   
--   A *single* golden file will be created (for each metric) for all the
--   programs in the given tree.
--   
--   For example, ``` pgoldenSpec $ do "foo" <tt>| pconstant 42 "bar" </tt>
--   do "qux" @| pconstant <a>Hello</a> ```
--   
--   Will create three golden files -- uplc.golden, uplc.eval.golden and
--   bench.golden -- each containing three lines one for each program
--   above. Hierarchy is represented by intercalating with a dot; for
--   instance, the key for <tt>qux</tt> will be "bar.qux".
pgoldenSpec :: HasCallStack => PlutarchGoldens -> Spec

-- | Like <a>pgoldenSpec</a> but takes a <a>GoldenConf</a> to determine
--   which goldens to track.
--   
--   <pre>
--   pgoldenSpec = pgoldenSpec' def
--   </pre>
pgoldenSpec' :: HasCallStack => GoldenConf -> PlutarchGoldens -> Spec

-- | Specify goldens for the given Plutarch program
(@|) :: forall t a. HasGoldenValue t => GoldenKey -> (forall s. t s a) -> PlutarchGoldens
infixr 0 @|

-- | Add an expectation for the Plutarch program specified with (@|)
(@\) :: GoldenKey -> PlutarchGoldens -> PlutarchGoldens

-- | Test an expectation on a golden Plutarch program
(@->) :: ClosedTerm a -> (ClosedTerm a -> Expectation) -> TermExpectation a
infixr 1 @->

-- | Like <a>@-&gt;</a> but also takes the evaluated script and benchmark
--   as arguments
--   
--   Useful to do assertion checks on post-evaluation benchmark (eg: to
--   check if script size is below certain threshold) -- use in conjunction
--   with <tt>psatisfyWithinBenchmark</tt> -- or on evaluated script (ie.,
--   without re-evaluating the program).
(@:->) :: ClosedTerm a -> ((ClosedTerm a, Script, Benchmark) -> Expectation) -> TermExpectation a
infixr 1 @:->
type TermExpectation a = forall s. TermExpectation' s a
type PlutarchGoldens = ListSyntax (GoldenKey, GoldenValue)

-- | The key used in the .golden files containing multiple golden values
data GoldenKey
currentGoldenKey :: HasCallStack => SpecM () GoldenKey
goldenKeyString :: GoldenKey -> String
mkGoldenKeyFromSpecPath :: HasCallStack => [Text] -> GoldenKey
defaultGoldenBasePath :: FilePath
goldenTestPath :: FilePath -> GoldenKey -> GoldenTest -> FilePath
data GoldenConf
GoldenConf :: Set GoldenTest -> FilePath -> GoldenConf
[$sel:chosenTests:GoldenConf] :: GoldenConf -> Set GoldenTest

-- | Directory to put the goldens in.
[$sel:goldenBasePath:GoldenConf] :: GoldenConf -> FilePath
data GoldenTest

-- | The unevaluated UPLC (compiled target of Plutarch term)
GoldenT'UPLCPreEval :: GoldenTest

-- | The evaluated UPLC (evaluated result of Plutarch term)
GoldenT'UPLCPostEval :: GoldenTest

-- | Benchmark of Plutarch term (will never fail)
GoldenT'Bench :: GoldenTest

-- | Like <a>evalScript</a> but doesn't throw <tt>EvalError</tt>, and
--   returns <a>Benchmark</a>.
--   
--   On <tt>EvalError</tt>, this function returns <a>perror</a> as
--   evaluated script. Plutus does not provide an accurate way to tell if
--   the program evaluates to <tt>Error</tt> or not; see
--   <a>https://github.com/input-output-hk/plutus/issues/4270</a>
evalScriptAlwaysWithBenchmark :: Script -> (Script, Benchmark)
compileD :: ClosedTerm a -> Script
instance Data.String.IsString Plutarch.Test.Golden.GoldenKey
instance GHC.Classes.Ord Plutarch.Test.Golden.GoldenKey
instance GHC.Show.Show Plutarch.Test.Golden.GoldenKey
instance GHC.Classes.Eq Plutarch.Test.Golden.GoldenKey
instance GHC.Enum.Bounded Plutarch.Test.Golden.GoldenTest
instance GHC.Enum.Enum Plutarch.Test.Golden.GoldenTest
instance GHC.Classes.Ord Plutarch.Test.Golden.GoldenTest
instance GHC.Show.Show Plutarch.Test.Golden.GoldenTest
instance GHC.Classes.Eq Plutarch.Test.Golden.GoldenTest
instance GHC.Show.Show Plutarch.Test.Golden.GoldenConf
instance GHC.Classes.Eq Plutarch.Test.Golden.GoldenConf
instance Data.Default.Class.Default Plutarch.Test.Golden.GoldenConf
instance GHC.Base.Semigroup Plutarch.Test.Golden.GoldenKey
instance Plutarch.Test.Golden.HasGoldenValue Plutarch.Test.Golden.TermExpectation'
instance Plutarch.Test.Golden.HasGoldenValue Plutarch.Internal.Term


-- | Generator helpers
module Plutarch.Test.Property.Gen
genRational :: (MonadPlus g, MonadGen g) => g Rational
genInteger :: MonadGen g => g Integer
genList :: MonadGen g => g a -> g [a]
bsOfLength :: Int -> Gen ByteString
instance Test.QuickCheck.Arbitrary.Arbitrary PlutusTx.Builtins.Internal.BuiltinByteString
instance Test.QuickCheck.Arbitrary.Arbitrary PlutusLedgerApi.V1.Value.CurrencySymbol
instance Test.QuickCheck.Arbitrary.Arbitrary PlutusLedgerApi.V1.Value.Value
instance Test.QuickCheck.Arbitrary.Arbitrary PlutusLedgerApi.V1.Value.TokenName
instance Test.QuickCheck.Arbitrary.Arbitrary PlutusLedgerApi.V1.Crypto.PubKeyHash
instance Test.QuickCheck.Arbitrary.Arbitrary PlutusLedgerApi.V1.Scripts.ScriptHash
instance Test.QuickCheck.Arbitrary.Arbitrary PlutusLedgerApi.V1.Credential.Credential
instance Test.QuickCheck.Arbitrary.Arbitrary PlutusLedgerApi.V1.Credential.StakingCredential
instance Test.QuickCheck.Arbitrary.Arbitrary PlutusLedgerApi.V1.Address.Address

module Plutarch.Test.Property.Marshal

-- | Class of Haskell types that can be marshalled to a Plutarch term.
class Marshal h (p :: PType) | h -> p
marshal :: Marshal h p => h -> ClosedTerm p
marshal :: (Marshal h p, PLifted p ~ h, PLift p) => h -> ClosedTerm p
instance forall h (p :: Plutarch.Internal.PType). Plutarch.Test.Property.Marshal.Marshal h p => Plutarch.Test.Property.Marshal.Marshal [h] (Plutarch.List.PList p)
instance forall ha (pa :: Plutarch.Internal.PType). Plutarch.Test.Property.Marshal.Marshal ha pa => Plutarch.Test.Property.Marshal.Marshal (GHC.Maybe.Maybe ha) (Plutarch.Maybe.PMaybe pa)
instance forall ha (pa :: Plutarch.Internal.PType) hb (pb :: Plutarch.Internal.PType). (Plutarch.Test.Property.Marshal.Marshal ha pa, Plutarch.Test.Property.Marshal.Marshal hb pb) => Plutarch.Test.Property.Marshal.Marshal (ha, hb) (Plutarch.Pair.PPair pa pb)
instance Plutarch.Test.Property.Marshal.Marshal GHC.Num.Integer.Integer Plutarch.Integer.PInteger
instance Plutarch.Test.Property.Marshal.Marshal GHC.Real.Rational Plutarch.Rational.PRational
instance Plutarch.Test.Property.Marshal.Marshal GHC.Types.Bool Plutarch.Bool.PBool
instance Plutarch.Test.Property.Marshal.Marshal () (Plutarch.Unit.PUnit @{Plutarch.Internal.S})


-- | The property of Plutarch terms corresponding to a Haskell term.
--   
--   Assuming Haskell functions are already well-tested, by verifying the
--   property that a Plutarch term functions equivalently to the
--   corresponding Haskell term we automatically (more or less) verify the
--   correctness of the Plutarch term.
--   
--   This modules provides a <a>prop_haskEquiv</a> to that end.
module Plutarch.Test.Property.HaskEquiv

-- | The given Plutarch term is equivalent to the given Haskell type upto
--   the given <a>Equality</a> and <a>Totality</a>.
--   
--   Generator arguments must be non-empty if the term is a lambda. This
--   function must always be called using <tt>TypeApplications</tt>
--   specifying the first two type variables.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; prop_haskEquiv
--     @'OnPEq
--     @'TotalFun
--     (reverse :: [Integer] -&gt; [Integer])
--     preverse
--     (genList genInteger :* Nil)
--   </pre>
prop_haskEquiv :: forall (e :: Equality) (t :: Totality) h p. HaskEquiv e t h p (LamArgs h) => h -> ClosedTerm p -> NP Gen (LamArgs h) -> Property

-- | The nature of equality between two Plutarch terms.
data Equality
OnPEq :: Equality
OnPData :: Equality

-- | Terms are equal on both <a>PEq</a> and <a>PData</a>
OnBoth :: Equality

-- | Whether a function is total or partial.
data Totality
TotalFun :: Totality

-- | The Plutarch *and* Haskell function is expected to be partial (error's
--   on certain inputs).
PartialFun :: Totality
data () => NP (a :: k -> Type) (b :: [k])
[Nil] :: forall {k} (a :: k -> Type). NP a ('[] :: [k])
[:*] :: forall {k} (a :: k -> Type) (x :: k) (xs :: [k]). a x -> NP a xs -> NP a (x ': xs)

-- | Argument types for a Haskell function (empty if a term value)
type family LamArgs f :: [Type]

-- | Class of pairs of Plutarch and Haskell types that are semantically
--   equivalent, upto the given <a>Equality</a> and <a>Totality</a>.
class LamArgs h ~ args => HaskEquiv (e :: Equality) (t :: Totality) h p args | h -> p
testDataEq :: PIsData a => ClosedTerm a -> ClosedTerm a -> PropertyT IO ()
testPEq :: PEq a => ClosedTerm a -> ClosedTerm a -> PropertyT IO ()
instance GHC.Classes.Ord Plutarch.Test.Property.HaskEquiv.Equality
instance GHC.Show.Show Plutarch.Test.Property.HaskEquiv.Equality
instance GHC.Classes.Eq Plutarch.Test.Property.HaskEquiv.Equality
instance GHC.Classes.Ord Plutarch.Test.Property.HaskEquiv.Totality
instance GHC.Show.Show Plutarch.Test.Property.HaskEquiv.Totality
instance GHC.Classes.Eq Plutarch.Test.Property.HaskEquiv.Totality
instance forall ha (pa :: Plutarch.Internal.PType) (e :: Plutarch.Test.Property.HaskEquiv.Equality) (t :: Plutarch.Test.Property.HaskEquiv.Totality) hb (pb :: Plutarch.Internal.PType) (hbArgs :: [GHC.Types.Type]). (GHC.Show.Show ha, Plutarch.Test.Property.Marshal.Marshal ha pa, Plutarch.Test.Property.HaskEquiv.HaskEquiv e t hb pb hbArgs, (Plutarch.Test.Property.HaskEquiv.LamArgs hb :: [GHC.Types.Type]) GHC.Types.~ (hbArgs :: [GHC.Types.Type])) => Plutarch.Test.Property.HaskEquiv.HaskEquiv e t (ha -> hb) (pa Plutarch.Internal.:--> pb) ((':) @GHC.Types.Type ha hbArgs)
instance forall (p :: Plutarch.Internal.PType) h. (Plutarch.Builtin.PIsData p, Plutarch.Test.Property.Marshal.Marshal h p, (Plutarch.Test.Property.HaskEquiv.LamArgs h :: [GHC.Types.Type]) GHC.Types.~ ('[] @GHC.Types.Type :: [GHC.Types.Type])) => Plutarch.Test.Property.HaskEquiv.HaskEquiv 'Plutarch.Test.Property.HaskEquiv.OnPData 'Plutarch.Test.Property.HaskEquiv.TotalFun h p ('[] @GHC.Types.Type)
instance forall (p :: Plutarch.Internal.PType) h. (Plutarch.Bool.PEq p, Plutarch.Test.Property.Marshal.Marshal h p, (Plutarch.Test.Property.HaskEquiv.LamArgs h :: [GHC.Types.Type]) GHC.Types.~ ('[] @GHC.Types.Type :: [GHC.Types.Type])) => Plutarch.Test.Property.HaskEquiv.HaskEquiv 'Plutarch.Test.Property.HaskEquiv.OnPEq 'Plutarch.Test.Property.HaskEquiv.TotalFun h p ('[] @GHC.Types.Type)
instance forall h (p :: Plutarch.Internal.PType). (Plutarch.Test.Property.Marshal.Marshal h p, Plutarch.Test.Property.HaskEquiv.HaskEquiv 'Plutarch.Test.Property.HaskEquiv.OnPEq 'Plutarch.Test.Property.HaskEquiv.TotalFun h p ('[] @GHC.Types.Type), Plutarch.Test.Property.HaskEquiv.HaskEquiv 'Plutarch.Test.Property.HaskEquiv.OnPData 'Plutarch.Test.Property.HaskEquiv.TotalFun h p ('[] @GHC.Types.Type)) => Plutarch.Test.Property.HaskEquiv.HaskEquiv 'Plutarch.Test.Property.HaskEquiv.OnBoth 'Plutarch.Test.Property.HaskEquiv.TotalFun h p ('[] @GHC.Types.Type)
instance forall h (p :: Plutarch.Internal.PType) (eq :: Plutarch.Test.Property.HaskEquiv.Equality). (Plutarch.Test.Property.Marshal.Marshal h p, Plutarch.Test.Property.HaskEquiv.HaskEquiv eq 'Plutarch.Test.Property.HaskEquiv.TotalFun h p ('[] @GHC.Types.Type)) => Plutarch.Test.Property.HaskEquiv.HaskEquiv eq 'Plutarch.Test.Property.HaskEquiv.PartialFun h p ('[] @GHC.Types.Type)


-- | Extra properties based on <a>prop_haskEquiv</a>
module Plutarch.Test.Property.Extra

-- | <tt>l</tt> is a left inverse of <tt>r</tt>
--   
--   See
--   <a>https://en.wikipedia.org/wiki/Inverse_function#Left_inverses</a>
--   
--   Like <a>prop_haskEquiv</a>, you want to call this with
--   <tt>TypeApplications</tt> specifying the value of <tt>e</tt>. For
--   example,
--   
--   <pre>
--   &gt;&gt;&gt; prop_leftInverse
--     @'OnPEq
--     mapJoin
--     mapSplit
--     $ mapOf (pairOf integer integer) rational
--   </pre>
prop_leftInverse :: forall e p p' h. (LamArgs h ~ '[], HaskEquiv e 'TotalFun (h -> h) (p :--> p) '[h]) => ClosedTerm (p' :--> p) -> ClosedTerm (p :--> p') -> Gen h -> Property

-- | A Plutarch term that is a <a>PIsData</a> can be encoded to and decoded
--   back to the same value.
prop_dataRoundTrip :: forall h p. (LamArgs h ~ '[], Show h, Marshal h p, PIsData p, PEq p) => Gen h -> Property


-- | Helper for writing property tests for Plutarch terms.
module Plutarch.Test.Property

module Plutarch.Test.Run

-- | Ensures that there are no unused goldens left behind.
--   
--   Use this on any <a>SpecTree</a> that internally uses
--   <tt>pgoldenSpec</tt> to define the golden tests. These golden file
--   paths are accumulated, and compared to the actual files existing on
--   disk. If any golden file exists on disk, but is not tracked by the
--   <a>SpecTree</a> this function will fail, reporting the list of
--   untracked golden files.
--   
--   <b>Example:</b>
--   
--   <pre>
--   noUnusedGoldens =&lt;&lt; hspecAndReturnForest spec
--   
--   </pre>
noUnusedGoldens :: [SpecTree ()] -> IO ()

-- | Like <a>noUnusedGoldens</a> but takes a custom path to the golden
--   storage.
--   
--   NOTE: This relies on the assumption that the same <a>GoldenConf</a> is
--   used in all <tt>pgoldenSpec'</tt> calls. This function will go away
--   after https:/<i>github.com</i>Plutonomicon<i>plutarch</i>issues/458
noUnusedGoldens' :: GoldenConf -> [SpecTree ()] -> IO ()

-- | Like <tt>hspec</tt>, but returns the test forest after running the
--   tests.
--   
--   Based on
--   <a>https://github.com/hspec/hspec/issues/649#issuecomment-1092423220</a>
hspecAndReturnForest :: Spec -> IO [SpecTree ()]


-- | Common functions for testing Plutarch code
module Plutarch.Test

-- | Asserts the term to be true
passert :: ClosedTerm a -> Expectation

-- | Asserts the term to be false
passertNot :: ClosedTerm a -> Expectation

-- | Asserts the term evaluates without success
pfails :: ClosedTerm a -> Expectation

-- | Asserts the term evaluates successfully without failing
psucceeds :: ClosedTerm a -> Expectation

-- | Asserts that the term evaluates successfully with the given trace
--   sequence
ptraces :: ClosedTerm a -> [Text] -> Expectation

-- | Like <a>shouldBe</a> but but for Plutarch terms
pshouldBe :: ClosedTerm a -> ClosedTerm b -> Expectation

-- | Like <tt>@?=</tt> but for Plutarch terms
(#@?=) :: ClosedTerm a -> ClosedTerm b -> Expectation

-- | Check that the given benchmark is within certain maximum values.
--   
--   Use this to ensure that a program's benchmark doesn't exceed expected
--   values (such as script size or memory budget). You will need this
--   because,
--   
--   <ul>
--   <li><a>Test</a>'s golden testing uses maximum possible ExBudget for
--   evaluating programs</li>
--   <li>You may want to check that the script size is within a certain
--   value</li>
--   </ul>
psatisfyWithinBenchmark :: Benchmark -> Benchmark -> Expectation

-- | Specify goldens for the given Plutarch program
(@|) :: forall t a. HasGoldenValue t => GoldenKey -> (forall s. t s a) -> PlutarchGoldens
infixr 0 @|

-- | Add an expectation for the Plutarch program specified with (@|)
(@\) :: GoldenKey -> PlutarchGoldens -> PlutarchGoldens

-- | Test an expectation on a golden Plutarch program
(@->) :: ClosedTerm a -> (ClosedTerm a -> Expectation) -> TermExpectation a
infixr 1 @->

-- | Like <a>@-&gt;</a> but also takes the evaluated script and benchmark
--   as arguments
--   
--   Useful to do assertion checks on post-evaluation benchmark (eg: to
--   check if script size is below certain threshold) -- use in conjunction
--   with <tt>psatisfyWithinBenchmark</tt> -- or on evaluated script (ie.,
--   without re-evaluating the program).
(@:->) :: ClosedTerm a -> ((ClosedTerm a, Script, Benchmark) -> Expectation) -> TermExpectation a
infixr 1 @:->

-- | Test that the Plutarch program evaluates to the given term
(@==) :: ClosedTerm a -> ClosedTerm b -> TermExpectation a
infixr 1 @==

-- | Create golden specs for pre/post-eval UPLC and benchmarks.
--   
--   A *single* golden file will be created (for each metric) for all the
--   programs in the given tree.
--   
--   For example, ``` pgoldenSpec $ do "foo" <tt>| pconstant 42 "bar" </tt>
--   do "qux" @| pconstant <a>Hello</a> ```
--   
--   Will create three golden files -- uplc.golden, uplc.eval.golden and
--   bench.golden -- each containing three lines one for each program
--   above. Hierarchy is represented by intercalating with a dot; for
--   instance, the key for <tt>qux</tt> will be "bar.qux".
pgoldenSpec :: HasCallStack => PlutarchGoldens -> Spec

-- | Like <a>pgoldenSpec</a> but takes a <a>GoldenConf</a> to determine
--   which goldens to track.
--   
--   <pre>
--   pgoldenSpec = pgoldenSpec' def
--   </pre>
pgoldenSpec' :: HasCallStack => GoldenConf -> PlutarchGoldens -> Spec
type PlutarchGoldens = ListSyntax (GoldenKey, GoldenValue)
data GoldenConf
GoldenConf :: Set GoldenTest -> FilePath -> GoldenConf
[$sel:chosenTests:GoldenConf] :: GoldenConf -> Set GoldenTest

-- | Directory to put the goldens in.
[$sel:goldenBasePath:GoldenConf] :: GoldenConf -> FilePath
data GoldenTest

-- | The unevaluated UPLC (compiled target of Plutarch term)
GoldenT'UPLCPreEval :: GoldenTest

-- | The evaluated UPLC (evaluated result of Plutarch term)
GoldenT'UPLCPostEval :: GoldenTest

-- | Benchmark of Plutarch term (will never fail)
GoldenT'Bench :: GoldenTest
data Benchmark
Benchmark :: ExCPU -> ExMemory -> ScriptSizeBytes -> Benchmark

-- | CPU budget used by the script.
[$sel:exBudgetCPU:Benchmark] :: Benchmark -> ExCPU

-- | Memory budget used by the script.
[$sel:exBudgetMemory:Benchmark] :: Benchmark -> ExMemory

-- | Size of Plutus script in bytes
[$sel:scriptSizeBytes:Benchmark] :: Benchmark -> ScriptSizeBytes
data ScriptSizeBytes

-- | Ensures that there are no unused goldens left behind.
--   
--   Use this on any <a>SpecTree</a> that internally uses
--   <tt>pgoldenSpec</tt> to define the golden tests. These golden file
--   paths are accumulated, and compared to the actual files existing on
--   disk. If any golden file exists on disk, but is not tracked by the
--   <a>SpecTree</a> this function will fail, reporting the list of
--   untracked golden files.
--   
--   <b>Example:</b>
--   
--   <pre>
--   noUnusedGoldens =&lt;&lt; hspecAndReturnForest spec
--   
--   </pre>
noUnusedGoldens :: [SpecTree ()] -> IO ()

-- | Like <a>noUnusedGoldens</a> but takes a custom path to the golden
--   storage.
--   
--   NOTE: This relies on the assumption that the same <a>GoldenConf</a> is
--   used in all <tt>pgoldenSpec'</tt> calls. This function will go away
--   after https:/<i>github.com</i>Plutonomicon<i>plutarch</i>issues/458
noUnusedGoldens' :: GoldenConf -> [SpecTree ()] -> IO ()

-- | Like <tt>hspec</tt>, but returns the test forest after running the
--   tests.
--   
--   Based on
--   <a>https://github.com/hspec/hspec/issues/649#issuecomment-1092423220</a>
hspecAndReturnForest :: Spec -> IO [SpecTree ()]
